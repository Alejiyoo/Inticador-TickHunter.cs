//
// Copyright (C) 2020, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.Globalization;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.Code;
using System.Threading;
using System.Collections.Concurrent;
using System.IO;
using NinjaTrader.NinjaScript.Indicators.TickHunterTA.TH;
using NinjaTrader.NinjaScript.Indicators.TickHunterTA;


#endregion


// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators.TickHunterTA
{
    [Description(@"TickHunter - Use TickHunter at your own risk.  None of the authors, contributors, administrators, or anyone else connected with TickHunter, in any way whatsoever, can be responsible or held liable for using this trading tool.")]
    public partial class TickHunter : Indicator
    {
        private const string SystemVersion = "v1.506";
        private const string SystemName = "TickHunter";
        private const string FullSystemName = SystemName + " - " + SystemVersion;
        private const string SystemDescription = "Use TickHunter at your own risk.  None of the authors, contributors, administrators, or anyone else connected with TickHunter, in any way whatsoever, can be responsible or held liable for using this trading tool.";
        private const string SignalName = "TickHunter";
        private const string ObjectPrefix = "th_";
        private const string InfoLink = "https://discord.gg/HUt7dQrBYc";
        //private const string TickHunterSessionStateFileName = "TickHunterSessionState.csv";

        private const string CloseAlertMessageTitle = SystemName + " - Close Alert";
        private const string CloseAlertAltMessageTitle = CloseAlertMessageTitle + " (Alt)";
        private const string BuyZombieAlertMessageTitle = SystemName + " - Buy Zombie Alert";
        private const string BuyZombieAlertAltMessageTitle = BuyZombieAlertMessageTitle + " (Alt)";
        private const string BuyCreeperAlertMessageTitle = SystemName + " - Buy Creeper Alert";
        private const string BuyCreeperAlertAltMessageTitle = BuyCreeperAlertMessageTitle + " (Alt)";
        private const string SellZombieAlertMessageTitle = SystemName + " - Sell Zombie Alert";
        private const string SellZombieAlertAltMessageTitle = SellZombieAlertMessageTitle + " (Alt)";
        private const string SellCreeperAlertMessageTitle = SystemName + " - Sell Creeper Alert";
        private const string SellCreeperAlertAltMessageTitle = SellCreeperAlertMessageTitle + " (Alt)";

        private const string BuySliderAlertMessageTitle = SystemName + " - Buy Slider Alert";
        private const string SellSliderAlertMessageTitle = SystemName + " - Sell Slider Alert";

        private const int ZombieSetupBuyCode = 1;
        private const int ZombieSetupSellCode = -1;
        private const int ZombieSetupNoCode = 0;
        private const int StingRayHigherHighCode = 1;
        private const int StingRayLowerLowCode = -1;
        private const int StingRayNoChangeCode = 0;

        private const int AveragePriceLineZOrder = 50000;

        private Account account = null;
        private string atmStrategyName = string.Empty;
        private NinjaTrader.Gui.Tools.AccountSelector accountSelector = null;
        private System.Windows.Threading.DispatcherTimer timer;
        private double lastAccountBalance = 0;
        private DateTime lastOrderOutputTime = DateTime.MinValue;
        private bool hasRanOnceFirstCycle = false;
        private bool hasDrawnButtons = false;
        private bool accountHadPositions = false;
        private RealLogger RealLogger = new RealLogger(SystemName);
        private RealInstrumentService RealInstrumentService = new RealInstrumentService();

        private RealPositionService RealPositionService = new RealPositionService();
        private RealOrderService RealOrderService = new RealOrderService();
        private Dictionary<long, Order> ninjaTraderOrders = new Dictionary<long, Order>();
        private List<RealSessionState> accountSessionState = new List<RealSessionState>();
        private bool IsNinjaTraderOrdersAlreadyLoaded = false;
        private bool isIndicatorSuspended = false;

        private RealRunOncePerBar AutoPilotRunOncePerBar = new RealRunOncePerBar();
        private RealRunOncePerBar AutoAddOnRunOncePerBar = new RealRunOncePerBar();
        private RealRunOncePerBar AutoCloseRunOncePerBar = new RealRunOncePerBar();
        private RealRunOncePerBar AutoBreakEvenRunOncePerBar = new RealRunOncePerBar();
        private RealRunOncePerBar PopDelayedEntryRunOncePerBar = new RealRunOncePerBar();

        private readonly object ThreadManagerLock = new object();
        private readonly object AccountLock = new object();
        private readonly object ClosePositionLock = new object();
        private readonly object FlattenEverythingLock = new object();
        private readonly object NewPositionLock = new object();
        private readonly object MarketOrderLock = new object();
        private readonly object RefreshTPSLLock = new object();
        private readonly object RefreshPositionInfoLock = new object();
        private readonly object PopAutoJumpToSnapLock = new object();
        private readonly object DropAutoJumpToSnapLock = new object();
        private readonly object ClosePositionsInProfitLock = new object();
        private readonly object ClosePositionsInLossLock = new object();
        private readonly object RealTimePipelineLock = new object();
        private readonly object DelayedPipelineLock = new object();
        private string lastATMStopLossStrategyName = string.Empty;
        private string lastATMTakeProfitStrategyName = string.Empty;

        private System.Windows.Controls.Grid thLayoutGrid = null;
        private System.Windows.Controls.Grid buttonGrid = null;
        private System.Windows.Controls.Grid labelGrid = null;
        private System.Windows.Controls.Button toggleAutoBEButton = null;
        private System.Windows.Controls.Button closeAllButton = null;
        private System.Windows.Controls.Button toggleAutoCloseButton = null;
        private System.Windows.Controls.Button BEButton = null;
        private System.Windows.Controls.Button SLButton = null;
        private System.Windows.Controls.Button TPButton = null;
        private System.Windows.Controls.Button revButton = null;
        private System.Windows.Controls.Button BuyDropButton = null;
        private System.Windows.Controls.Button SellDropButton = null;
        private System.Windows.Controls.Button BuyPopButton = null;
        private System.Windows.Controls.Button SellPopButton = null;
        private System.Windows.Controls.Button BuyMarketButton = null;
        private System.Windows.Controls.Button SellMarketButton = null;
        private System.Windows.Controls.Button toggleProfitTargetButton = null;
        private System.Windows.Controls.Button toggleEntryVolumeMaxButton = null;
        private System.Windows.Controls.Button toggleEntryVolumeAutoButton = null;
        private System.Windows.Controls.Button toggleAutoAddOnButton = null;
        private System.Windows.Controls.Button toggleTradeSignalButton = null;
        private System.Windows.Controls.Button toggleAutoPilotProfileButton = null;
        private System.Windows.Controls.Button toggleAutoPilotButton = null;
        private System.Windows.Controls.TextBlock riskInfoLabel = null;
        private System.Windows.Controls.TextBlock profitInfoLabel = null;
        private System.Windows.Controls.TextBlock bogeyTargetInfoLabel = null;
        private System.Windows.Controls.TextBlock dayOverMaxLossInfoLabel = null;
        private System.Windows.Controls.TextBlock hordeTradeCopierInfoLabel = null;

        private const string ToggleReverseButtonText = "Rev";
        private const string ToggleReverseButtonToolTip = "Reverse Position";
        private const string ToggleReverseBButtonText = "RevB";
        private const string ToggleReverseBButtonToolTip = "Reverse Blended Positions";
        private const string ToggleCloseButtonText = "Close";
        private const string ToggleCloseButtonToolTip = "Close Position";
        private const string ToggleFlatButtonText = "Flat";
        private const string ToggleFlatButtonToolTip = "Flatten Everything";
        private const string ToggleCloseBButtonText = "CloseB";
        private const string ToggleCloseBButtonToolTip = "Close Blended Positions";
        private const string ToggleTPButtonText = "TP+";
        private const string ToggleTPButtonToolTip = "Take-Profit Jump";
        private const string ToggleBEButtonText = "BE+";
        private const string ToggleBEButtonToolTip = "Break-Even Jump";
        private const string ToggleSLButtonText = "SL+";
        private const string ToggleSLButtonToolTip = "Stop-Loss Jump";
        private const string ToggleBuyMarketButtonText = "Buy";
        private const string ToggleBuyMarketButtonToolTip = "Buy Market";
        private const string ToggleSellMarketButtonText = "Sell";
        private const string ToggleSellMarketButtonToolTip = "Sell Market";
        private const string TogglePopBuyButtonText = "Pop+ {0}";
        private const string TogglePopBuyButtonToolTip = "Pop+ Buy Stop{0}";
        private const string TogglePopSellButtonText = "Pop- {0}";
        private const string TogglePopSellButtonToolTip = "Pop- Sell Stop{0}";

        private const string TogglePopBuyDelayedButtonDisabledText = "Pop+ {0}";
        private const string TogglePopBuyDelayedButtonDisabledToolTip = "Pop+ Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount1Text = "Pop+(1) {0}";
        private const string TogglePopBuyDelayedButtonCount1ToolTip = "Pop+(1) Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount2Text = "Pop+(2) {0}";
        private const string TogglePopBuyDelayedButtonCount2ToolTip = "Pop+(2) Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount3Text = "Pop+(3) {0}";
        private const string TogglePopBuyDelayedButtonCount3ToolTip = "Pop+(3) Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount4Text = "Pop+(4) {0}";
        private const string TogglePopBuyDelayedButtonCount4ToolTip = "Pop+(4) Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount5Text = "Pop+(5) {0}";
        private const string TogglePopBuyDelayedButtonCount5ToolTip = "Pop+(5) Buy Stop Delayed Entry{0}";

        private const string TogglePopSellDelayedButtonDisabledText = "Pop- {0}";
        private const string TogglePopSellDelayedButtonDisabledToolTip = "Pop- Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount1Text = "Pop-(1) {0}";
        private const string TogglePopSellDelayedButtonCount1ToolTip = "Pop-(1) Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount2Text = "Pop-(2) {0}";
        private const string TogglePopSellDelayedButtonCount2ToolTip = "Pop-(2) Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount3Text = "Pop-(3) {0}";
        private const string TogglePopSellDelayedButtonCount3ToolTip = "Pop-(3) Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount4Text = "Pop-(4) {0}";
        private const string TogglePopSellDelayedButtonCount4ToolTip = "Pop-(4) Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount5Text = "Pop-(5) {0}";
        private const string TogglePopSellDelayedButtonCount5ToolTip = "Pop-(5) Sell Stop Delayed Entry{0}";

        private const string ToggleDropBuyButtonText = "Drop+";
        private const string ToggleDropBuyButtonToolTip = "Drop+ Buy Limit";
        private const string ToggleDropSellButtonText = "Drop-";
        private const string ToggleDropSellButtonToolTip = "Drop- Sell Limit";

        private const string ToggleAutoPPButtonDisabledText = "APP.OFF";
        private const string ToggleAutoPPButtonDisabledToolTip = "Auto Pilot Profile Off";
        private const string ToggleAutoPPPButtonEnabledText = "PEPPY{0}";
        private const string ToggleAutoPPPButtonEnabledToolTip = "Auto Pilot Profile Peppy{0}";
        private const string ToggleAutoPPSButtonEnabledText = "SLEEPY{0}";
        private const string ToggleAutoPPSButtonEnabledToolTip = "Auto Pilot Profile Sleepy{0}";


        private const string ToggleAutoBEButtonDisabledText = "AB.OFF";
        private const string ToggleAutoBEButtonDisabledToolTip = "Auto Break-Even Off";
        private const string ToggleAutoBEButtonEnabledText = "AB.ON";
        private const string ToggleAutoBEButtonEnabledToolTip = "Auto Break-Even On";
        private const string ToggleAutoBEHDLButtonEnabledText = "HODL";
        private const string ToggleAutoBEHDLButtonEnabledToolTip = "HODL";
        private const string ToggleCZFTButtonEnabledText = "CZF+T";
        private const string ToggleCZFTButtonEnabledToolTip = "Creeper & Zombie Flip + Trail";
        private const string ToggleCFTButtonEnabledText = "CF+T";
        private const string ToggleCFTButtonEnabledToolTip = "Creeper Flip + Trail";
        private const string ToggleAutoBETZRButtonEnabledText = "ZF+RT";
        private const string ToggleAutoBETZRButtonEnabledToolTip = "Zombie Flip + Resume Trail";
        private const string ToggleAutoBET5BButtonEnabledText = "AB.T5B{0}";
        private const string ToggleAutoBET5BButtonEnabledToolTip = "Auto Break-Even + Trail 5 Bars{0}";
        private const string ToggleAutoBET3BButtonEnabledText = "AB.T3B{0}";
        private const string ToggleAutoBET3BButtonEnabledToolTip = "Auto Break-Even + Trail 3 Bars{0}";
        private const string ToggleAutoBET2BButtonEnabledText = "AB.T2B{0}";
        private const string ToggleAutoBET2BButtonEnabledToolTip = "Auto Break-Even + Trail 2 Bars{0}";
        private const string ToggleAutoBET1BButtonEnabledText = "AB.T1B{0}";
        private const string ToggleAutoBET1BButtonEnabledToolTip = "Auto Break-Even + Trail 1 Bar{0}";
        private const string ToggleAutoBETMXButtonEnabledText = "AB.TMX{0}";
        private const string ToggleAutoBETMXButtonEnabledToolTip = "Auto Break-Even + Trail Mix{0}";
        private const string ToggleAutoBETZFButtonEnabledText = "AB.TZF{0}";
        private const string ToggleAutoBETZFButtonEnabledToolTip = "Auto Break-Even + Trail Zombie Flip{0}";

        private const string ToggleAutoBETSLButtonEnabledText = "AB.TSL{0}";
        private const string ToggleAutoBETSLButtonEnabledToolTip = "Auto Break-Even + Trail SpeedLine ({1}){0}";
        private const string ToggleAutoBETRLButtonEnabledText = "AB.TRL{0}";
        private const string ToggleAutoBETRLButtonEnabledToolTip = "Auto Break-Even + Trail RushLine ({1}){0}";
        private const string ToggleAutoBETM4ButtonEnabledText = "AB.TM4{0}";
        private const string ToggleAutoBETM4ButtonEnabledToolTip = "Auto Break-Even + Trail EMA 4 ({1}){0}";
        private const string ToggleAutoBETM3ButtonEnabledText = "AB.TM3{0}";
        private const string ToggleAutoBETM3ButtonEnabledToolTip = "Auto Break-Even + Trail EMA 3 ({1}){0}";
        private const string ToggleAutoBETM2ButtonEnabledText = "AB.TM2{0}";
        private const string ToggleAutoBETM2ButtonEnabledToolTip = "Auto Break-Even + Trail EMA 2 ({1}){0}";
        private const string ToggleAutoBETM1ButtonEnabledText = "AB.TM1{0}";
        private const string ToggleAutoBETM1ButtonEnabledToolTip = "Auto Break-Even + Trail EMA 1 ({1}){0}";
        private const string ToggleAutoBETD4ButtonEnabledText = "AB.TD4{0}";
        private const string ToggleAutoBETD4ButtonEnabledToolTip = "Auto Break-Even + Trail SMA 4 ({1}){0}";
        private const string ToggleAutoBETD3ButtonEnabledText = "AB.TD3{0}";
        private const string ToggleAutoBETD3ButtonEnabledToolTip = "Auto Break-Even + Trail SMA 3 ({1}){0}";
        private const string ToggleAutoBETD2ButtonEnabledText = "AB.TD2{0}";
        private const string ToggleAutoBETD2ButtonEnabledToolTip = "Auto Break-Even + Trail SMA 2 ({1}){0}";
        private const string ToggleAutoBETD1ButtonEnabledText = "AB.TD1{0}";
        private const string ToggleAutoBETD1ButtonEnabledToolTip = "Auto Break-Even + Trail SMA 1 ({1}){0}";
        private const string ToggleAutoBETR1ButtonEnabledText = "AB.TR1{0}";
        private const string ToggleAutoBETR1ButtonEnabledToolTip = "Auto Break-Even + Trail River 1 ({1}){0}";
        private const string ToggleAutoBETR5ButtonEnabledText = "AB.TR5{0}";
        private const string ToggleAutoBETR5ButtonEnabledToolTip = "Auto Break-Even + Trail River 5 ({1}){0}";

        private const string ToggleAutoBETC1ButtonEnabledText = "AB.TC1{0}";
        private const string ToggleAutoBETC1ButtonEnabledToolTip = "Auto Break-Even + Trail Creek 1 ({1}){0}";
        private const string ToggleAutoBETC5ButtonEnabledText = "AB.TC5{0}";
        private const string ToggleAutoBETC5ButtonEnabledToolTip = "Auto Break-Even + Trail Creek 5 ({1}){0}";

        private const string ToggleAutoBETSButtonEnabledText = "AB.TSR{0}";
        private const string ToggleAutoBETSButtonEnabledToolTip = "Auto Break-Even + Trail Sting Ray {0}";
        private const string ToggleAutoBETXButtonEnabledText = "AB.TX{0}";
        private const string ToggleAutoBETXButtonEnabledToolTip = "Auto Break-Even + Trail X{0}";
        private const string ToggleAutoBETMButtonEnabledText = "AB.TM{0}";
        private const string ToggleAutoBETMButtonEnabledToolTip = "Auto Break-Even + Trail Monster{0}";
        private const string ToggleAutoBETDMButtonEnabledText = "AB.TDM{0}";
        private const string ToggleAutoBETDMButtonEnabledToolTip = "Auto Break-Even + Trail Drift Monster{0}";
        private const string ToggleAutoBETKLDButtonEnabledText = "AB.TKD{0}";
        private const string ToggleAutoBETKLDButtonEnabledToolTip = "Auto Break-Even + Trail KLine Dual ({1}){0}";
        private const string ToggleAutoBETZL2ButtonEnabledText = "AB.TZL{0}";
        private const string ToggleAutoBETZL2ButtonEnabledToolTip = "Auto Break-Even + Trail ZipLine 2 ({1}){0}";
        private const string ToggleAutoBETZLDButtonEnabledText = "AB.TZD{0}";
        private const string ToggleAutoBETZLDButtonEnabledToolTip = "Auto Break-Even + Trail ZipLine Dual ({1}){0}";
        private const string ToggleAutoBETKZDButtonEnabledText = "AB.TKZ{0}";
        private const string ToggleAutoBETKZDButtonEnabledToolTip = "Auto Break-Even + Trail KLine Dual + ZLine Dual ({1}){0}";

        private const string ToggleAutoBETBSButtonEnabledText = "AB.TBS{0}";
        private const string ToggleAutoBETBSButtonEnabledToolTip = "Auto Break-Even + Trail Boss {0}";

        private const string ToggleAutoBEPLButtonEnabledText = "AB.PL{0}";
        private const string ToggleAutoBEPLButtonEnabledToolTip = "Auto Break-Even + Profile Peppy{0}";
        private const string ToggleAutoBEPSButtonEnabledText = "AB.PS{0}";
        private const string ToggleAutoBEPSButtonEnabledToolTip = "Auto Break-Even + Profile Sleepy{0}";

        private const string ToggleAutoCloseButtonDisabledText = "AC.OFF";
        private const string ToggleAutoCloseButtonDisabledToolTip = "Auto Close Off";
        private const string ToggleAutoCloseM1SButtonEnabledText = "AC.M1S{0}";
        private const string ToggleAutoCloseM1SButtonEnabledToolTip = "Auto Close MA 1 Slope{0}";
        private const string ToggleAutoCloseM2SButtonEnabledText = "AC.M2S{0}";
        private const string ToggleAutoCloseM2SButtonEnabledToolTip = "Auto Close MA 2 Slope{0}";
        private const string ToggleAutoCloseM3SButtonEnabledText = "AC.M3S{0}";
        private const string ToggleAutoCloseM3SButtonEnabledToolTip = "Auto Close MA 3 Slope{0}";
        private const string ToggleAutoCloseM4BButtonEnabledText = "AC.M4B{0}";
        private const string ToggleAutoCloseM4BButtonEnabledToolTip = "Auto Close MA 4 Break{0}";
        private const string ToggleAutoCloseDL4BButtonEnabledText = "AC.D4B{0}";
        private const string ToggleAutoCloseDL4BButtonEnabledToolTip = "Auto Close DriftLine 4 Break{0}";
        private const string ToggleAutoCloseKLDFButtonEnabledText = "AC.KD{0}";
        private const string ToggleAutoCloseKLDFButtonEnabledToolTip = "Auto Close KLine Dual Flip{0}";
        private const string ToggleAutoCloseZFButtonEnabledText = "AC.ZF{0}";
        private const string ToggleAutoCloseZFButtonEnabledToolTip = "Auto Close Zombie Flip{0}";
        private const string ToggleAutoCloseZSFButtonEnabledText = "AC.ZSF{0}";
        private const string ToggleAutoCloseZSFButtonEnabledToolTip = "Auto Close Zombie Stacked Flip{0}";
        private const string ToggleAutoCloseZBFButtonEnabledText = "AC.ZBF{0}";
        private const string ToggleAutoCloseZBFButtonEnabledToolTip = "Auto Close Zombie Boosted Flip{0}";
        private const string ToggleAutoCloseCFButtonEnabledText = "AC.CF{0}";
        private const string ToggleAutoCloseCFButtonEnabledToolTip = "Auto Close Creeper Flip{0}";
        private const string ToggleAutoCloseZLDButtonEnabledText = "AC.ZD{0}";
        private const string ToggleAutoCloseZLDButtonEnabledToolTip = "Auto Close ZipLine Dual Flip{0}";
        private const string ToggleAutoCloseKZButtonEnabledText = "AC.KZ{0}";
        private const string ToggleAutoCloseKZButtonEnabledToolTip = "Auto Close KDual + ZDual Flip{0}";

        private const string ToggleAutoClosePLButtonEnabledText = "AC.PL{0}";
        private const string ToggleAutoClosePLButtonEnabledToolTip = "Auto Close Profile Peppy{0}";
        private const string ToggleAutoClosePSButtonEnabledText = "AC.PS{0}";
        private const string ToggleAutoClosePSButtonEnabledToolTip = "Auto Close Profile Sleepy{0}";

        private const string ToggleTradeSignalButtonDisabledText = "S.OFF";
        private const string ToggleTradeSignalButtonDisabledToolTip = "Trade Signal Off";
        private const string ToggleTradeSignalBSAButtonEnabledText = "S.BS.A";
        private const string ToggleTradeSignalBSAButtonEnabledTextToolTip = "Trade Signal All";
        private const string ToggleTradeSignalBSFButtonEnabledText = "S.BS.F";
        private const string ToggleTradeSignalBSFButtonEnabledTextToolTip = "Trade Signal Filtered";
        private const string ToggleTradeSignalBOButtonEnabledText = "S.BO";
        private const string ToggleTradeSignalBOButtonEnabledTextToolTip = "Trade Signal Buy Only";
        private const string ToggleTradeSignalSOButtonEnabledText = "S.SO";
        private const string ToggleTradeSignalSOButtonEnabledTextToolTip = "Trade Signal Sell Only";

        private string ToggleAutoEntryVolOption1ButtonEnabledText = "V(1)";
        private string ToggleAutoEntryVolOption1ButtonEnabledToolTip = "Volume (1)";
        private string ToggleAutoEntryVolOption2ButtonEnabledText = "V(2)";
        private string ToggleAutoEntryVolOption2ButtonEnabledToolTip = "Volume (2)";
        private string ToggleAutoEntryVolOption3ButtonEnabledText = "V(3)";
        private string ToggleAutoEntryVolOption3ButtonEnabledToolTip = "Volume (3)";
        private string ToggleAutoEntryVolOption4ButtonEnabledText = "V(4)";
        private string ToggleAutoEntryVolOption4ButtonEnabledToolTip = "Volume (4)";
        private string ToggleAutoEntryVolOption5ButtonEnabledText = "V(5)";
        private string ToggleAutoEntryVolOption5ButtonEnabledToolTip = "Volume (5)";

        private string ToggleEntryVolMaxOption1ButtonEnabledText = "VM(1)";
        private string ToggleEntryVolMaxOption1ButtonEnabledToolTip = "Volume Max (1)";
        private string ToggleEntryVolMaxOption2ButtonEnabledText = "VM(2)";
        private string ToggleEntryVolMaxOption2ButtonEnabledToolTip = "Volume Max (2)";
        private string ToggleEntryVolMaxOption3ButtonEnabledText = "VM(3)";
        private string ToggleEntryVolMaxOption3ButtonEnabledToolTip = "Volume Max (3)";
        private string ToggleEntryVolMaxOption4ButtonEnabledText = "VM(4)";
        private string ToggleEntryVolMaxOption4ButtonEnabledToolTip = "Volume Max (4)";
        private string ToggleEntryVolMaxOption5ButtonEnabledText = "VM(5)";
        private string ToggleEntryVolMaxOption5ButtonEnabledToolTip = "Volume Max (5)";

        private const string ToggleAutoPilotLiteButtonDisabledText = "APL.OFF";
        private const string ToggleAutoPilotLiteButtonDisabledToolTip = "Auto Pilot Lite Off";
        private const string ToggleAutoPilotLiteNext1ButtonEnabledText = "APL.N(1){0}";
        private const string ToggleAutoPilotLiteNext1ButtonEnabledToolTip = "Auto Pilot Lite Next Trade 1{0}";
        private const string ToggleAutoPilotLiteNextFiltered1ButtonEnabledText = "APL.F(1){0}";
        private const string ToggleAutoPilotLiteNextFiltered1ButtonEnabledToolTip = "Auto Pilot Lite Next Filtered Trade 1{0}";
        private const string ToggleAutoPilotLiteBuy1ButtonEnabledText = "APL.B(1){0}";
        private const string ToggleAutoPilotLiteBuy1ButtonEnabledToolTip = "Auto Pilot Lite Buy Trade 1{0}";
        private const string ToggleAutoPilotLiteSell1ButtonEnabledText = "APL.S(1){0}";
        private const string ToggleAutoPilotLiteSell1ButtonEnabledToolTip = "Auto Pilot Lite Sell Trade 1{0}";
        private const string ToggleAutoPilotLiteAlertButtonEnabledText = "APL.Alert{0}";
        private const string ToggleAutoPilotLiteAlertButtonEnabledToolTip = "Auto Pilot Lite Alert Setups{0}";

        private const string ToggleAutoPilotButtonDisabledText = "AP.OFF";
        private const string ToggleAutoPilotButtonDisabledToolTip = "Auto Pilot Off";
        private const string ToggleAutoPilotCount1ButtonEnabledText = "AP.T(1){0}";
        private const string ToggleAutoPilotCount1ButtonEnabledToolTip = "Auto Pilot Trade 1{0}";
        private const string ToggleAutoPilotCount2ButtonEnabledText = "AP.T(2){0}";
        private const string ToggleAutoPilotCount2ButtonEnabledToolTip = "Auto Pilot Trade 2{0}";
        private const string ToggleAutoPilotCount3ButtonEnabledText = "AP.T(3){0}";
        private const string ToggleAutoPilotCount3ButtonEnabledToolTip = "Auto Pilot Trade 3{0}";
        private const string ToggleAutoPilotCount4ButtonEnabledText = "AP.T(4){0}";
        private const string ToggleAutoPilotCount4ButtonEnabledToolTip = "Auto Pilot Trade 4{0}";
        private const string ToggleAutoPilotCount5ButtonEnabledText = "AP.T(5){0}";
        private const string ToggleAutoPilotCount5ButtonEnabledToolTip = "Auto Pilot Trade 5{0}";
        private const string ToggleAutoPilotCount6ButtonEnabledText = "AP.T(6){0}";
        private const string ToggleAutoPilotCount6ButtonEnabledToolTip = "Auto Pilot Trade 6{0}";
        private const string ToggleAutoPilotCount7ButtonEnabledText = "AP.T(7){0}";
        private const string ToggleAutoPilotCount7ButtonEnabledToolTip = "Auto Pilot Trade 7{0}";
        private const string ToggleAutoPilotCount8ButtonEnabledText = "AP.T(8){0}";
        private const string ToggleAutoPilotCount8ButtonEnabledToolTip = "Auto Pilot Trade 8{0}";
        private const string ToggleAutoPilotCount9ButtonEnabledText = "AP.T(9){0}";
        private const string ToggleAutoPilotCount9ButtonEnabledToolTip = "Auto Pilot Trade 9{0}";
        private const string ToggleAutoPilotCount10ButtonEnabledText = "AP.T(10){0}";
        private const string ToggleAutoPilotCount10ButtonEnabledToolTip = "Auto Pilot Trade 10{0}";
        private const string ToggleAutoPilotCount11ButtonEnabledText = "AP.T(11){0}";
        private const string ToggleAutoPilotCount11ButtonEnabledToolTip = "Auto Pilot Trade 11{0}";
        private const string ToggleAutoPilotCount12ButtonEnabledText = "AP.T(12){0}";
        private const string ToggleAutoPilotCount12ButtonEnabledToolTip = "Auto Pilot Trade 12{0}";
        private const string ToggleAutoPilotCount13ButtonEnabledText = "AP.T(13){0}";
        private const string ToggleAutoPilotCount13ButtonEnabledToolTip = "Auto Pilot Trade 13{0}";
        private const string ToggleAutoPilotCount14ButtonEnabledText = "AP.T(14){0}";
        private const string ToggleAutoPilotCount14ButtonEnabledToolTip = "Auto Pilot Trade 14{0}";
        private const string ToggleAutoPilotCount15ButtonEnabledText = "AP.T(15){0}";
        private const string ToggleAutoPilotCount15ButtonEnabledToolTip = "Auto Pilot Trade 15{0}";
        private const string ToggleAutoPilotCount16ButtonEnabledText = "AP.T(16){0}";
        private const string ToggleAutoPilotCount16ButtonEnabledToolTip = "Auto Pilot Trade 16{0}";
        private const string ToggleAutoPilotCount17ButtonEnabledText = "AP.T(17){0}";
        private const string ToggleAutoPilotCount17ButtonEnabledToolTip = "Auto Pilot Trade 17{0}";
        private const string ToggleAutoPilotCount18ButtonEnabledText = "AP.T(18){0}";
        private const string ToggleAutoPilotCount18ButtonEnabledToolTip = "Auto Pilot Trade 18{0}";
        private const string ToggleAutoPilotCount19ButtonEnabledText = "AP.T(19){0}";
        private const string ToggleAutoPilotCount19ButtonEnabledToolTip = "Auto Pilot Trade 19{0}";
        private const string ToggleAutoPilotCount20ButtonEnabledText = "AP.T(20){0}";
        private const string ToggleAutoPilotCount20ButtonEnabledToolTip = "Auto Pilot Trade 20{0}";

        private const string ToggleAutoAddOnButtonDisabledText = "AA.OFF";
        private const string ToggleAutoAddOnButtonDisabledToolTip = "Auto AddOn Off (${0})";
        private const string ToggleAutoAddOnButtonEnabledText = "AA.ON";
        private string ToggleAutoAddOnButtonEnabledToolTip = "Auto AddOn On (${0})";

        private const string ToggleProfitTargetButtonDisabledText = "PT.OFF";
        private const string ToggleProfitTargetButtonDisabledToolTip = "Profit Target Off";
        private const string ToggleProfitTargetECAButtonEnabledText = "ECAT";
        private const string ToggleProfitTargetECAButtonEnabledToolTip = "Equity Close All Target";
        private const string ToggleProfitTargetX0ButtonEnabledText = "BT.X{0}{1}";
        private const string ToggleProfitTargetX0ButtonEnabledToolTip = "Bogey Target X{0}{1}";

        private const string HHToggleAutoBEButtonName = "HHToggleAutoBEButton";
        private const string HHCloseAllButtonName = "HHCloseAllButton";
        private const string HHToggleAutoCloseButtonName = "HHToggleAutoCloseButton";
        private const string HHToggleEntryVolumeAutoButtonName = "HHToggleEntryVolumeAutoButton";
        private const string HHToggleEntryVolumeMaxButtonName = "HHToggleEntryVolumeMaxButton";
        private const string HHToggleTradeSignalButtonName = "HHToggleTradeSignalButton";
        private const string HHToggleAutoPilotButtonName = "HHToggleAutoPilotButton";
        private const string HHToggleAutoPilotProfileButtonName = "HHToggleAutoPilotProfileButton";
        private const string HHToggleAutoAddOnButtonName = "HHToggleAutoAddOnButton";
        private const string HHToggleProfitTargetButtonName = "HHToggleProfitTargetButton";
        private const string HHBEButtonName = "HHBEButton";
        private const string HHSLButtonName = "HHSLButton";
        private const string HHTPButtonName = "HHTPButton";
        private const string HHRevButtonName = "HHRevButton";
        private const string HHBuyDropButtonName = "HHBDropButton";
        private const string HHSellDropButtonName = "HHSDropButton";
        private const string HHBuyPopButtonName = "HHBPopButton";
        private const string HHSellPopButtonName = "HHSPopButton";
        private const string HHBuyMarketButtonName = "HHBMarketButton";
        private const string HHSellMarketButtonName = "HHSMarketButton";
        private const string HHRiskInfoLabelName = "HHRILabel";
        private const string HHProfitInfoLabelName = "HHPILabel";
        private const string HHBogeyTargetInfoLabelName = "HHBTILabel";
        private const string HHDayOverMaxLossInfoLabelName = "HHDOMLILabel";
        private const string HHHordeTradeCopierInfoLabelName = "HHHTCILabel";


        private const double MIN_EXCESS_MARGIN = 25;
        private const int MICRO_TO_EMINI_MULTIPLIER = 10;
        private const int DEFAULT_VOLUME_SIZE = 1;

        private DateTime lastFlattenEverythingCycleChangeTime = DateTime.MinValue;
        private const int FlattenEverythingThrottleSeconds = 5;

        private bool bypassAutoPositionTakeProfit = false;

        private DateTime lastTakeProfitThrottleChangeTime = DateTime.MinValue;
        private const int DefaultTakeProfitThrottleIncrementSeconds = 5;
        private int nextTakeProfitThrottleSeconds = 0;
        private int lastTakeProfitLogThrottleSeconds = 0;
        private int lastTakeProfitMismatchContracts = 0;

        private DateTime lastTakeProfitBlendThrottleChangeTime = DateTime.MinValue;
        private const int DefaultTakeProfitBlendThrottleIncrementSeconds = 5;
        private int nextTakeProfitBlendThrottleSeconds = 0;
        private int lastTakeProfitBlendLogThrottleSeconds = 0;
        private int lastTakeProfitBlendMismatchContracts = 0;
        
        // Delayed take profit creation for batching position changes
        private readonly object DelayedTakeProfitLock = new object();
        private DateTime scheduledTakeProfitCreationTime = DateTime.MinValue;
        private Instrument scheduledTakeProfitInstrument = null;
        private OrderAction? scheduledTakeProfitOrderAction = null;
        private int scheduledTakeProfitQuantity = 0;
        private double scheduledTakeProfitPrice = 0;
        private bool hasScheduledTakeProfit = false;
        
        // Delayed stop loss creation for batching position changes
        private readonly object DelayedStopLossLock = new object();
        private DateTime scheduledStopLossCreationTime = DateTime.MinValue;
        private Instrument scheduledStopLossInstrument = null;
        private OrderAction? scheduledStopLossOrderAction = null;
        private int scheduledStopLossQuantity = 0;
        private double scheduledStopLossPrice = 0;
        private bool hasScheduledStopLoss = false;

        private DateTime lastStopLossThrottleChangeTime = DateTime.MinValue;
        private const int DefaultStopLossThrottleIncrementSeconds = 5;
        private int nextStopLossThrottleSeconds = 0;
        private int lastStopLossLogThrottleSeconds = 0;

        private DateTime lastStopLossBlendThrottleChangeTime = DateTime.MinValue;
        private const int DefaultStopLossBlendThrottleIncrementSeconds = 5;
        private int nextStopLossBlendThrottleSeconds = 0;
        private int lastStopLossBlendLogThrottleSeconds = 0;
        
        // Performance optimization: Track last TPSL refresh time for throttling
        private DateTime lastTPSLRefreshTime = DateTime.MinValue;
        private const int TPSL_REFRESH_THROTTLE_MS = 100; // Minimum 100ms between calls

        private const int BogeyTargetLineChangePlotIndex = 0;
        private Brush bogeyTargetLineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetLineDashStyle;
        private int bogeyTargetLineWidth = 1;
        private double bogeyTargetMultiplier = 1;
        private bool bogeyTargetStartWithFullPnLFlag = true;
        private int maxInitialTrancheVolumeSize = DEFAULT_VOLUME_SIZE;

        private int limitedVolumeMaxSize = DEFAULT_VOLUME_SIZE;

        private const int BogeyTargetBreakEvenLineChangePlotIndex = 1;
        private Brush bogeyTargetBreakEvenLineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetBreakEvenLineDashStyle;
        private int bogeyTargetBreakEvenLineWidth = 1;
        private bool bogeyTargetBreakEvenLineIsBrushTransparent = false;

        private const int BogeyTargetDaily1LineChangePlotIndex = 2;
        private Brush bogeyTargetDaily1LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily1LineDashStyle;
        private int bogeyTargetDaily1LineWidth = 1;
        private bool bogeyTargetDaily1LineIsBrushTransparent = false;

        private const int BogeyTargetDaily2LineChangePlotIndex = 3;
        private Brush bogeyTargetDaily2LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily2LineDashStyle;
        private int bogeyTargetDaily2LineWidth = 1;
        private bool bogeyTargetDaily2LineIsBrushTransparent = false;

        private const int BogeyTargetDaily3LineChangePlotIndex = 4;
        private Brush bogeyTargetDaily3LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily3LineDashStyle;
        private int bogeyTargetDaily3LineWidth = 1;
        private bool bogeyTargetDaily3LineIsBrushTransparent = false;

        private const int BogeyTargetDaily4LineChangePlotIndex = 5;
        private Brush bogeyTargetDaily4LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily4LineDashStyle;
        private int bogeyTargetDaily4LineWidth = 1;
        private bool bogeyTargetDaily4LineIsBrushTransparent = false;

        private const int BogeyTargetDaily5LineChangePlotIndex = 6;
        private Brush bogeyTargetDaily5LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily5LineDashStyle;
        private int bogeyTargetDaily5LineWidth = 1;
        private bool bogeyTargetDaily5LineIsBrushTransparent = false;

        private const int DayOverMaxLossLineChangePlotIndex = 7;
        private Brush dayOverMaxLossInfoTextColor = Brushes.Silver;
        private Brush dayOverMaxLossLineBrush = Brushes.Transparent;
        private DashStyleHelper dayOverMaxLossLineDashStyle;
        private int dayOverMaxLossLineWidth = 1;

        private const int DayOverAccountBalanceFloorLineChangePlotIndex = 8;
        private Brush dayOverAccountBalanceFloorLineBrush = Brushes.Transparent;
        private DashStyleHelper dayOverAccountBalanceFloorLineDashStyle;
        private int dayOverAccountBalanceFloorLineWidth = 1;

        private const int ECATakeProfitLineChangePlotIndex = 9;
        private Brush ecaTakeProfitLineBrush = Brushes.Transparent;
        private DashStyleHelper ecaTakeProfitLineDashStyle;
        private int ecaTakeProfitLineWidth = 1;

        private const int AveragePriceLineChangePlotIndex = 10;
        private Brush averagePriceLineBrush = Brushes.Transparent;
        private DashStyleHelper averagePriceLineDashStyle;
        private int averagePriceLineWidth = 1;
        private double averagePriceLevelHorizontalOffset = 50;
        private bool averagePriceLineIsBrushTransparent = false;

        private TickHunterEntryVolumeAutoTypes currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
        private TickHunterEntryVolumeAutoTypes lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
        private TickHunterEntryVolumeAutoTypes nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
        private DateTime lastEntryVolumeAutoChangeTime = DateTime.MinValue;
        private const int EntryVolumeAutoColorDelaySeconds = 1;

        private TickHunterEntryVolumeMaxTypes currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
        private TickHunterEntryVolumeMaxTypes lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
        private TickHunterEntryVolumeMaxTypes nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
        private DateTime lastEntryVolumeMaxChangeTime = DateTime.MinValue;
        private const int EntryVolumeMaxColorDelaySeconds = 1;

        private TickHunterTradeSignalTypes currentTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
        private TickHunterTradeSignalTypes lastToggleEntryTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
        private TickHunterTradeSignalTypes nextTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
        private DateTime lastTradeSignalChangeTime = DateTime.MinValue;
        private const int TradeSignalColorDelaySeconds = 5;

        private TickHunterAutoPilotTypes currentAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
        private TickHunterAutoPilotTypes lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
        private TickHunterAutoPilotTypes nextAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
        private DateTime lastAutoPilotChangeTime = DateTime.MinValue;
        private const int AutoPilotColorDelaySeconds = 1;
        private bool useAutoPilotAddOnFlag = true;

        private TickHunterAutoPilotOrderTypes currentAutoPilotOrderStatus = TickHunterAutoPilotOrderTypes.Market;

        private TickHunterAutoPilotLiteTypes currentAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
        private TickHunterAutoPilotLiteTypes lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
        private TickHunterAutoPilotLiteTypes nextAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
        private DateTime lastAutoPilotLiteChangeTime = DateTime.MinValue;
        private const int AutoPilotLiteColorDelaySeconds = 3;
        private bool isTradeAlertMessageBoxOpen = false;

        private TickHunterAutoAddOnTypes currentAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
        private TickHunterAutoAddOnTypes lastToggleEntryAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
        private TickHunterAutoAddOnTypes nextAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
        private DateTime lastAutoAddOnChangeTime = DateTime.MinValue;
        private const int AutoAddOnColorDelaySeconds = 3;
        private const int AutoAddOnInnerWindowDelaySeconds = 5;
        const double DEFAULT_ADDON_MAX_DOLLARS = 1;
        double autoAddOnMaxDollars = DEFAULT_ADDON_MAX_DOLLARS;

        private DateTime lastAddOnMaxCycleChangeTime = DateTime.MinValue;
        private const int AutoAddOnMaxCycleDelaySeconds = 5;

        private TickHunterCloseAutoTypes currentCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
        private TickHunterCloseAutoTypes lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
        private TickHunterCloseAutoTypes nextCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
        private DateTime lastCloseAutoChangeTime = DateTime.MinValue;
        private const int CloseAutoColorDelaySeconds = 5;
        private bool closeAutoMinProfitFlag = false;
        private bool closeAutoAlertFlag = false;

        private TickHunterBreakEvenAutoTypes currentBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
        private TickHunterBreakEvenAutoTypes lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
        private TickHunterBreakEvenAutoTypes nextBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
        private DateTime lastBreakEvenAutoChangeTime = DateTime.MinValue;
        private const int BeakEvenAutoColorDelaySeconds = 5;
        private bool breakEvenAutoHODLFlag = false;
        private TickHunterBreakEvenAutoTrailNowTypes breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.Disabled;

        private TickHunterAutoPilotSetupTypes currentAutoPilotSetupStatus = TickHunterAutoPilotSetupTypes.ZombieOnly;

        private TickHunterAutoPilotProfileTypes currentAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
        private TickHunterAutoPilotProfileTypes lastToggleAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
        private TickHunterAutoPilotProfileTypes nextAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
        private DateTime lastAutoPilotProfileChangeTime = DateTime.MinValue;
        private const int AutoPilotProfileColorDelaySeconds = 3;
        private bool autoPilotProfileAutoAdjustFlag = false;

        private TickHunterAutoPilotProfileSetupTypes currentAutoPilotProfileSetupStatus = TickHunterAutoPilotProfileSetupTypes.ZombieOrCreeperCombo;

        private TickHunterProfitTargetTypes currentProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
        private TickHunterProfitTargetTypes lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
        private TickHunterProfitTargetTypes nextProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
        private const int BogeyTargetMultiplierDisabled = 0;
        private int currentBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
        private int lastToggleEntryBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
        private int nextBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
        private DateTime lastProfitTargetChangeTime = DateTime.MinValue;
        private const int BogeyTargetColorDelaySeconds = 5;

        private bool useBuyPopActivateFlag = false;
        private DateTime lastBuyPopActivateChangeTime = DateTime.MinValue;
        private bool useSellPopActivateFlag = false;
        private DateTime lastSellPopActivateChangeTime = DateTime.MinValue;

        private bool popCTRLDelayedEntryFlag = true;
        private int popDelayedEntryMaxCountFlag = 1;

        private TickHunterPopDelayedTypes currentBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private TickHunterPopDelayedTypes lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private TickHunterPopDelayedTypes nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private DateTime lastBuyPopDelayedChangeTime = DateTime.MinValue;

        private TickHunterPopDelayedTypes currentSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private TickHunterPopDelayedTypes lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private TickHunterPopDelayedTypes nextSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private DateTime lastSellPopDelayedChangeTime = DateTime.MinValue;

        private const int PopActivateColorDelaySeconds = 1;

        private TickHunterStopLossSnapTypes currentStopLossInitialSnapStatus = TickHunterStopLossSnapTypes.Disabled;

        //private string HedgehogEntrySymbol1FullName = "";
        //private string HedgehogEntrySymbol2FullName = "";

        private Instrument attachedInstrument = null;
        private bool attachedInstrumentIsEmini = false;
        private bool attachedInstrumentIsFuture = false;
        private bool attachedInstrumentServerSupported = false;
        private double attachedInstrumentTickSize = 0;
        private double attachedInstrumentTickValue = 0;
        private int attachedInstrumentTicksPerPoint = 0;
        private double attachedInstrumentCommissionPerSide = 0;
        private int attachedInstrumentPositionMaxVolume = 0;
        private double attachedInstrumentIntradayMarginDollars = 0;

        private EMA autoCloseAndTrailMA1Buffer;
        private EMA autoCloseAndTrailMA2Buffer;
        private EMA autoCloseAndTrailMA3Buffer;
        private EMA autoCloseAndTrailMA4Buffer;
        private EMA autoCloseAndTrailR1HBuffer;
        private EMA autoCloseAndTrailR1LBuffer;
        private EMA autoCloseAndTrailR5HBuffer;
        private EMA autoCloseAndTrailR5LBuffer;
        private HMA autoCloseAndTrailZL1Buffer;
        private HMA autoCloseAndTrailZL2Buffer;
        private HMA autoCloseAndTrailZL3Buffer;
        private HMA autoCloseAndTrailZL4Buffer;
        private SMA autoCloseAndTrailRLBuffer;
        private SMA autoCloseAndTrailDL1Buffer;
        private SMA autoCloseAndTrailDL2Buffer;
        private SMA autoCloseAndTrailDL3Buffer;
        private SMA autoCloseAndTrailDL4Buffer;

        private SMA autoCloseAndTrailDL3HBuffer;
        private SMA autoCloseAndTrailDL3LBuffer;
        private SMA autoCloseAndTrailDL4HBuffer;
        private SMA autoCloseAndTrailDL4LBuffer;

        private double autoPilotSetupCreeperValue;
        private double autoPilotSetupCreeperValue2;
        private double autoPilotSetupCreeperValue3;
        private double autoPilotSetupCreeperValue4;
        private double autoPilotSetupCreeperValue5;
        private double autoPilotSetupCreeperValue6;
        private double autoPilotSetupCreeperValue7;
        private double autoPilotSetupCreeperValue8;
        private double autoPilotSetupCreeperValue9;
        private double autoPilotSetupCreeperValue10;

        private double recentCreeperBuyHighPrice = 0;
        private double recentCreeperBuyLowPrice = 0;
        private double recentCreeperSellHighPrice = 0;
        private double recentCreeperSellLowPrice = 0;

        private bool autoPilotSetupCreeperBuyContinuation1;
        private bool autoPilotSetupCreeperSellContinuation1;

        private double autoCloseAndTrailMA1Value;
        private double autoCloseAndTrailMA1Value2;
        private double autoCloseAndTrailMA1Value3;

        private double autoCloseAndTrailMA2Value;
        private double autoCloseAndTrailMA2Value2;
        private double autoCloseAndTrailMA2Value3;

        private double autoCloseAndTrailMA3Value;
        private double autoCloseAndTrailMA3Value2;
        private double autoCloseAndTrailMA3Value3;

        private double autoCloseAndTrailMA4Value;
        private double autoCloseAndTrailMA4Value2;
        private double autoCloseAndTrailMA4Value3;
        private double autoCloseAndTrailMA4Value4;
        private double autoCloseAndTrailMA4Value5;
        private double autoCloseAndTrailMA4Value6;
        private double autoCloseAndTrailMA4Value7;
        private double autoCloseAndTrailMA4Value8;
        private double autoCloseAndTrailMA4Value9;
        private double autoCloseAndTrailMA4Value10;

        private double autoCloseAndTrailR1HValue;
        private double autoCloseAndTrailR1LValue;

        private double autoCloseAndTrailR5HValue;
        private double autoCloseAndTrailR5LValue;

        private double autoCloseAndTrailZL1Value;
        private double autoCloseAndTrailZL1Value2;
        private double autoCloseAndTrailZL2Value;
        private double autoCloseAndTrailZL2Value2;
        private double autoCloseAndTrailZL3Value;
        private double autoCloseAndTrailZL3Value2;
        private double autoCloseAndTrailZL4Value;
        private double autoCloseAndTrailZL4Value2;

        private double autoCloseAndTrailRLValue;
        private double autoCloseAndTrailRLValue2;
        private double autoCloseAndTrailRLValue3;
        private double autoCloseAndTrailRLValue4;

        private double autoCloseAndTrailDL1Value;
        private double autoCloseAndTrailDL2Value;
        private double autoCloseAndTrailDL3Value;

        private double autoCloseAndTrailDL4Value;
        private double autoCloseAndTrailDL4Value2;
        private double autoCloseAndTrailDL4Value3;
        private double autoCloseAndTrailDL4Value4;
        private double autoCloseAndTrailDL4Value5;
        private double autoCloseAndTrailDL4Value6;
        private double autoCloseAndTrailDL4Value7;
        private double autoCloseAndTrailDL4Value8;
        private double autoCloseAndTrailDL4Value9;
        private double autoCloseAndTrailDL4Value10;
        private double autoCloseAndTrailDL4Value11;
        private double autoCloseAndTrailDL4Value12;
        private double autoCloseAndTrailDL4Value13;
        private double autoCloseAndTrailDL4Value14;
        private double autoCloseAndTrailDL4Value15;

        private double autoCloseAndTrailDL3HValue;
        private double autoCloseAndTrailDL3LValue;

        private double autoCloseAndTrailDL4HValue;
        private double autoCloseAndTrailDL4LValue;

        private THStingRay stingRayBuffer;

        private double stingRayHighLevel1Value;
        private double stingRayHighLevel2Value;
        private double stingRayHighLevel3Value;
        private double stingRayHighLevel4Value;
        private double stingRayHighLevel5Value;

        private double stingRayLowLevel1Value;
        private double stingRayLowLevel2Value;
        private double stingRayLowLevel3Value;
        private double stingRayLowLevel4Value;
        private double stingRayLowLevel5Value;

        private double stingRayRecentHigherHighValue;
        private double stingRayRecentLowerLowValue;

        private double stingRayCreeperCycleCountValue;
        private double stingRaySurgeBarCountValue;
        private double stingRaySurgeBarCycleTickSpeedValue;
        private double stingRayGush1BarCountValue;
        private double stingRayGush1BarCycleTickSpeedValue;

        private double stingRayFlow1BarCountValue;
        private double stingRayFlow1BarCycleTickSpeedValue;
        private double stingRayFlow2BarCountValue;
        private double stingRayFlow2BarCycleTickSpeedValue;
        private double stingRayFlow3BarCountValue;
        private double stingRayFlow3BarCycleTickSpeedValue;
        private double stingRayFlow4BarCountValue;
        private double stingRayFlow4BarCycleTickSpeedValue;


        private THPowerBox snapPowerBoxBuffer;
        private double snapPowerBoxMiddleValue;
        private double snapPowerBoxUpperValue;
        private double snapPowerBoxUpperValue10;
        private double snapPowerBoxUpperValue20;
        private double snapPowerBoxUpperValue30;
        private double snapPowerBoxUpperValue40;
        private double snapPowerBoxUpperValue50;
        private double snapPowerBoxLowerValue;
        private double snapPowerBoxLowerValue10;
        private double snapPowerBoxLowerValue20;
        private double snapPowerBoxLowerValue30;
        private double snapPowerBoxLowerValue40;
        private double snapPowerBoxLowerValue50;

        private THKeltnerATR keltnerATRBuffer;

        private double keltnerUpperInnerRingValue;
        private double keltnerLowerInnerRingValue;

        private int KeltnerPeriod = 21;
        private int KeltnerATRPeriod = 21;
        private double KeltnerOffsetMultiplier1 = 2;
        private double KeltnerOffsetMultiplier2 = 3;
        private double KeltnerOffsetMultiplier3 = 2;
        private double KeltnerOffsetMultiplier4 = 3;

        private EMA autoPilotSetupWalkerBuffer;
        private double autoPilotSetupWalkerValue;
        private double autoPilotSetupWalkerValue2;

        private EMA autoPilotSpeedLineFilterBuffer;
        private double autoPilotSpeedLineFilterValue;
        private double autoPilotSpeedLineFilterValue2;
        private double autoPilotSpeedLineFilterValue3;
        private double autoPilotSpeedLineFilterValue4;
        private double autoPilotSpeedLineFilterValue5;
        private double autoPilotSpeedLineFilterValue6;
        private double autoPilotSpeedLineFilterValue7;
        private double autoPilotSpeedLineFilterValue8;
        private double autoPilotSpeedLineFilterValue9;
        private double autoPilotSpeedLineFilterValue10;

        private EMA autoPilotFilterBuffer;

        bool autoPilotBullishTrend = true;
        bool autoPilotBullishDriftTrend = true;
        bool autoPilotBullishRiverTrend = true;

        private THZombieSetup autoPilotSetupZombieBuffer;
        private THZombieSetup autoPilotSetupZombie2Buffer;
        private THCreeperSetup autoPilotSetupCreeperBuffer;

        private double autoPilotSetupZombieValue;
        private double autoPilotSetupZombieValue2;
        private double autoPilotSetupZombieValue3;
        private double autoPilotSetupZombieValue4;
        private double autoPilotSetupZombieValue5;
        private double autoPilotSetupZombieValue6;
        private double autoPilotSetupZombieValue7;
        private double autoPilotSetupZombieValue8;
        private double autoPilotSetupZombieValue9;
        private double autoPilotSetupZombieValue10;

        private bool autoPilotSetupZombieBuyContinuation1;
        private bool autoPilotSetupZombieBuyContinuation2;
        private bool autoPilotSetupZombieBuyContinuation3;
        private bool autoPilotSetupZombieBuyContinuation4;
        private bool autoPilotSetupZombieBuyContinuation5;
        private bool autoPilotSetupZombieBuyContinuation6;
        private bool autoPilotSetupZombieBuyContinuation7;
        private bool autoPilotSetupZombieBuyContinuation8;

        private bool autoPilotSetupZombieSellContinuation1;
        private bool autoPilotSetupZombieSellContinuation2;
        private bool autoPilotSetupZombieSellContinuation3;
        private bool autoPilotSetupZombieSellContinuation4;
        private bool autoPilotSetupZombieSellContinuation5;
        private bool autoPilotSetupZombieSellContinuation6;
        private bool autoPilotSetupZombieSellContinuation7;
        private bool autoPilotSetupZombieSellContinuation8;

        private bool autoPilotSetupZombie2BuyContinuation1;
        private bool autoPilotSetupZombie2SellContinuation1;

        private bool autoPilotSetupZombieBuySetup1;
        private bool autoPilotSetupZombieSellSetup1;
        private bool autoPilotSetupZombieBuySetup2;
        private bool autoPilotSetupZombieSellSetup2;
        private bool autoPilotSetupZombieBuySetup3;
        private bool autoPilotSetupZombieSellSetup3;
        private bool autoPilotSetupZombieBuySetup4;
        private bool autoPilotSetupZombieSellSetup4;
        private bool autoPilotSetupZombieBuySetup5;
        private bool autoPilotSetupZombieSellSetup5;
        private bool autoPilotSetupZombieBuySetup6;
        private bool autoPilotSetupZombieSellSetup6;
        private bool autoPilotSetupZombieBuySetup7;
        private bool autoPilotSetupZombieSellSetup7;
        private bool autoPilotSetupZombieBuySetup8;
        private bool autoPilotSetupZombieSellSetup8;
        private bool autoPilotSetupZombieBuySetup9;
        private bool autoPilotSetupZombieSellSetup9;

        private double recentZombieBuyHighPrice = 0;
        private double recentZombieBuyLowPrice = 0;
        private double recentZombieSellHighPrice = 0;
        private double recentZombieSellLowPrice = 0;

        private THZombieSetup autoCloseAndTrailKLine1Buffer;
        private double autoCloseAndTrailKLine1Value;

        private THZombieSetup autoCloseAndTrailKLine2Buffer;
        private double autoCloseAndTrailKLine2Value;


        private Instrument mnqInstrument = null;
        private Instrument mesInstrument = null;
        private Instrument mymInstrument = null;
        private Instrument m2kInstrument = null;
        private Instrument nqInstrument = null;
        private Instrument esInstrument = null;
        private Instrument ymInstrument = null;
        private Instrument rtyInstrument = null;
        private double mymLastAsk = 0;
        private double mymLastBid = 0;
        private double mesLastAsk = 0;
        private double mesLastBid = 0;
        private double m2kLastAsk = 0;
        private double m2kLastBid = 0;
        private double mnqLastAsk = 0;
        private double mnqLastBid = 0;
        private int marketDataBidAskPulseStatus = 0;
        private int marketDataBidAskChangeStatus = 0;
        private const string MNQPrefix = "MNQ";
        private const string MESPrefix = "MES";
        private const string MYMPrefix = "MYM";
        private const string M2KPrefix = "M2K";

        private double ymLastAsk = 0;
        private double ymLastBid = 0;
        private double esLastAsk = 0;
        private double esLastBid = 0;
        private double rtyLastAsk = 0;
        private double rtyLastBid = 0;
        private double nqLastAsk = 0;
        private double nqLastBid = 0;
        private const string NQPrefix = "NQ";
        private const string ESPrefix = "ES";
        private const string YMPrefix = "YM";
        private const string RTYPrefix = "RTY";

        private double maxDDInDollars = 0;
        private double lastAccountBalanceFloorDollars = 0;

        private bool validateAttachedPositionStopLossQuantityStage1 = false;
        private bool validateAttachedPositionTakeProfitQuantityStage1 = false;
        private bool validateBlendedPositionStopLossQuantityStage1 = false;
        private bool validateBlendedPositionTakeProfitQuantityStage1 = false;

        private bool validateAttachedPositionStopLossQuantity = false;
        private bool validateAttachedPositionTakeProfitQuantity = false;
        private bool validateBlendedPositionStopLossQuantity = false;
        private bool validateBlendedPositionTakeProfitQuantity = false;

        private bool riskInfoHasChanged = false;
        private MarketPosition riskInfoMarketPosition = MarketPosition.Flat;
        private int riskInfoQuantity = 0;
        private double riskInfoPositionPrice = 0;

        private bool profitInfoHasChanged = false;
        private MarketPosition profitInfoMarketPosition = MarketPosition.Flat;
        private int profitInfoQuantity = 0;
        private double profitInfoPositionPrice = 0;

        private double dayOverMaxLossDollars = 0;
        private bool dayOverMaxLossHasChanged = false;
        private MarketPosition dayOverMaxLossMarketPosition = MarketPosition.Flat;
        private int dayOverMaxLossPositionQuantity = 0;
        private double dayOverMaxLossPositionPrice = 0;
        private double dayOverMaxAccountPnLPeakDollars = 0;
        private double lastDayOverMaxLossAccountPnLPeakInfoDollars = 0;
        private string lastDayOverMaxAccountPnLPeakLabelText = "";
        //private DateTime lastDayOverMaxLossHighestPnLInSessionChangeDate = DateTime.MinValue;
        //private double lastDayOverMaxLossHighestPnLInSessionPnL = 0;
        private double lastDayOverMaxLossInfoDollars = 0;
        private string lastDayOverMaxLossLabelText = "";
        private double lastDayOverMaxLossDollars = 0;
        private MarketPosition lastDayOverMaxLossPositionType = MarketPosition.Flat;
        private double lastDayOverMaxLossClosedOrderProfit = 0;
        private double lastDayOverMaxLossPositionPrice = 0;
        private int lastDayOverMaxLossPositionQuantity = 0;
        private double lastDayOverMaxLossLinePrice = 0;
        private bool activeDayOverMaxLossAutoClose = false;
        private bool dayOverMaxLossLineVisible = false;

        private double dayBreakEvenDollars = 0;
        private bool dayBreakEvenHasChanged = false;
        private MarketPosition dayBreakEvenMarketPosition = MarketPosition.Flat;
        private int dayBreakEvenPositionQuantity = 0;
        private double dayBreakEvenPositionPrice = 0;
        private bool dayBreakEvenLineVisible = false;
        private double lastDayBreakEvenDollars = 0;
        private double lastDayBreakEvenLinePrice = 0;
        private MarketPosition lastDayBreakEvenPositionType = MarketPosition.Flat;
        private double lastDayBreakEvenPositionPrice = 0;
        private int lastDayBreakEvenPositionQuantity = 0;

        private bool bogeyTargetHasChanged = false;

        private bool hordeTradeCopierHasChanged = false;
        private string hordeTradeCopierInfoTextCache = string.Empty;
        private string profitInfoTextCache = string.Empty;
        private string riskInfoTextCache = string.Empty;
        private string bogeyTargetInfoTextCache = string.Empty;
        private string dayOverMaxLossInfoTextCache = string.Empty;
        
        // Foreground brush caches
        private Brush profitInfoForegroundCache = Brushes.White;
        private Brush riskInfoForegroundCache = Brushes.White;
        private Brush hordeTradeCopierForegroundCache = Brushes.Silver;
        
        // Visibility caches
        private Visibility profitInfoVisibilityCache = Visibility.Hidden;
        private Visibility riskInfoVisibilityCache = Visibility.Hidden;
        private Visibility bogeyTargetInfoVisibilityCache = Visibility.Hidden;
        private Visibility dayOverMaxLossInfoVisibilityCache = Visibility.Hidden;
        private Visibility hordeTradeCopierInfoVisibilityCache = Visibility.Hidden;
        
        // Label grid background cache
        private Brush labelGridBackgroundCache = Brushes.Transparent;
        
        // StringBuilder for text concatenation
        private StringBuilder labelTextBuilder = new StringBuilder(256);
        
        // Label refresh throttling
        private DateTime lastLabelRefreshTime = DateTime.MinValue;
        private const double LABEL_REFRESH_THROTTLE_MS = 50;
        private DateTime lastNoOpenPositionsCheckTime = DateTime.MinValue;
        private bool cachedNoOpenPositionsResult = true;
        private MarketPosition bogeyTargetMarketPosition = MarketPosition.Flat;
        private int bogeyTargetPositionQuantity = 0;
        private double bogeyTargetPositionPrice = 0;
        private double lastBogeyTargetInfoDollars = 0;
        private double lastBogeyTargetBaseDollars = 0;
        private MarketPosition lastBogeyTargetPositionType = MarketPosition.Flat;
        private double lastBogeyTargetClosedOrderProfit = 0;
        private double lastBogeyTargetPositionPrice = 0;
        private int lastBogeyTargetPositionQuantity = 0;
        private double lastBogeyTargetLinePrice = 0;
        private bool bogeyTargetLineVisible = false;

        private bool bogeyTargetBreakEvenLineVisible = false;
        private double lastBogeyTargetBreakEvenDollars = 0;
        private double lastBogeyTargetBreakEvenLinePrice = 0;

        private bool bogeyTargetDaily1LineVisible = false;
        private double lastBogeyTargetDaily1Dollars = 0;
        private double lastBogeyTargetDaily1LinePrice = 0;

        private bool bogeyTargetDaily2LineVisible = false;
        private double lastBogeyTargetDaily2Dollars = 0;
        private double lastBogeyTargetDaily2LinePrice = 0;

        private bool bogeyTargetDaily3LineVisible = false;
        private double lastBogeyTargetDaily3Dollars = 0;
        private double lastBogeyTargetDaily3LinePrice = 0;

        private bool bogeyTargetDaily4LineVisible = false;
        private double lastBogeyTargetDaily4Dollars = 0;
        private double lastBogeyTargetDaily4LinePrice = 0;

        private bool bogeyTargetDaily5LineVisible = false;
        private double lastBogeyTargetDaily5Dollars = 0;
        private double lastBogeyTargetDaily5LinePrice = 0;


        private bool dayOverAccountBalanceFloorHasChanged = false;
        private MarketPosition dayOverAccountBalanceFloorMarketPosition = MarketPosition.Flat;
        private int dayOverAccountBalanceFloorPositionQuantity = 0;
        private double dayOverAccountBalanceFloorPositionPrice = 0;
        private double lastDayOverAccountBalanceFloorInfoDollars = 0;
        private double lastDayOverAccountBalanceFloorDollars = 0;
        private MarketPosition lastDayOverAccountBalanceFloorPositionType = MarketPosition.Flat;
        private double lastDayOverAccountBalanceFloorPositionPrice = 0;
        private int lastDayOverAccountBalanceFloorPositionQuantity = 0;
        private double lastDayOverAccountBalanceFloorLinePrice = 0;
        private double lastDayOverAccountBalance = 0;
        private double lastDayOverAccountFloorInfoDollars = 0;
        private string lastDayOverAccountFloorLabelText = "";
        private DateTime lastDayOverAccountBalanceRefreshTime = DateTime.MinValue;
        private const int DayOverAccountBalanceRefreshDelaySeconds = 10;
        private bool dayOverAccountBalanceFloorLineVisible = false;

        private double cacheECATakeProfitDollars = 0;
        private bool ecaTakeProfitHasChanged = false;
        private MarketPosition ecaTakeProfitMarketPosition = MarketPosition.Flat;
        private int ecaTakeProfitPositionQuantity = 0;
        private double ecaTakeProfitPositionPrice = 0;
        private double lastECATakeProfitInfoDollars = 0;
        private double lastECATakeProfitDollars = 0;
        private MarketPosition lastECATakeProfitPositionType = MarketPosition.Flat;
        private double lastECATakeProfitClosedOrderProfit = 0;
        private double lastECATakeProfitPositionPrice = 0;
        private int lastECATakeProfitPositionQuantity = 0;
        private double lastECATakeProfitLinePrice = 0;
        private bool ecaTakeProfitLineVisible = false;

        private bool averagePriceHasChanged = false;
        private MarketPosition averagePriceMarketPosition = MarketPosition.Flat;
        private int averagePricePositionQuantity = 0;
        private double averagePricePositionPrice = 0;
        private double lastAveragePriceInfoDollars = 0;
        private double lastAveragePriceDollars = 0;
        private MarketPosition lastAveragePricePositionType = MarketPosition.Flat;
        private double lastAveragePriceClosedOrderProfit = 0;
        private double lastAveragePricePositionPrice = 0;
        private int lastAveragePricePositionQuantity = 0;
        private double lastAveragePriceLinePrice = 0;
        private bool averagePriceLineVisible = false;

        private bool attachedInstrumentHasChanged = false;
        private bool attachedInstrumentHasPosition = false;
        private int attachedInstrumentPositionBarCount = 0;
        private double attachedInstrumentPositionCreeperCycleCount = 0;
        private bool attachedInstrumentPositionCreeperSurging = false;
        private bool attachedInstrumentPositionCreeperGushing1 = false;
        private bool attachedInstrumentPositionFlowing1 = false;
        private bool attachedInstrumentPositionFlowing2 = false;
        private bool attachedInstrumentPositionFlowing3 = false;
        private bool attachedInstrumentPositionFlowing4 = false;
        private MarketPosition attachedInstrumentMarketPosition = MarketPosition.Flat;
        private double attachedInstrumentPositionPnL = 0;
        private int attachedInstrumentPositionQuantity = 0;
        private double attachedInstrumentPositionPrice = 0;
        private double attachedInstrumentPositionStopLossPrice = 0;
        private double attachedInstrumentPositionTakeProfitPrice = 0;
        private MarketPosition lastAttachedInstrumentPositionType = MarketPosition.Flat;
        private double lastAttachedInstrumentPositionPrice = 0;
        private int lastAttachedInstrumentPositionQuantity = 0;

        private bool blendedInstrumentHasChanged = false;
        private bool blendedInstrumentHasPosition = false;
        private double blendedInstrumentPositionCreeperCycleCount = 0;
        private bool blendedInstrumentPositionCreeperSurging = false;
        private Instrument blendedInstrument = null;
        private MarketPosition blendedInstrumentMarketPosition = MarketPosition.Flat;
        private int blendedInstrumentPositionQuantity = 0;
        private double blendedInstrumentPositionPrice = 0;
        private double blendedInstrumentPositionStopLossPrice = 0;
        private double blendedInstrumentPositionTakeProfitPrice = 0;
        private double lastBlendedInstrumentInfoDollars = 0;
        private double lastBlendedInstrumentDollars = 0;
        private MarketPosition lastBlendedInstrumentPositionType = MarketPosition.Flat;
        private double lastBlendedInstrumentPositionPrice = 0;
        private int lastBlendedInstrumentPositionQuantity = 0;

        const double BarPeriodSecondInterval = 60;
        private double barPeriodSecondInterval = BarPeriodSecondInterval;

        private bool limitTrancheVolumeToInProfitFlag = false;
        private bool popLimitToPullbackFlag = false;
        private bool limitTrancheVolumePerBarFlag = false;

        private double lastAccountIntradayExcessMargin = 0;
        private ATR atrBuffer;
        private double atrValue = 0;

        private string fullSoundFilename = "";

        private bool isTickHunterActivated = false;
        private bool isTickHunterAlreadyLoaded = false;

        private int currentBarCount = 0;
        private double previous1ClosePrice = 0;
        private double previous2ClosePrice = 0;
        private double previous3ClosePrice = 0;
        private double previous4ClosePrice = 0;
        private double previous5ClosePrice = 0;
        private double previous6ClosePrice = 0;
        private double previous7ClosePrice = 0;
        private double previous8ClosePrice = 0;
        private double previous9ClosePrice = 0;
        private double previous10ClosePrice = 0;
        private double previous11ClosePrice = 0;
        private double previous12ClosePrice = 0;
        private double previous13ClosePrice = 0;
        private double previous14ClosePrice = 0;
        private double previous15ClosePrice = 0;
        private double previous16ClosePrice = 0;
        private double previous17ClosePrice = 0;
        private double previous18ClosePrice = 0;
        private double previous19ClosePrice = 0;
        private double previous20ClosePrice = 0;
        private double previous1LowPrice = 0;
        private double previous2LowPrice = 0;
        private double previous3LowPrice = 0;
        private double previous4LowPrice = 0;
        private double previous5LowPrice = 0;
        private double previous6LowPrice = 0;
        private double previous7LowPrice = 0;
        private double previous8LowPrice = 0;
        private double previous9LowPrice = 0;
        private double previous10LowPrice = 0;
        private double previous11LowPrice = 0;
        private double previous12LowPrice = 0;
        private double previous13LowPrice = 0;
        private double previous14LowPrice = 0;
        private double previous15LowPrice = 0;
        private double previous16LowPrice = 0;
        private double previous17LowPrice = 0;
        private double previous18LowPrice = 0;
        private double previous19LowPrice = 0;
        private double previous20LowPrice = 0;

        private double previous1HighPrice = 0;
        private double previous2HighPrice = 0;
        private double previous3HighPrice = 0;
        private double previous4HighPrice = 0;
        private double previous5HighPrice = 0;
        private double previous6HighPrice = 0;
        private double previous7HighPrice = 0;
        private double previous8HighPrice = 0;
        private double previous9HighPrice = 0;
        private double previous10HighPrice = 0;
        private double previous11HighPrice = 0;
        private double previous12HighPrice = 0;
        private double previous13HighPrice = 0;
        private double previous14HighPrice = 0;
        private double previous15HighPrice = 0;
        private double previous16HighPrice = 0;
        private double previous17HighPrice = 0;
        private double previous18HighPrice = 0;
        private double previous19HighPrice = 0;
        private double previous20HighPrice = 0;
        private bool previous1CandleBullish = false;
        private bool previous2CandleBullish = false;
        private bool previous3CandleBullish = false;
        private bool previous4CandleBullish = false;
        private bool previous5CandleBullish = false;
        private bool previous6CandleBullish = false;
        private bool previous7CandleBullish = false;
        private bool previous8CandleBullish = false;

        private bool inBuySliderSetupCycle = false;
        private bool inSellSliderSetupCycle = false;

        private bool usedBuySliderSetupCycle = false;
        private bool usedSellSliderSetupCycle = false;

        private Key buyMarketHotKeyValue = Key.None;
        private Key sellMarketHotKeyValue = Key.None;
        private Key buyPopHotKeyValue = Key.None;
        private Key sellPopHotKeyValue = Key.None;
        private Key closeHotKeyValue = Key.None;
        private Key reverseHotKeyValue = Key.None;
        private Key breakEvenPlusHotKeyValue = Key.None;
        private Key stopLossPlusHotKeyValue = Key.None;
        private Key volumeHotKeyValue = Key.None;
        private Key activateHotKeyValue = Key.None;

        private bool hasFollowerAccounts = false;
        private Account followerAccount1 = null;
        private Account followerAccount2 = null;
        private Account followerAccount3 = null;
        private Account followerAccount4 = null;
        private Account followerAccount5 = null;
        private Account followerAccount6 = null;
        private Account followerAccount7 = null;
        private Account followerAccount8 = null;
        private Account followerAccount9 = null;
        private Account followerAccount10 = null;
        private Account followerAccount11 = null;
        private Account followerAccount12 = null;
        private Account followerAccount13 = null;
        private Account followerAccount14 = null;
        private Account followerAccount15 = null;
        private Account followerAccount16 = null;
        private Account followerAccount17 = null;
        private Account followerAccount18 = null;
        private Account followerAccount19 = null;
        private Account followerAccount20 = null;
        private Account followerAccount21 = null;
        private Account followerAccount22 = null;
        private Account followerAccount23 = null;
        private Account followerAccount24 = null;
        
        // Cached parsed TradeSize values for performance (parsed once during LoadAccount, not on every execution)
        private int follower1Multiplier = 1;
        private bool follower1CrossToEmini = false;
        private int follower2Multiplier = 1;
        private bool follower2CrossToEmini = false;
        private int follower3Multiplier = 1;
        private bool follower3CrossToEmini = false;
        private int follower4Multiplier = 1;
        private bool follower4CrossToEmini = false;
        private int follower5Multiplier = 1;
        private bool follower5CrossToEmini = false;
        private int follower6Multiplier = 1;
        private bool follower6CrossToEmini = false;
        private int follower7Multiplier = 1;
        private bool follower7CrossToEmini = false;
        private int follower8Multiplier = 1;
        private bool follower8CrossToEmini = false;
        private int follower9Multiplier = 1;
        private bool follower9CrossToEmini = false;
        private int follower10Multiplier = 1;
        private bool follower10CrossToEmini = false;
        private int follower11Multiplier = 1;
        private bool follower11CrossToEmini = false;
        private int follower12Multiplier = 1;
        private bool follower12CrossToEmini = false;
        private int follower13Multiplier = 1;
        private bool follower13CrossToEmini = false;
        private int follower14Multiplier = 1;
        private bool follower14CrossToEmini = false;
        private int follower15Multiplier = 1;
        private bool follower15CrossToEmini = false;
        private int follower16Multiplier = 1;
        private bool follower16CrossToEmini = false;
        private int follower17Multiplier = 1;
        private bool follower17CrossToEmini = false;
        private int follower18Multiplier = 1;
        private bool follower18CrossToEmini = false;
        private int follower19Multiplier = 1;
        private bool follower19CrossToEmini = false;
        private int follower20Multiplier = 1;
        private bool follower20CrossToEmini = false;
        private int follower21Multiplier = 1;
        private bool follower21CrossToEmini = false;
        private int follower22Multiplier = 1;
        private bool follower22CrossToEmini = false;
        private int follower23Multiplier = 1;
        private bool follower23CrossToEmini = false;
        private int follower24Multiplier = 1;
        private bool follower24CrossToEmini = false;
        
        private string followerAccount1Prop = string.Empty;
        private string followerAccount2Prop = string.Empty;
        private string followerAccount3Prop = string.Empty;
        private string followerAccount4Prop = string.Empty;
        private string followerAccount5Prop = string.Empty;
        private string followerAccount6Prop = string.Empty;
        private string followerAccount7Prop = string.Empty;
        private string followerAccount8Prop = string.Empty;
        private string followerAccount9Prop = string.Empty;
        private string followerAccount10Prop = string.Empty;
        private string followerAccount11Prop = string.Empty;
        private string followerAccount12Prop = string.Empty;
        private string followerAccount13Prop = string.Empty;
        private string followerAccount14Prop = string.Empty;
        private string followerAccount15Prop = string.Empty;
        private string followerAccount16Prop = string.Empty;
        private string followerAccount17Prop = string.Empty;
        private string followerAccount18Prop = string.Empty;
        private string followerAccount19Prop = string.Empty;
        private string followerAccount20Prop = string.Empty;
        private string followerAccount21Prop = string.Empty;
        private string followerAccount22Prop = string.Empty;
        private string followerAccount23Prop = string.Empty;
        private string followerAccount24Prop = string.Empty;

        // Horde position tracking: Dictionary<Account, Dictionary<Instrument, int>> - tracks net position quantity per account per instrument
        private Dictionary<Account, Dictionary<Instrument, int>> hordeAccountPositions = new Dictionary<Account, Dictionary<Instrument, int>>();
        private int totalHordePositionCount = 0;

        // Performance optimization: Store only active follower accounts instead of looping through all 24 indexes
        private class FollowerAccountInfo
        {
            public Account Account { get; set; }
            public int Index { get; set; }
            public int Multiplier { get; set; }
            public bool CrossToEmini { get; set; }
        }
        private List<FollowerAccountInfo> activeFollowerAccounts = new List<FollowerAccountInfo>();

        /*
        private Stroke stopLossStroke = null;
        private Stroke profitTargetStroke = null;
        private DateTime lastChartTraderCycleChangeTime = DateTime.MinValue;
        private int ChartTraderCycleThrottleSeconds = 5;
        */

        private DateTime lastRealTimePipeLineCycleChangeTime = DateTime.MinValue;
        private DateTime lastPopDropCycleChangeTime = DateTime.MinValue;
        private bool isPopDropOnBarUpdateCycleReady = false;

        private bool runSysCheckFlag = false;
        private bool alreadyRanOnceLoadTHCheck = false;

        public override string DisplayName
		{
			get
			{
				if (State == State.SetDefaults || ShowIndicatorName)
					return FullSystemName;
				else
					return "";
			}
		}


        protected override void OnStateChange()
        {
            string signalName = "OnStateChange";

            if (State == State.SetDefaults)
            {
                signalName = "OnStateChange (State.SetDefaults)";
                if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** " + signalName + ":");

                Name = SystemName;
                Description = FullSystemName;
                Calculate = Calculate.OnPriceChange;
                MaximumBarsLookBack = MaximumBarsLookBack.TwoHundredFiftySix;
                IsOverlay = true;
                IsChartOnly = true;
                IsSuspendedWhileInactive = false;
                DisplayInDataBox = false;
                DrawOnPricePanel = true;
                //DrawHorizontalGridLines = false;
                //DrawVerticalGridLines = false;
                PaintPriceMarkers = false;

                PrintTo = PrintTo.OutputTab1;

                // 1) Stop Loss Settings
                UseAutoPositionStopLoss = false;
                StopLossInitialTicks = 21;
                StopLossInitialATRMultiplier = 0;
                StopLossInitialSnapType = TickHunterStopLossSnapTypes.Disabled;
                StopLossInitialMaxTicks = 0;
                StopLossInitialDollars = 0;
                StopLossInitialDollarsCombined = false;
                StopLossJumpTicks = 2;
                StopLossCTRLJumpTicks = true;
                StopLossRefreshOnVolumeChange = false;
                StopLossRefreshManagementEnabled = true;

                // 2) Take Profit Settings
                UseAutoPositionTakeProfit = false;
                TakeProfitInitialTicks = 45;
                TakeProfitInitialATRMultiplier = 0;
                TakeProfitSyncBogeyTargetPrice = true;
                TakeProfitSyncECATargetPrice = true;
                TakeProfitJumpTicks = 20;
                TakeProfitCtrlSLMultiplier = 2;
                TakeProfitRefreshManagementEnabled = true;

                //3) Break-Even Settings
                AutoPositionBreakEvenType = TickHunterBreakEvenAutoTypes.Disabled;
                BreakEvenInitialTicks = 4;
                BreakEvenJumpTicks = 2;
                BreakEvenTurboJumpTicks = 4;
                BreakEvenAutoTrailNow = TickHunterBreakEvenAutoTrailNowTypes.Disabled;
                BreakEvenAutoTriggerTicks = 26;
                BreakEvenAutoTriggerATRMultiplier = 0;
                BreakEvenAutoZombieFlipResumeSnapType = TickHunterStopLossSnapTypes.Snap8Bar;
                BreakEvenAutoCreeperFlipSnapType = TickHunterStopLossSnapTypes.Snap1Bar;

                // 4) Buy/Sell Settings
                UseIntradayMarginCheck = false;
                
                LimitToVolumeMaxOption = false;
                EntryVolumeMaxOption1 = 1;
                EntryVolumeMaxOption2 = 2;
                EntryVolumeMaxOption3 = 3;
                EntryVolumeMaxOption4 = 4;
                EntryVolumeMaxOption5 = 5;

                LimitTrancheVolumeToInProfit = false;
                MaxInitialTrancheVolumeSize = 1;

                LimitTrancheVolumePerBar = false;
                MinTrancheVolumeDelaySeconds = 10;

                // 5) Pop/Drop Settings
                UsePopCTRLDelayedEntry = true;
                UsePopLimitToPullback = false;
                PopDelayedEntryMaxCount = 1;
                PopInitialTicks = 20;
                PopInitialATRMultiplier = 0.5;
                PopJumpTicks = 2;
                UsePopAutoJumpToSnap = true;
                DropInitialTicks = 20;
                DropInitialATRMultiplier = 0.5;
                DropJumpTicks = 2;
                UseDropAutoJumpToSnap = true;

                UsePopDropOnBarUpdateDelay = false;
                PopDropThrottleMilliseconds = 250;



                // 6) Volume Settings
                AutoEntryVolumeType = TickHunterEntryVolumeAutoTypes.Option1;
                AutoEntryVolumeOption1 = 1;
                AutoEntryVolumeOption2 = 2;
                AutoEntryVolumeOption3 = 3;
                AutoEntryVolumeOption4 = 4;
                AutoEntryVolumeOption5 = 5;

                // 7) AutoPilot Settings
                AutoPilotOrderType = TickHunterAutoPilotOrderTypes.Market;
                AutoPilotTradeSignalType = TickHunterTradeSignalTypes.BuySellAll;
                AutoPilotSetupType = TickHunterAutoPilotSetupTypes.CreeperOnly;
                UseAutoPilotLite = true;
                UseAutoPilotAddOn = false;
                AutoPilotMaxVolume = 0;
                UseAutoPilotSpeedLineFilter = false;
                AutoPilotSpeedLineFilterPeriod = 8;
                AutoPilotSetupFilterPeriod = 170;
                AutoPilotSetupCreeperPeriod1 = 12;
                AutoPilotSetupCreeperPeriod2 = 26;
                AutoPilotSetupCreeperPeriod3 = 9;
                AutoPilotSetupZombiePeriod = 15;
                AutoPilotSetupZombieMultiplier = 1.2;
                AutoPilotSetupWalkerPeriod = 8;
                AutoPilotSetupWalkerFreshCrossOnly = true;

                // 8) AutoPilot Profile Settings
                AutoPilotProfileSetupType = TickHunterAutoPilotProfileSetupTypes.CreeperOrSliderCombo;
                UsePeppyLimitPopDelayedEntry = true;
                UsePeppyLimitPopToPullback = false;
                UsePeppyLimitPopAlignedCreeper = true;
                UsePeppyLimitPopAlignedRushLine = true;
                UseSleepyLimitPopDelayedEntry = true;
                UseSleepyLimitPopToPullback = true;
                UseSleepyLimitPopCounterCreeper = true;
                UseSleepyLimitPopCounterRushLine = true;

                // 9) Auto Close Settings
                AutoPositionCloseType = TickHunterCloseAutoTypes.Disabled;
                UseAutoCloseMinProfit = false;
                AutoCloseMinProfitDollarsPerVolume = 5;
                UseAutoCloseAlert = false;
                AutoCloseAndTrailOffsetTicks = 1;
                AutoCloseAndTrailMA1Period = 21;
                AutoCloseAndTrailMA2Period = 34;
                AutoCloseAndTrailMA3Period = 55;
                AutoCloseAndTrailMA4Period = 170;
                AutoCloseAndTrailZL1Period = 17;
                AutoCloseAndTrailZL2Period = 60;
                AutoCloseAndTrailZL3Period = 85;
                AutoCloseAndTrailZL4Period = 300;
                AutoCloseAndTrailRLPeriod = 10;
                AutoCloseAndTrailDL1Period = 21;
                AutoCloseAndTrailDL2Period = 34;
                AutoCloseAndTrailDL3Period = 55;
                AutoCloseAndTrailDL4Period = 170;
                AutoCloseAndTrailR1Period = 34;
                AutoCloseAndTrailR5Period = 170;
                AutoCloseAndTrailKLine1Period = 15;
                AutoCloseAndTrailKLine1Multiplier = 1;
                AutoCloseAndTrailKLine2Period = 15;
                AutoCloseAndTrailKLine2Multiplier = 2;

                // 10) Bogey Target Settings
                BogeyTargetStartWithFullPnL = true;
                BogeyTargetBaseDollars = 100;
                BogeyTargetDailyBaseDollars = 0;
                ShowBogeyTargetDailyBreakEvenLine = false;
                ShowBogeyTargetDaily1Line = false;
                ShowBogeyTargetDaily2Line = false;
                ShowBogeyTargetDaily3Line = false;
                ShowBogeyTargetDaily4Line = false;
                ShowBogeyTargetDaily5Line = false;

                // 11) ECA Target Settings
                ECATargetDollars = 0;
                ECATargetDollarsPerOtherVolume = 5;
                ECATargetDollarsPerMNQVolume = 10;
                ECATargetDollarsPerNQVolume = 100;
                ECATargetDollarsPerM2KVolume = 5;
                ECATargetDollarsPerRTYVolume = 50;
                ECATargetDollarsPerMESVolume = 5;
                ECATargetDollarsPerESVolume = 50;
                ECATargetDollarsPerMYMVolume = 5;
                ECATargetDollarsPerYMVolume = 50;
                ECATargetATRMultiplierPerVolume = 0.5;

                // 12) AddOn Settings
                AutoAddOnMaxDollars = 250;

                // 13) Account Risk Settings
                UseDayOverMaxLossTrailing = false;
                DayOverMaxLossDollars = 0;
                DayOverMaxLossBTBaseRatio = 0;
                DayOverMaxAccountPnLPeakDollars = 0;
                DayOverAccountBalanceFloorDollars = 0;
                ECAMaxDDInDollars = 0;
                ExcessIntradayMarginMinDollars = 0;

                // 14) Sound Settings
                PlaySoundOnSetupAlert = false;
                SoundFile = NinjaTrader.Core.Globals.InstallDir.ToString() + @"sounds\whip.wav";

                // 15) Button Settings
                ShowButtonAutoBreakEven = true;
                ShowButtonReverse = true;
                ShowButtonClose = true;
                ShowButtonAutoClose = true;
                ShowButtonProfitTarget = true;
                ShowButtonTPPlus = true;
                ShowButtonBEPlus = true;
                ShowButtonSLPlus = true;
                ShowButtonBuyMarket = true;
                ShowButtonSellMarket = true;
                ShowButtonPopPlus = false;
                ShowButtonPopMinus = false;
                ShowButtonDropPlus = false;
                ShowButtonDropMinus = false;
                ShowButtonAutoAddOn = false;
                ShowButtonTradeSignal = false;
                ShowButtonAutoPilotProfile = false;
                ShowButtonAutoPilot = false;
                ShowButtonVolumeMax = false;
                ShowButtonVolume = true;

                // 16) Instrument Settings
                UseBlendedInstruments = false;
                ShowAveragePriceLine = true;
                ShowAveragePriceLineQuantity = true;
                ShowAveragePriceLineQuantityInMicros = false;
                OtherCommissionPerSide = 2.09;
                OtherIntradayMarginDollars = 1000;
                OtherPositionMaxVolume = 50;

                MNQCommissionPerSide = 0.61;
                MNQIntradayMarginDollars = 100;
                MNQPositionMaxVolume = 100;

                NQCommissionPerSide = 2.09;
                NQIntradayMarginDollars = 1000;
                NQPositionMaxVolume = 50;

                MESCommissionPerSide = 0.61;
                MESIntradayMarginDollars = 50;
                MESPositionMaxVolume = 100;

                ESCommissionPerSide = 2.09;
                ESIntradayMarginDollars = 500;
                ESPositionMaxVolume = 50;

                MYMCommissionPerSide = 0.61;
                MYMIntradayMarginDollars = 50;
                MYMPositionMaxVolume = 100;

                YMCommissionPerSide = 2.09;
                YMIntradayMarginDollars = 500;
                YMPositionMaxVolume = 50;

                M2KCommissionPerSide = 0.61;
                M2KIntradayMarginDollars = 50;
                M2KPositionMaxVolume = 100;

                RTYCommissionPerSide = 2.09;
                RTYIntradayMarginDollars = 500;
                RTYPositionMaxVolume = 50;

                IgnoreInstrumentServerSupport = false;

                //17) HotKey Settings
                UseHotKeys = false;
                BuyMarketHotKey = "NumLock + 2";
                SellMarketHotKey = "NumLock + 3";
                BuyPopHotKey = "NumLock + 5";
                SellPopHotKey = "NumLock + 6";
                CloseHotKey = "NumLock + .";
                ReverseHotKey = "NumLock + -";
                BreakEvenPlusHotKey = "NumLock + 0";
                StopLossPlusHotKey = "NumLock + Enter";
                VolumeHotKey = "NumLock + +";
                ActivateHotKey = "NumLock + *";

                // 18) Horde Settings
                UseHordeTradeCopier = false;
                FollowerAccount1  = string.Empty;
                Follower1TradeSize = string.Empty;
                FollowerAccount2  = string.Empty;
                Follower2TradeSize = string.Empty;
                FollowerAccount3  = string.Empty;
                Follower3TradeSize = string.Empty;
                FollowerAccount4  = string.Empty;
                Follower4TradeSize = string.Empty;
                FollowerAccount5  = string.Empty;
                Follower5TradeSize = string.Empty;
                FollowerAccount6  = string.Empty;
                Follower6TradeSize = string.Empty;
                FollowerAccount7  = string.Empty;
                Follower7TradeSize = string.Empty;
                FollowerAccount8  = string.Empty;
                Follower8TradeSize = string.Empty;
                FollowerAccount9  = string.Empty;
                Follower9TradeSize = string.Empty;
                FollowerAccount10 = string.Empty;
                Follower10TradeSize = string.Empty;
                FollowerAccount11 = string.Empty;
                Follower11TradeSize = string.Empty;
                FollowerAccount12 = string.Empty;
                Follower12TradeSize = string.Empty;
                FollowerAccount13 = string.Empty;
                Follower13TradeSize = string.Empty;
                FollowerAccount14 = string.Empty;
                Follower14TradeSize = string.Empty;
                FollowerAccount15 = string.Empty;
                Follower15TradeSize = string.Empty;
                FollowerAccount16 = string.Empty;
                Follower16TradeSize = string.Empty;
                FollowerAccount17 = string.Empty;
                Follower17TradeSize = string.Empty;
                FollowerAccount18 = string.Empty;
                Follower18TradeSize = string.Empty;
                FollowerAccount19 = string.Empty;
                Follower19TradeSize = string.Empty;
                FollowerAccount20 = string.Empty;
                Follower20TradeSize = string.Empty;
                FollowerAccount21 = string.Empty;
                Follower21TradeSize = string.Empty;
                FollowerAccount22 = string.Empty;
                Follower22TradeSize = string.Empty;
                FollowerAccount23 = string.Empty;
                Follower23TradeSize = string.Empty;
                FollowerAccount24 = string.Empty;
                Follower24TradeSize = string.Empty;

                // 19) Misc Settings
                SnapOffsetTicks = 1;
                TakeProfitAddOnDelaySeconds = 0; // 0 = immediate, >0 = delay in seconds (e.g., 5)
                StopLossAddOnDelaySeconds = 0; // 0 = immediate, >0 = delay in seconds (e.g., 5)
                SnapPowerBoxPeriod = 8;
                SnapPowerBoxAutoAdjustPeriodsOnM1 = true;
                ATRPeriod = 21;
                RefreshTPSLOffsetTicks = 0;
                SingleOrderChunkMaxQuantity = 10;
                SingleOrderChunkMinQuantity = 5;
                SingleOrderChunkDelayMilliseconds = 10;
                RealTimePipeLineThrottleMilliseconds = 50;

                // 20) Output Log Settings
                UsePositionProfitLogging = false;
                DebugLogLevel = 0;
                OrderWaitOutputThrottleSeconds = 1;

                // 21) Account Logging Settings
                UseAccountInfoLogging = false;
                AccountInfoLoggingPath = @"C:\MetaTrader\AccountInfo_NT.csv";


                //UseHedgehogEntry = false;
                //HedgehogEntryBuySymbol1SellSymbol2 = true;
                //HedgehogEntrySymbol1 = "MES";
                //HedgehogEntrySymbol2 = "M2K";

                AddPlot(new Stroke(Brushes.LimeGreen, DashStyleHelper.Solid, 3), PlotStyle.Line, "BogeyTargetLine");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.DashDotDot, 1), PlotStyle.Line, "BogeyTargetBreakEvenLine");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily1Line");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily2Line");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily3Line");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily4Line");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily5Line");

                AddPlot(new Stroke(Brushes.Red, DashStyleHelper.Solid, 3), PlotStyle.Line, "DayOverMaxLossLine");
                AddPlot(new Stroke(Brushes.Red, DashStyleHelper.Dash, 3), PlotStyle.Line, "DayOverAccountBalanceFloorLine");
                AddPlot(new Stroke(Brushes.LimeGreen, DashStyleHelper.Dash, 3), PlotStyle.Line, "ECATakeProfitLine");
                AddPlot(new Stroke(Brushes.SkyBlue, DashStyleHelper.Solid, 3), PlotStyle.Line, "AveragePriceLine");
            }
            else if (State == State.Configure)
            {
                signalName = "OnStateChange (State.Configure)";
                if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** " + signalName + ":");

                isTickHunterAlreadyLoaded = false;
                attachedInstrument = this.Instrument;
                attachedInstrumentIsEmini = IsEminiInstrument(attachedInstrument);
                attachedInstrumentIsFuture = RealInstrumentService.IsFutureInstrumentType(this.attachedInstrument);
                attachedInstrumentServerSupported = (IgnoreInstrumentServerSupport || this.Instrument.MasterInstrument.IsServerSupported);
                attachedInstrumentTickSize = RealInstrumentService.GetTickSize(attachedInstrument);
                attachedInstrumentTicksPerPoint = RealInstrumentService.GetTicksPerPoint(attachedInstrumentTickSize);
                attachedInstrumentTickValue = RealInstrumentService.GetTickValue(attachedInstrument);

                GenerateEntryVolumeAutoButtonText();
                GenerateEntryVolumeMaxButtonText();

                currentAutoPilotStatus = TickHunterAutoPilotTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentTradeSignalStatus = AutoPilotTradeSignalType;
                lastToggleEntryTradeSignalStatus = currentTradeSignalStatus;
                lastToggleBuyPopDelayedStatus = currentBuyPopDelayedStatus;
                lastToggleSellPopDelayedStatus = currentSellPopDelayedStatus;

                currentAutoPilotSetupStatus = AutoPilotSetupType;
                currentAutoPilotProfileSetupStatus = AutoPilotProfileSetupType;
                currentAutoPilotOrderStatus = AutoPilotOrderType;
                currentStopLossInitialSnapStatus = StopLossInitialSnapType;
                //if (!ShowButtonTradeSignal) currentTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
                currentEntryVolumeAutoStatus = AutoEntryVolumeType;
                lastToggleEntryVolumeAutoStatus = currentEntryVolumeAutoStatus;
                currentBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
                nextBogeyTargetMultiplier = currentBogeyTargetMultiplier;

                currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                lastToggleEntryVolumeMaxStatus = currentEntryVolumeMaxStatus;

                bogeyTargetStartWithFullPnLFlag = BogeyTargetStartWithFullPnL;
                useAutoPilotAddOnFlag = UseAutoPilotAddOn;
                breakEvenAutoTrailNowFlag = BreakEvenAutoTrailNow;
                closeAutoMinProfitFlag = UseAutoCloseMinProfit;
                closeAutoAlertFlag = UseAutoCloseAlert;
                popCTRLDelayedEntryFlag = UsePopCTRLDelayedEntry;
                popLimitToPullbackFlag = UsePopLimitToPullback;
                popDelayedEntryMaxCountFlag = Math.Min(PopDelayedEntryMaxCount, (int)TickHunterPopDelayedTypes.TradeCount5);

                maxInitialTrancheVolumeSize = Math.Max(MaxInitialTrancheVolumeSize, DEFAULT_VOLUME_SIZE);
                limitedVolumeMaxSize = LimitVolumeMax();
                limitTrancheVolumeToInProfitFlag = (LimitTrancheVolumeToInProfit && maxInitialTrancheVolumeSize > 0);
                
                limitTrancheVolumePerBarFlag = (LimitTrancheVolumePerBar && MinTrancheVolumeDelaySeconds > 0);


                currentCloseAutoStatus = AutoPositionCloseType;
                lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;

                currentBreakEvenAutoStatus = AutoPositionBreakEvenType;
                lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;

                if (DayOverMaxLossBTBaseRatio > 0 && BogeyTargetBaseDollars > 0 && DayOverMaxLossDollars == 0)
                {
                    dayOverMaxLossDollars = BogeyTargetBaseDollars * DayOverMaxLossBTBaseRatio;
                }
                else
                {
                    dayOverMaxLossDollars = DayOverMaxLossDollars;
                }

                autoAddOnMaxDollars = CalculateAutoAddOnMaxDollars(AutoAddOnMaxDollars, StopLossInitialDollars, dayOverMaxLossDollars);

                if (this.ECAMaxDDInDollars == 0)
                    maxDDInDollars = this.ECAMaxDDInDollars;
                else
                    maxDDInDollars = this.ECAMaxDDInDollars * -1;

                if (attachedInstrumentServerSupported)
                {
                    if (attachedInstrumentIsFuture)
                    {
                        //HedgehogEntrySymbol1FullName = HedgehogEntrySymbol1 + GetCurrentFuturesMonthYearPrefix();
                        //HedgehogEntrySymbol2FullName = HedgehogEntrySymbol2 + GetCurrentFuturesMonthYearPrefix();

                        string mnqFullName = MNQPrefix + GetCurrentFuturesMonthYearPrefix();
                        string mesFullName = MESPrefix + GetCurrentFuturesMonthYearPrefix();
                        string mymFullName = MYMPrefix + GetCurrentFuturesMonthYearPrefix();
                        string m2kFullName = M2KPrefix + GetCurrentFuturesMonthYearPrefix();

                        string nqFullName = NQPrefix + GetCurrentFuturesMonthYearPrefix();
                        string esFullName = ESPrefix + GetCurrentFuturesMonthYearPrefix();
                        string ymFullName = YMPrefix + GetCurrentFuturesMonthYearPrefix();
                        string rtyFullName = RTYPrefix + GetCurrentFuturesMonthYearPrefix();


                        // BarsArray[0] is default of chart we are on

                        if (this.Instrument.FullName != mnqFullName)
                        {
                            ValidateInstrument(mnqFullName);
                        }

                        if (this.Instrument.FullName != mesFullName)
                        {
                            ValidateInstrument(mesFullName);
                        }

                        if (this.Instrument.FullName != mymFullName)
                        {
                            ValidateInstrument(mymFullName);
                        }

                        if (this.Instrument.FullName != m2kFullName)
                        {
                            ValidateInstrument(m2kFullName);
                        }

                        if (this.Instrument.FullName != nqFullName)
                        {
                            ValidateInstrument(nqFullName);
                        }

                        if (this.Instrument.FullName != esFullName)
                        {
                            ValidateInstrument(esFullName);
                            //AddDataSeries(emini2FullName, BarsPeriodType.Minute, 5);
                        }

                        if (this.Instrument.FullName != ymFullName)
                        {
                            ValidateInstrument(ymFullName);
                            //AddDataSeries(emini3FullName, BarsPeriodType.Minute, 5);
                        }

                        if (this.Instrument.FullName != rtyFullName)
                        {
                            ValidateInstrument(rtyFullName);
                            //AddDataSeries(emini4FullName, BarsPeriodType.Minute, 5);
                        }

                        mnqInstrument = Instrument.GetInstrument(mnqFullName);
                        mesInstrument = Instrument.GetInstrument(mesFullName);
                        mymInstrument = Instrument.GetInstrument(mymFullName);
                        m2kInstrument = Instrument.GetInstrument(m2kFullName);

                        nqInstrument = Instrument.GetInstrument(nqFullName);
                        esInstrument = Instrument.GetInstrument(esFullName);
                        ymInstrument = Instrument.GetInstrument(ymFullName);
                        rtyInstrument = Instrument.GetInstrument(rtyFullName);

                        blendedInstrument = GetBlendedInstrument(attachedInstrument);
                    }
                }

                ForceRefresh();
            }
            else if (State == State.DataLoaded)
            {
                signalName = "OnStateChange (State.DataLoaded)";
                if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** " + signalName + ":");

                RealLogger.PrintOutput("Loading " + SystemVersion + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ")", PrintTo.OutputTab1);
                RealLogger.PrintOutput("Loading " + SystemVersion + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ")", PrintTo.OutputTab2);
                RealLogger.PrintOutput("IsFutureType=" + attachedInstrumentIsFuture.ToString() + " IsInstrumentServerSupported=" + attachedInstrumentServerSupported.ToString(), PrintTo.OutputTab2);

                if (!alreadyRanOnceLoadTHCheck && ChartControl != null)
                {
                    ChartObjectCollection<Gui.NinjaScript.IndicatorRenderBase> loadedIndicators = ChartControl.Indicators;

                    bool foundFirstInstance = false;

                    foreach (Gui.NinjaScript.IndicatorRenderBase indicator in loadedIndicators)
                    {
                        if (indicator is TickHunter)
                        {
                            if (!foundFirstInstance)
                            {
                                foundFirstInstance = true;
                            }
                            else
                            {
                                foundFirstInstance = false;
                                RealLogger.PrintOutput("*** CRITICAL ERROR: " + SystemName + " is detecting more than one instance loaded on the same chart.  Only one instance of TickHunter can be loaded on the same chart.");
                                this.SetState(State.Terminated);
                                
                                throw new ApplicationException("Unable to load more than one instance of TickHunter on the same chart.");
                            }
                        }
                    }

                    alreadyRanOnceLoadTHCheck = true; 
                }

                isTickHunterActivated = false;
                if (attachedInstrumentServerSupported)
                {
                    hasRanOnceFirstCycle = false;
                    activeDayOverMaxLossAutoClose = false;
                    atrBuffer = ATR(ATRPeriod);
                    atrValue = 0;

                    barPeriodSecondInterval = GetBarPeriodSecondInterval(BarsPeriod);

                    runSysCheckFlag = true;

                    this.fullSoundFilename = this.SoundFile;

                    snapPowerBoxBuffer = THPowerBox("x", false, SnapPowerBoxPeriod, 2);
                    snapPowerBoxBuffer.AutoAdjustPeriodsOnM1 = SnapPowerBoxAutoAdjustPeriodsOnM1;
                    snapPowerBoxMiddleValue = 0;
                    snapPowerBoxUpperValue = 0;
                    snapPowerBoxUpperValue10 = 0;
                    snapPowerBoxUpperValue20 = 0;
                    snapPowerBoxUpperValue30 = 0;
                    snapPowerBoxUpperValue40 = 0;
                    snapPowerBoxUpperValue50 = 0;
                    snapPowerBoxLowerValue = 0;
                    snapPowerBoxLowerValue10 = 0;
                    snapPowerBoxLowerValue20 = 0;
                    snapPowerBoxLowerValue30 = 0;
                    snapPowerBoxUpperValue40 = 0;
                    snapPowerBoxUpperValue50 = 0;


                    keltnerATRBuffer = THKeltnerATR("X", false, false, KeltnerPeriod, KeltnerATRPeriod, KeltnerOffsetMultiplier1, KeltnerOffsetMultiplier2, KeltnerOffsetMultiplier3, KeltnerOffsetMultiplier4);

                    keltnerUpperInnerRingValue = 0;
                    keltnerLowerInnerRingValue = 0;

                    stingRayBuffer = THStingRay("x", 2, false, false, AutoPilotSetupCreeperPeriod1, AutoPilotSetupCreeperPeriod2, AutoPilotSetupCreeperPeriod3, AutoCloseAndTrailRLPeriod, AutoCloseAndTrailDL1Period, AutoCloseAndTrailDL2Period, AutoCloseAndTrailDL3Period, AutoCloseAndTrailDL4Period);
                    stingRayHighLevel1Value = 0;
                    stingRayHighLevel2Value = 0;
                    stingRayHighLevel3Value = 0;
                    stingRayHighLevel4Value = 0;
                    stingRayHighLevel5Value = 0;

                    stingRayLowLevel1Value = 0;
                    stingRayLowLevel2Value = 0;
                    stingRayLowLevel3Value = 0;
                    stingRayLowLevel4Value = 0;
                    stingRayLowLevel5Value = 0;

                    stingRayRecentHigherHighValue = 0;
                    stingRayRecentLowerLowValue = 0;

                    stingRayCreeperCycleCountValue = 0;
                    stingRaySurgeBarCountValue = 0;
                    stingRaySurgeBarCycleTickSpeedValue = 0;
                    stingRayGush1BarCountValue = 0;
                    stingRayGush1BarCycleTickSpeedValue = 0;

                    stingRayFlow1BarCountValue = 0;
                    stingRayFlow1BarCycleTickSpeedValue = 0;
                    stingRayFlow2BarCountValue = 0;
                    stingRayFlow2BarCycleTickSpeedValue = 0;
                    stingRayFlow3BarCountValue = 0;
                    stingRayFlow3BarCycleTickSpeedValue = 0;
                    stingRayFlow4BarCountValue = 0;
                    stingRayFlow4BarCycleTickSpeedValue = 0;

                    inBuySliderSetupCycle = false;
                    inSellSliderSetupCycle = false;
                    usedBuySliderSetupCycle = false;
                    usedSellSliderSetupCycle = false;

                    bogeyTargetLineBrush = Plots[BogeyTargetLineChangePlotIndex].Brush;
                    bogeyTargetLineDashStyle = Plots[BogeyTargetLineChangePlotIndex].DashStyleHelper;
                    bogeyTargetLineWidth = (int)Plots[BogeyTargetLineChangePlotIndex].Width;

                    bogeyTargetLineBrush.Freeze();

                    bogeyTargetBreakEvenLineBrush = Plots[BogeyTargetBreakEvenLineChangePlotIndex].Brush;
                    bogeyTargetBreakEvenLineDashStyle = Plots[BogeyTargetBreakEvenLineChangePlotIndex].DashStyleHelper;
                    bogeyTargetBreakEvenLineWidth = (int)Plots[BogeyTargetBreakEvenLineChangePlotIndex].Width;
                    bogeyTargetBreakEvenLineIsBrushTransparent = bogeyTargetBreakEvenLineBrush.IsTransparent();

                    bogeyTargetBreakEvenLineBrush.Freeze();

                    bogeyTargetDaily1LineBrush = Plots[BogeyTargetDaily1LineChangePlotIndex].Brush;
                    bogeyTargetDaily1LineDashStyle = Plots[BogeyTargetDaily1LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily1LineWidth = (int)Plots[BogeyTargetDaily1LineChangePlotIndex].Width;
                    bogeyTargetDaily1LineIsBrushTransparent = bogeyTargetDaily1LineBrush.IsTransparent();

                    bogeyTargetDaily1LineBrush.Freeze();

                    bogeyTargetDaily2LineBrush = Plots[BogeyTargetDaily2LineChangePlotIndex].Brush;
                    bogeyTargetDaily2LineDashStyle = Plots[BogeyTargetDaily2LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily2LineWidth = (int)Plots[BogeyTargetDaily2LineChangePlotIndex].Width;
                    bogeyTargetDaily2LineIsBrushTransparent = bogeyTargetDaily2LineBrush.IsTransparent();

                    bogeyTargetDaily2LineBrush.Freeze();

                    bogeyTargetDaily3LineBrush = Plots[BogeyTargetDaily3LineChangePlotIndex].Brush;
                    bogeyTargetDaily3LineDashStyle = Plots[BogeyTargetDaily3LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily3LineWidth = (int)Plots[BogeyTargetDaily3LineChangePlotIndex].Width;
                    bogeyTargetDaily3LineIsBrushTransparent = bogeyTargetDaily3LineBrush.IsTransparent();

                    bogeyTargetDaily3LineBrush.Freeze();

                    bogeyTargetDaily4LineBrush = Plots[BogeyTargetDaily4LineChangePlotIndex].Brush;
                    bogeyTargetDaily4LineDashStyle = Plots[BogeyTargetDaily4LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily4LineWidth = (int)Plots[BogeyTargetDaily4LineChangePlotIndex].Width;
                    bogeyTargetDaily4LineIsBrushTransparent = bogeyTargetDaily4LineBrush.IsTransparent();

                    bogeyTargetDaily4LineBrush.Freeze();

                    bogeyTargetDaily5LineBrush = Plots[BogeyTargetDaily5LineChangePlotIndex].Brush;
                    bogeyTargetDaily5LineDashStyle = Plots[BogeyTargetDaily5LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily5LineWidth = (int)Plots[BogeyTargetDaily5LineChangePlotIndex].Width;
                    bogeyTargetDaily5LineIsBrushTransparent = bogeyTargetDaily5LineBrush.IsTransparent();

                    bogeyTargetDaily5LineBrush.Freeze();

                    dayOverMaxLossLineBrush = Plots[DayOverMaxLossLineChangePlotIndex].Brush;
                    dayOverMaxLossLineDashStyle = Plots[DayOverMaxLossLineChangePlotIndex].DashStyleHelper;
                    dayOverMaxLossLineWidth = (int)Plots[DayOverMaxLossLineChangePlotIndex].Width;

                    dayOverMaxLossLineBrush.Freeze();
                    dayOverMaxLossInfoTextColor.Freeze();

                    dayOverAccountBalanceFloorLineBrush = Plots[DayOverAccountBalanceFloorLineChangePlotIndex].Brush;
                    dayOverAccountBalanceFloorLineDashStyle = Plots[DayOverAccountBalanceFloorLineChangePlotIndex].DashStyleHelper;
                    dayOverAccountBalanceFloorLineWidth = (int)Plots[DayOverAccountBalanceFloorLineChangePlotIndex].Width;

                    dayOverAccountBalanceFloorLineBrush.Freeze();

                    ecaTakeProfitLineBrush = Plots[ECATakeProfitLineChangePlotIndex].Brush;
                    ecaTakeProfitLineDashStyle = Plots[ECATakeProfitLineChangePlotIndex].DashStyleHelper;
                    ecaTakeProfitLineWidth = (int)Plots[ECATakeProfitLineChangePlotIndex].Width;

                    ecaTakeProfitLineBrush.Freeze();

                    averagePriceLineBrush = Plots[AveragePriceLineChangePlotIndex].Brush;
                    averagePriceLineDashStyle = Plots[AveragePriceLineChangePlotIndex].DashStyleHelper;
                    averagePriceLineWidth = (int)Plots[AveragePriceLineChangePlotIndex].Width;
                    averagePriceLineIsBrushTransparent = averagePriceLineBrush.IsTransparent();

                    averagePriceLineBrush.Freeze();


                    autoPilotSetupWalkerBuffer = EMA(Close, AutoPilotSetupWalkerPeriod);
                    autoPilotSpeedLineFilterBuffer = EMA(Close, AutoPilotSpeedLineFilterPeriod);
                    autoPilotFilterBuffer = EMA(Close, AutoPilotSetupFilterPeriod);

                    autoPilotSetupZombieBuffer = THZombieSetup("x", AutoPilotSetupZombiePeriod, AutoPilotSetupZombieMultiplier, false, 2);
                    autoPilotSetupZombie2Buffer = THZombieSetup("x", AutoCloseAndTrailKLine2Period, AutoCloseAndTrailKLine2Multiplier, false, 2);
                    autoPilotSetupCreeperBuffer = THCreeperSetup("X", AutoPilotSetupCreeperPeriod1, AutoPilotSetupCreeperPeriod2, AutoPilotSetupCreeperPeriod3, 12, 1, 26, Brushes.Transparent);

                    autoCloseAndTrailKLine1Buffer = THZombieSetup("x", AutoCloseAndTrailKLine1Period, AutoCloseAndTrailKLine1Multiplier, false, 2);
                    autoCloseAndTrailKLine2Buffer = THZombieSetup("x", AutoCloseAndTrailKLine2Period, AutoCloseAndTrailKLine2Multiplier, false, 2);

                    autoCloseAndTrailMA1Buffer = EMA(Close, AutoCloseAndTrailMA1Period);
                    autoCloseAndTrailMA2Buffer = EMA(Close, AutoCloseAndTrailMA2Period);
                    autoCloseAndTrailMA3Buffer = EMA(Close, AutoCloseAndTrailMA3Period);
                    autoCloseAndTrailMA4Buffer = EMA(Close, AutoCloseAndTrailMA4Period);

                    autoCloseAndTrailR1HBuffer = EMA(High, AutoCloseAndTrailR1Period);
                    autoCloseAndTrailR1LBuffer = EMA(Low, AutoCloseAndTrailR1Period);
                    autoCloseAndTrailR5HBuffer = EMA(High, AutoCloseAndTrailR5Period);
                    autoCloseAndTrailR5LBuffer = EMA(Low, AutoCloseAndTrailR5Period);

                    autoCloseAndTrailZL1Buffer = HMA(Close, AutoCloseAndTrailZL1Period);
                    autoCloseAndTrailZL2Buffer = HMA(Close, AutoCloseAndTrailZL2Period);
                    autoCloseAndTrailZL3Buffer = HMA(Close, AutoCloseAndTrailZL3Period);
                    autoCloseAndTrailZL4Buffer = HMA(Close, AutoCloseAndTrailZL4Period);

                    autoCloseAndTrailRLBuffer = SMA(Close, AutoCloseAndTrailRLPeriod);
                    autoCloseAndTrailDL1Buffer = SMA(Close, AutoCloseAndTrailDL1Period);
                    autoCloseAndTrailDL2Buffer = SMA(Close, AutoCloseAndTrailDL2Period);

                    autoCloseAndTrailDL3Buffer = SMA(Close, AutoCloseAndTrailDL3Period);
                    autoCloseAndTrailDL3HBuffer = SMA(High, AutoCloseAndTrailDL3Period);
                    autoCloseAndTrailDL3LBuffer = SMA(Low, AutoCloseAndTrailDL3Period);

                    autoCloseAndTrailDL4Buffer = SMA(Close, AutoCloseAndTrailDL4Period);
                    autoCloseAndTrailDL4HBuffer = SMA(High, AutoCloseAndTrailDL4Period);
                    autoCloseAndTrailDL4LBuffer = SMA(Low, AutoCloseAndTrailDL4Period);

                    isPopDropOnBarUpdateCycleReady = false;

                    if (BarsInProgress == 0 && ChartControl != null && timer == null)
                    {
                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            timer = new System.Windows.Threading.DispatcherTimer { Interval = new TimeSpan(0, 0, 0, 0, 1000), IsEnabled = true };
                            SubscribeToTimerTick(timer);
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync(() =>
                            {
                                timer = new System.Windows.Threading.DispatcherTimer { Interval = new TimeSpan(0, 0, 0, 0, 1000), IsEnabled = true };
                                SubscribeToTimerTick(timer);
                            });
                        }
                    }

                    if (ChartControl != null)
                    {
                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            SubscribeToPreviewMouseLeftButtonDown(ChartControl);
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync(() =>
                            {
                                SubscribeToPreviewMouseLeftButtonDown(ChartControl);
                            });
                        }
                    }

                    if (ChartControl != null)
                    {
                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            var chartWindow = Window.GetWindow(ChartControl);
                            SubscribeToPreviewKeyDown(chartWindow);
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync(() =>
                            {
                                var chartWindow = Window.GetWindow(ChartControl);
                                SubscribeToPreviewKeyDown(chartWindow);
                            });
                        }
                    }

                    if (ChartControl != null)
                    {
                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            if (attachedInstrumentIsFuture)
                            {
                                SubscribeToMarketDataUpdate(this.attachedInstrument);

                                if (this.attachedInstrument != mnqInstrument) SubscribeToMarketDataUpdate(mnqInstrument);
                                if (this.attachedInstrument != mesInstrument) SubscribeToMarketDataUpdate(mesInstrument);
                                if (this.attachedInstrument != mymInstrument) SubscribeToMarketDataUpdate(mymInstrument);
                                if (this.attachedInstrument != m2kInstrument) SubscribeToMarketDataUpdate(m2kInstrument);

                                if (this.attachedInstrument != nqInstrument) SubscribeToMarketDataUpdate(nqInstrument);
                                if (this.attachedInstrument != esInstrument) SubscribeToMarketDataUpdate(esInstrument);
                                if (this.attachedInstrument != ymInstrument) SubscribeToMarketDataUpdate(ymInstrument);
                                if (this.attachedInstrument != rtyInstrument) SubscribeToMarketDataUpdate(rtyInstrument);
                            }
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync(() =>
                            {
                                if (attachedInstrumentIsFuture)
                                {
                                    SubscribeToMarketDataUpdate(this.attachedInstrument);

                                    if (this.attachedInstrument != mnqInstrument) SubscribeToMarketDataUpdate(mnqInstrument);
                                    if (this.attachedInstrument != mesInstrument) SubscribeToMarketDataUpdate(mesInstrument);
                                    if (this.attachedInstrument != mymInstrument) SubscribeToMarketDataUpdate(mymInstrument);
                                    if (this.attachedInstrument != m2kInstrument) SubscribeToMarketDataUpdate(m2kInstrument);

                                    if (this.attachedInstrument != nqInstrument) SubscribeToMarketDataUpdate(nqInstrument);
                                    if (this.attachedInstrument != esInstrument) SubscribeToMarketDataUpdate(esInstrument);
                                    if (this.attachedInstrument != ymInstrument) SubscribeToMarketDataUpdate(ymInstrument);
                                    if (this.attachedInstrument != rtyInstrument) SubscribeToMarketDataUpdate(rtyInstrument);
                                }
                            });
                        }
                    }


                    /*
                    if (IsStrategyAttachedToChart())
                    {
                        if (ChartControl != null)
                        {
                            if (ChartControl.Dispatcher.CheckAccess())
                            {
                                DrawButtonPanel();
                            }
                            else
                            {
                                ChartControl.Dispatcher.InvokeAsync((() =>
                                {

                                   DrawButtonPanel();
                                }));
                            }
                        }
                    }
                    */
                }
            }
            else if (State == State.Terminated)
            {
                signalName = "OnStateChange (State.Terminated)";
                if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** " + signalName + ":");

                CleanUpAllEvents(signalName);

                hasRanOnceFirstCycle = false;
                hasDrawnButtons = false;
                activeDayOverMaxLossAutoClose = false;
            }
        }



        //public override void CloseStrategy(string signalName)
        //{


        // base.CloseStrategy(signalName);
        //}


        protected override void OnConnectionStatusUpdate(ConnectionStatusEventArgs connectionStatusUpdate)
        {
            string signalName = "OnConnectionStatusUpdate";

            base.OnConnectionStatusUpdate(connectionStatusUpdate);

            if (connectionStatusUpdate.Status == ConnectionStatus.Disconnected)
            {
                CleanUpAllEvents(signalName);
            }

            //Print("*** DEBUG OnConnectionStatusUpdate from " + connectionStatusUpdate.PreviousStatus + " to " + connectionStatusUpdate.Status + " con=" + connectionStatusUpdate.Connection.Now + " pb=" + (NinjaTrader.Cbi.Connection.PlaybackConnection != null) + " acc=" + account);
        }

        private void CleanUpAllEvents(string signalName)
        {
            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        UnloadAccountEvents(signalName);
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            UnloadAccountEvents(signalName);
                        }
                    });
                }
            }

            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        UnsubscribeToPreviewMouseLeftButtonDown(ChartControl);
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            UnsubscribeToPreviewMouseLeftButtonDown(ChartControl);
                        }
                    });
                }
            }

            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        var chartWindow = Window.GetWindow(ChartControl);
                        UnsubscribeToPreviewKeyDown(chartWindow);
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            var chartWindow = Window.GetWindow(ChartControl);
                            UnsubscribeToPreviewKeyDown(chartWindow);
                        }
                    });
                }
            }

            if (ChartControl != null && timer != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        UnsubscribeToTimerTick(timer);
                        timer = null;
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            UnsubscribeToTimerTick(timer);
                            timer = null;
                        }
                    });
                }
            }

            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        RemoveButtonPanel();
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            RemoveButtonPanel();
                        }
                    });
                }
            }

            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentIsFuture)
                    {
                        UnsubscribeToMarketDataUpdate(this.attachedInstrument);

                        if (this.attachedInstrument != mnqInstrument) UnsubscribeToMarketDataUpdate(mnqInstrument);
                        if (this.attachedInstrument != mesInstrument) UnsubscribeToMarketDataUpdate(mesInstrument);
                        if (this.attachedInstrument != mymInstrument) UnsubscribeToMarketDataUpdate(mymInstrument);
                        if (this.attachedInstrument != m2kInstrument) UnsubscribeToMarketDataUpdate(m2kInstrument);

                        if (this.attachedInstrument != nqInstrument) UnsubscribeToMarketDataUpdate(nqInstrument);
                        if (this.attachedInstrument != esInstrument) UnsubscribeToMarketDataUpdate(esInstrument);
                        if (this.attachedInstrument != ymInstrument) UnsubscribeToMarketDataUpdate(ymInstrument);
                        if (this.attachedInstrument != rtyInstrument) UnsubscribeToMarketDataUpdate(rtyInstrument);
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentIsFuture)
                        {
                            UnsubscribeToMarketDataUpdate(this.attachedInstrument);

                            if (this.attachedInstrument != mnqInstrument) UnsubscribeToMarketDataUpdate(mnqInstrument);
                            if (this.attachedInstrument != mesInstrument) UnsubscribeToMarketDataUpdate(mesInstrument);
                            if (this.attachedInstrument != mymInstrument) UnsubscribeToMarketDataUpdate(mymInstrument);
                            if (this.attachedInstrument != m2kInstrument) UnsubscribeToMarketDataUpdate(m2kInstrument);

                            if (this.attachedInstrument != nqInstrument) UnsubscribeToMarketDataUpdate(nqInstrument);
                            if (this.attachedInstrument != esInstrument) UnsubscribeToMarketDataUpdate(esInstrument);
                            if (this.attachedInstrument != ymInstrument) UnsubscribeToMarketDataUpdate(ymInstrument);
                            if (this.attachedInstrument != rtyInstrument) UnsubscribeToMarketDataUpdate(rtyInstrument);
                        }
                    });
                }
            }
        }

        protected override void OnBarUpdate()
        {
            /*
            if (State != State.Historical)
            {
                //Print(String.Format("OnBarUpdate Bid: {0} Ask: {1} Last: {2}", GetCurrentBid(), GetCurrentAsk(), Close[0])); //debug
            }
            */

            if (attachedInstrumentServerSupported)
            {
                currentBarCount = CurrentBar;

                RefreshAccount();
                RefreshATMStrategyName();

                lastAccountIntradayExcessMargin = GetAccountIntradayExcessMargin();

                /*
                bool isNextChartTraderCycleReady = lastChartTraderCycleChangeTime <= GetDateTimeNow();

                if (isNextChartTraderCycleReady && State == State.Realtime)
                {
                    lastChartTraderCycleChangeTime = (GetDateTimeNow()).AddSeconds(ChartTraderCycleThrottleSeconds);

                    if (ChartControl != null)
                    {
                        ChartControl.Dispatcher.InvokeAsync(() =>
                        {
                            stopLossStroke = ChartControl.OwnerChart.ChartTrader.Properties.StopLoss;
                            profitTargetStroke = ChartControl.OwnerChart.ChartTrader.Properties.ProfitTarget;
                        });
                    }
                }
                */

                if (CurrentBar > 21)
                {
                    previous1ClosePrice = Close[1];
                    previous2ClosePrice = Close[2];
                    previous3ClosePrice = Close[3];
                    previous4ClosePrice = Close[4];
                    previous5ClosePrice = Close[5];
                    previous6ClosePrice = Close[6];
                    previous7ClosePrice = Close[7];
                    previous8ClosePrice = Close[8];
                    previous9ClosePrice = Close[9];
                    previous10ClosePrice = Close[10];
                    previous11ClosePrice = Close[11];
                    previous12ClosePrice = Close[12];
                    previous13ClosePrice = Close[13];
                    previous14ClosePrice = Close[14];
                    previous15ClosePrice = Close[15];
                    previous16ClosePrice = Close[16];
                    previous17ClosePrice = Close[17];
                    previous18ClosePrice = Close[18];
                    previous19ClosePrice = Close[19];
                    previous20ClosePrice = Close[20];
                    previous1HighPrice = High[1];
                    previous2HighPrice = High[2];
                    previous3HighPrice = High[3];
                    previous4HighPrice = High[4];
                    previous5HighPrice = High[5];
                    previous6HighPrice = High[6];
                    previous7HighPrice = High[7];
                    previous8HighPrice = High[8];
                    previous9HighPrice = High[9];
                    previous10HighPrice = High[10];
                    previous11HighPrice = High[11];
                    previous12HighPrice = High[12];
                    previous13HighPrice = High[13];
                    previous14HighPrice = High[14];
                    previous15HighPrice = High[15];
                    previous16HighPrice = High[16];
                    previous17HighPrice = High[17];
                    previous18HighPrice = High[18];
                    previous19HighPrice = High[19];
                    previous20HighPrice = High[20];

                    previous1LowPrice = Low[1];
                    previous2LowPrice = Low[2];
                    previous3LowPrice = Low[3];
                    previous4LowPrice = Low[4];
                    previous5LowPrice = Low[5];
                    previous6LowPrice = Low[6];
                    previous7LowPrice = Low[7];
                    previous8LowPrice = Low[8];
                    previous9LowPrice = Low[9];
                    previous10LowPrice = Low[10];
                    previous11LowPrice = Low[11];
                    previous12LowPrice = Low[12];
                    previous13LowPrice = Low[13];
                    previous14LowPrice = Low[14];
                    previous15LowPrice = Low[15];
                    previous16LowPrice = Low[16];
                    previous17LowPrice = Low[17];
                    previous18LowPrice = Low[18];
                    previous19LowPrice = Low[19];
                    previous20LowPrice = Low[20];

                    previous1CandleBullish = previous1ClosePrice >= previous2ClosePrice;
                    previous2CandleBullish = previous2ClosePrice >= previous3ClosePrice;
                    previous3CandleBullish = previous3ClosePrice >= previous4ClosePrice;
                    previous4CandleBullish = previous4ClosePrice >= previous5ClosePrice;
                    previous5CandleBullish = previous5ClosePrice >= previous6ClosePrice;
                    previous6CandleBullish = previous6ClosePrice >= previous7ClosePrice;
                    previous7CandleBullish = previous7ClosePrice >= previous8ClosePrice;
                    previous8CandleBullish = previous8ClosePrice >= previous9ClosePrice;
                }

                //snapPowerBoxBuffer.PowerBoxPeriodActual[1] != 0 && CurrentBar > snapPowerBoxBuffer.PowerBoxPeriodActual[1])

                if (CurrentBar > 4)
                {
                    stingRayHighLevel1Value = stingRayBuffer.SwingHigh1Level[1];
                    stingRayLowLevel1Value = stingRayBuffer.SwingLow1Level[1];

                    stingRayHighLevel2Value = stingRayBuffer.SwingHigh2Level[1];
                    stingRayLowLevel2Value = stingRayBuffer.SwingLow2Level[1];

                    stingRayHighLevel3Value = stingRayBuffer.SwingHigh3Level[1];
                    stingRayLowLevel3Value = stingRayBuffer.SwingLow3Level[1];

                    stingRayHighLevel4Value = stingRayBuffer.SwingHigh4Level[1];
                    stingRayLowLevel4Value = stingRayBuffer.SwingLow4Level[1];

                    stingRayHighLevel5Value = stingRayBuffer.SwingHigh5Level[1];
                    stingRayLowLevel5Value = stingRayBuffer.SwingLow5Level[1];

                    stingRayRecentHigherHighValue = stingRayBuffer.RecentHigherHigh[1];
                    stingRayRecentLowerLowValue = stingRayBuffer.RecentLowerLow[1];

                    stingRayCreeperCycleCountValue = stingRayBuffer.CreeperCycleCount[1];

                    if (runSysCheckFlag)
                    {
                        int thComponentSysCheckValue = GetTHComponentSysCheck();

                        if (thComponentSysCheckValue > 0)
                        {
                            RealLogger.PrintOutput("SYSCHECK: Detecting THComponent Full (" + thComponentSysCheckValue + ")");
                        }
                        else
                        {
                            RealLogger.PrintOutput("SYSCHECK: Detecting THComponent Stub (" + thComponentSysCheckValue + ")");
                        }

                        int stingRaySysCheckValue = stingRayBuffer.GetStingRaySysCheck();

                        if (stingRaySysCheckValue > 0)
                        {
                            RealLogger.PrintOutput("SYSCHECK: Detecting StringRay Full (" + stingRaySysCheckValue + ")");
                        }
                        else
                        {
                            RealLogger.PrintOutput("SYSCHECK: Detecting StringRay Stub (" + stingRaySysCheckValue + ")");
                        }

                        runSysCheckFlag = false;
                    }


                    stingRaySurgeBarCountValue = stingRayBuffer.SurgeBarCount[1];
                    stingRaySurgeBarCycleTickSpeedValue = stingRayBuffer.SurgeBarCycleTickSpeed[1];

                    stingRayGush1BarCountValue = stingRayBuffer.Gush1BarCount[1];
                    stingRayGush1BarCycleTickSpeedValue = stingRayBuffer.Gush1BarCycleTickSpeed[1];

                    stingRayFlow1BarCountValue = stingRayBuffer.Flow1BarCount[1];
                    stingRayFlow1BarCycleTickSpeedValue = stingRayBuffer.Flow1BarCycleTickSpeed[1];
                    stingRayFlow2BarCountValue = stingRayBuffer.Flow2BarCount[1];
                    stingRayFlow2BarCycleTickSpeedValue = stingRayBuffer.Flow2BarCycleTickSpeed[1];
                    stingRayFlow3BarCountValue = stingRayBuffer.Flow3BarCount[1];
                    stingRayFlow3BarCycleTickSpeedValue = stingRayBuffer.Flow3BarCycleTickSpeed[1];
                    stingRayFlow4BarCountValue = stingRayBuffer.Flow4BarCount[1];
                    stingRayFlow4BarCycleTickSpeedValue = stingRayBuffer.Flow4BarCycleTickSpeed[1];
                }

                if (CurrentBar > KeltnerPeriod && CurrentBar > KeltnerATRPeriod)
                {
                    if (CurrentBar > 2)
                    {
                        keltnerUpperInnerRingValue = keltnerATRBuffer.UpperLevel2[1];
                        keltnerLowerInnerRingValue = keltnerATRBuffer.LowerLevel2[1];
                    }
                }

                if (CurrentBar > SnapPowerBoxPeriod)
                {
                    if (CurrentBar > 2)
                    {
                        snapPowerBoxMiddleValue = snapPowerBoxBuffer.MeanChange[1];
                        snapPowerBoxUpperValue = snapPowerBoxBuffer.Upper[1];
                        snapPowerBoxLowerValue = snapPowerBoxBuffer.Lower[1];
                    }

                    if (CurrentBar > 11)
                    {
                        snapPowerBoxUpperValue10 = snapPowerBoxBuffer.Upper[10];
                        snapPowerBoxLowerValue10 = snapPowerBoxBuffer.Lower[10];
                    }

                    if (CurrentBar > 21)
                    {
                        snapPowerBoxUpperValue20 = snapPowerBoxBuffer.Upper[20];
                        snapPowerBoxLowerValue20 = snapPowerBoxBuffer.Lower[20];
                    }

                    if (CurrentBar > 31)
                    {
                        snapPowerBoxUpperValue30 = snapPowerBoxBuffer.Upper[30];
                        snapPowerBoxLowerValue30 = snapPowerBoxBuffer.Lower[30];
                    }

                    if (CurrentBar > 41)
                    {
                        snapPowerBoxUpperValue40 = snapPowerBoxBuffer.Upper[40];
                        snapPowerBoxLowerValue40 = snapPowerBoxBuffer.Lower[40];
                    }

                    if (CurrentBar > 51)
                    {
                        snapPowerBoxUpperValue50 = snapPowerBoxBuffer.Upper[50];
                        snapPowerBoxLowerValue50 = snapPowerBoxBuffer.Lower[50];
                    }
                }

                if (CurrentBar > AutoCloseAndTrailMA3Period)
                {
                    autoCloseAndTrailKLine1Value = autoCloseAndTrailKLine1Buffer.TrailingStop[1];
                    autoCloseAndTrailKLine2Value = autoCloseAndTrailKLine2Buffer.TrailingStop[1];

                    autoPilotSetupZombieValue = autoPilotSetupZombieBuffer.ZombieSetupStatus[1];
                    autoPilotSetupZombieValue2 = autoPilotSetupZombieBuffer.ZombieSetupStatus[2];
                    autoPilotSetupZombieValue3 = autoPilotSetupZombieBuffer.ZombieSetupStatus[3];
                    autoPilotSetupZombieValue4 = autoPilotSetupZombieBuffer.ZombieSetupStatus[4];
                    autoPilotSetupZombieValue5 = autoPilotSetupZombieBuffer.ZombieSetupStatus[5];
                    autoPilotSetupZombieValue6 = autoPilotSetupZombieBuffer.ZombieSetupStatus[6];
                    autoPilotSetupZombieValue7 = autoPilotSetupZombieBuffer.ZombieSetupStatus[7];
                    autoPilotSetupZombieValue8 = autoPilotSetupZombieBuffer.ZombieSetupStatus[8];
                    autoPilotSetupZombieValue9 = autoPilotSetupZombieBuffer.ZombieSetupStatus[9];
                    autoPilotSetupZombieValue10 = autoPilotSetupZombieBuffer.ZombieSetupStatus[10];

                    autoPilotSetupZombieBuyContinuation1 = autoPilotSetupZombieValue == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation2 = autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation3 = autoPilotSetupZombieValue3 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation4 = autoPilotSetupZombieValue4 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation5 = autoPilotSetupZombieValue5 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation6 = autoPilotSetupZombieValue6 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation7 = autoPilotSetupZombieValue7 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation8 = autoPilotSetupZombieValue8 == ZombieSetupBuyCode;

                    autoPilotSetupZombieSellContinuation1 = autoPilotSetupZombieValue == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation2 = autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation3 = autoPilotSetupZombieValue3 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation4 = autoPilotSetupZombieValue4 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation5 = autoPilotSetupZombieValue5 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation6 = autoPilotSetupZombieValue6 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation7 = autoPilotSetupZombieValue7 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation8 = autoPilotSetupZombieValue8 == ZombieSetupSellCode;

                    double autoPilotSetupZombie2Value = autoPilotSetupZombie2Buffer.ZombieSetupStatus[1];
                    autoPilotSetupZombie2BuyContinuation1 = autoPilotSetupZombie2Value == ZombieSetupBuyCode;
                    autoPilotSetupZombie2SellContinuation1 = autoPilotSetupZombie2Value == ZombieSetupSellCode;


                    autoPilotSetupZombieBuySetup1 = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup1 = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup2 = autoPilotSetupZombieValue2 == ZombieSetupBuyCode && autoPilotSetupZombieValue3 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup2 = autoPilotSetupZombieValue2 == ZombieSetupSellCode && autoPilotSetupZombieValue3 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup3 = autoPilotSetupZombieValue3 == ZombieSetupBuyCode && autoPilotSetupZombieValue4 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup3 = autoPilotSetupZombieValue3 == ZombieSetupSellCode && autoPilotSetupZombieValue4 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup4 = autoPilotSetupZombieValue4 == ZombieSetupBuyCode && autoPilotSetupZombieValue5 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup4 = autoPilotSetupZombieValue4 == ZombieSetupSellCode && autoPilotSetupZombieValue5 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup5 = autoPilotSetupZombieValue5 == ZombieSetupBuyCode && autoPilotSetupZombieValue6 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup5 = autoPilotSetupZombieValue5 == ZombieSetupSellCode && autoPilotSetupZombieValue6 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup6 = autoPilotSetupZombieValue6 == ZombieSetupBuyCode && autoPilotSetupZombieValue7 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup6 = autoPilotSetupZombieValue6 == ZombieSetupSellCode && autoPilotSetupZombieValue7 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup7 = autoPilotSetupZombieValue7 == ZombieSetupBuyCode && autoPilotSetupZombieValue8 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup7 = autoPilotSetupZombieValue7 == ZombieSetupSellCode && autoPilotSetupZombieValue8 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup8 = autoPilotSetupZombieValue8 == ZombieSetupBuyCode && autoPilotSetupZombieValue9 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup8 = autoPilotSetupZombieValue8 == ZombieSetupSellCode && autoPilotSetupZombieValue9 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup9 = autoPilotSetupZombieValue9 == ZombieSetupBuyCode && autoPilotSetupZombieValue10 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup9 = autoPilotSetupZombieValue9 == ZombieSetupSellCode && autoPilotSetupZombieValue10 == ZombieSetupBuyCode;

                    if (autoPilotSetupZombieBuySetup1)
                    {
                        recentZombieBuyLowPrice = Math.Min(previous1LowPrice, previous2LowPrice);
                        if (recentZombieSellLowPrice > 0) recentZombieBuyLowPrice = Math.Min(recentZombieBuyLowPrice, recentZombieSellLowPrice);
                        recentZombieBuyHighPrice = 0;
                        recentZombieSellHighPrice = previous1HighPrice;
                        recentZombieSellLowPrice = 0;
                    }
                    else if (autoPilotSetupZombieBuyContinuation1)
                    {
                        recentZombieBuyLowPrice = Math.Min(previous1LowPrice, recentZombieBuyLowPrice);
                        recentZombieSellHighPrice = Math.Max(previous1HighPrice, recentZombieSellHighPrice);
                    }
                    else if (autoPilotSetupZombieSellSetup1)
                    {
                        recentZombieSellHighPrice = Math.Max(previous1HighPrice, previous2HighPrice);
                        if (recentZombieBuyHighPrice > 0) recentZombieSellHighPrice = Math.Max(recentZombieSellHighPrice, recentZombieBuyHighPrice);
                        recentZombieSellLowPrice = 0;
                        recentZombieBuyHighPrice = previous1HighPrice;
                        recentZombieBuyLowPrice = 0;
                    }
                    else if (autoPilotSetupZombieSellContinuation1)
                    {
                        recentZombieBuyHighPrice = Math.Max(previous1HighPrice, recentZombieBuyHighPrice);
                        recentZombieSellLowPrice = Math.Min(previous1LowPrice, recentZombieSellLowPrice);
                    }


                    autoPilotSetupWalkerValue = autoPilotSetupWalkerBuffer[1];
                    autoPilotSetupWalkerValue2 = autoPilotSetupWalkerBuffer[2];

                    autoPilotSpeedLineFilterValue = autoPilotSpeedLineFilterBuffer[1];
                    autoPilotSpeedLineFilterValue2 = autoPilotSpeedLineFilterBuffer[2];
                    autoPilotSpeedLineFilterValue3 = autoPilotSpeedLineFilterBuffer[3];
                    autoPilotSpeedLineFilterValue4 = autoPilotSpeedLineFilterBuffer[4];
                    autoPilotSpeedLineFilterValue5 = autoPilotSpeedLineFilterBuffer[5];
                    autoPilotSpeedLineFilterValue6 = autoPilotSpeedLineFilterBuffer[6];
                    autoPilotSpeedLineFilterValue7 = autoPilotSpeedLineFilterBuffer[7];
                    autoPilotSpeedLineFilterValue8 = autoPilotSpeedLineFilterBuffer[8];
                    autoPilotSpeedLineFilterValue9 = autoPilotSpeedLineFilterBuffer[9];
                    autoPilotSpeedLineFilterValue10 = autoPilotSpeedLineFilterBuffer[10];

                    autoPilotSetupCreeperValue = autoPilotSetupCreeperBuffer.AvgChange[1];
                    autoPilotSetupCreeperValue2 = autoPilotSetupCreeperBuffer.AvgChange[2];
                    autoPilotSetupCreeperValue3 = autoPilotSetupCreeperBuffer.AvgChange[3];
                    autoPilotSetupCreeperValue4 = autoPilotSetupCreeperBuffer.AvgChange[4];
                    autoPilotSetupCreeperValue5 = autoPilotSetupCreeperBuffer.AvgChange[5];
                    autoPilotSetupCreeperValue6 = autoPilotSetupCreeperBuffer.AvgChange[6];
                    autoPilotSetupCreeperValue7 = autoPilotSetupCreeperBuffer.AvgChange[7];
                    autoPilotSetupCreeperValue8 = autoPilotSetupCreeperBuffer.AvgChange[8];
                    autoPilotSetupCreeperValue9 = autoPilotSetupCreeperBuffer.AvgChange[9];
                    autoPilotSetupCreeperValue10 = autoPilotSetupCreeperBuffer.AvgChange[10];

                    bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;
                    bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;

                    autoPilotSetupCreeperBuyContinuation1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;
                    autoPilotSetupCreeperSellContinuation1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                    if (altBuyCreeperSetup1)
                    {
                        recentCreeperBuyLowPrice = Math.Min(Math.Min(previous1LowPrice, previous2LowPrice), previous3LowPrice);
                        if (recentCreeperSellLowPrice > 0) recentCreeperBuyLowPrice = Math.Min(recentCreeperBuyLowPrice, recentCreeperSellLowPrice);
                        recentCreeperBuyHighPrice = previous1HighPrice;
                        recentCreeperSellHighPrice = 0;
                        recentCreeperSellLowPrice = 0;
                    }
                    else if (autoPilotSetupCreeperBuyContinuation1)
                    {
                        recentCreeperBuyLowPrice = Math.Min(previous1LowPrice, recentCreeperBuyLowPrice);
                        recentCreeperBuyHighPrice = Math.Max(previous1HighPrice, recentCreeperBuyHighPrice);
                    }
                    else if (altSellCreeperSetup1)
                    {
                        recentCreeperSellHighPrice = Math.Max(Math.Max(previous1HighPrice, previous2HighPrice), previous3HighPrice);
                        if (recentCreeperBuyHighPrice > 0) recentCreeperSellHighPrice = Math.Max(recentCreeperSellHighPrice, recentCreeperBuyHighPrice);
                        recentCreeperBuyHighPrice = 0;
                        recentCreeperBuyLowPrice = 0;
                        recentCreeperSellLowPrice = previous1LowPrice;
                    }
                    else if (autoPilotSetupCreeperSellContinuation1)
                    {
                        recentCreeperSellHighPrice = Math.Max(previous1HighPrice, recentCreeperSellHighPrice);
                        recentCreeperSellLowPrice = Math.Min(previous1LowPrice, recentCreeperBuyLowPrice);
                    }


                    autoCloseAndTrailMA1Value = autoCloseAndTrailMA1Buffer[1];
                    autoCloseAndTrailMA1Value2 = autoCloseAndTrailMA1Buffer[2];
                    autoCloseAndTrailMA1Value3 = autoCloseAndTrailMA1Buffer[3];
                    autoCloseAndTrailMA2Value = autoCloseAndTrailMA2Buffer[1];
                    autoCloseAndTrailMA2Value2 = autoCloseAndTrailMA2Buffer[2];
                    autoCloseAndTrailMA2Value3 = autoCloseAndTrailMA2Buffer[3];
                    autoCloseAndTrailMA3Value = autoCloseAndTrailMA3Buffer[1];
                    autoCloseAndTrailMA3Value2 = autoCloseAndTrailMA3Buffer[2];
                    autoCloseAndTrailMA3Value3 = autoCloseAndTrailMA3Buffer[3];
                }

                if (CurrentBar > AutoCloseAndTrailMA4Period + 10)
                {
                    autoCloseAndTrailMA4Value = autoCloseAndTrailMA4Buffer[1];
                    autoCloseAndTrailMA4Value2 = autoCloseAndTrailMA4Buffer[2];
                    autoCloseAndTrailMA4Value3 = autoCloseAndTrailMA4Buffer[3];
                    autoCloseAndTrailMA4Value4 = autoCloseAndTrailMA4Buffer[4];
                    autoCloseAndTrailMA4Value5 = autoCloseAndTrailMA4Buffer[5];
                    autoCloseAndTrailMA4Value6 = autoCloseAndTrailMA4Buffer[6];
                    autoCloseAndTrailMA4Value7 = autoCloseAndTrailMA4Buffer[7];
                    autoCloseAndTrailMA4Value8 = autoCloseAndTrailMA4Buffer[8];
                    autoCloseAndTrailMA4Value9 = autoCloseAndTrailMA4Buffer[9];
                    autoCloseAndTrailMA4Value10 = autoCloseAndTrailMA4Buffer[10];

                    autoPilotBullishRiverTrend = (Close[1] >= autoCloseAndTrailMA4Value4);
                }

                if (CurrentBar > AutoCloseAndTrailR1Period)
                {
                    autoCloseAndTrailR1HValue = autoCloseAndTrailR1HBuffer[1];
                    autoCloseAndTrailR1LValue = autoCloseAndTrailR1LBuffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailR5Period)
                {
                    autoCloseAndTrailR5HValue = autoCloseAndTrailR5HBuffer[1];
                    autoCloseAndTrailR5LValue = autoCloseAndTrailR5LBuffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailZL1Period)
                {
                    autoCloseAndTrailZL1Value = autoCloseAndTrailZL1Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailZL1Period + 1)
                {
                    autoCloseAndTrailZL1Value2 = autoCloseAndTrailZL1Buffer[2];
                }

                if (CurrentBar > AutoCloseAndTrailZL2Period)
                {
                    autoCloseAndTrailZL2Value = autoCloseAndTrailZL2Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailZL2Period + 1)
                {
                    autoCloseAndTrailZL2Value2 = autoCloseAndTrailZL2Buffer[2];
                }

                if (CurrentBar > AutoCloseAndTrailZL3Period)
                {
                    autoCloseAndTrailZL3Value = autoCloseAndTrailZL3Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailZL3Period + 1)
                {
                    autoCloseAndTrailZL3Value2 = autoCloseAndTrailZL3Buffer[2];
                }

                if (CurrentBar > AutoCloseAndTrailZL4Period)
                {
                    autoCloseAndTrailZL4Value = autoCloseAndTrailZL4Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailZL4Period + 1)
                {
                    autoCloseAndTrailZL4Value2 = autoCloseAndTrailZL4Buffer[2];
                }

                if (CurrentBar > AutoCloseAndTrailRLPeriod + 4)
                {
                    autoCloseAndTrailRLValue = autoCloseAndTrailRLBuffer[1];
                    autoCloseAndTrailRLValue2 = autoCloseAndTrailRLBuffer[2];
                    autoCloseAndTrailRLValue3 = autoCloseAndTrailRLBuffer[3];
                    autoCloseAndTrailRLValue4 = autoCloseAndTrailRLBuffer[4];
                }

                if (CurrentBar > AutoCloseAndTrailDL1Period)
                {
                    autoCloseAndTrailDL1Value = autoCloseAndTrailDL1Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailDL2Period)
                {
                    autoCloseAndTrailDL2Value = autoCloseAndTrailDL2Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailDL3Period)
                {
                    autoCloseAndTrailDL3Value = autoCloseAndTrailDL3Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailDL4Period + 15)
                {
                    autoCloseAndTrailDL4Value = autoCloseAndTrailDL4Buffer[1];
                    autoCloseAndTrailDL4Value2 = autoCloseAndTrailDL4Buffer[2];
                    autoCloseAndTrailDL4Value3 = autoCloseAndTrailDL4Buffer[3];
                    autoCloseAndTrailDL4Value4 = autoCloseAndTrailDL4Buffer[4];
                    autoCloseAndTrailDL4Value5 = autoCloseAndTrailDL4Buffer[5];
                    autoCloseAndTrailDL4Value6 = autoCloseAndTrailDL4Buffer[6];
                    autoCloseAndTrailDL4Value7 = autoCloseAndTrailDL4Buffer[7];
                    autoCloseAndTrailDL4Value8 = autoCloseAndTrailDL4Buffer[8];
                    autoCloseAndTrailDL4Value9 = autoCloseAndTrailDL4Buffer[9];
                    autoCloseAndTrailDL4Value10 = autoCloseAndTrailDL4Buffer[10];
                    autoCloseAndTrailDL4Value11 = autoCloseAndTrailDL4Buffer[11];
                    autoCloseAndTrailDL4Value12 = autoCloseAndTrailDL4Buffer[12];
                    autoCloseAndTrailDL4Value13 = autoCloseAndTrailDL4Buffer[13];
                    autoCloseAndTrailDL4Value14 = autoCloseAndTrailDL4Buffer[14];
                    autoCloseAndTrailDL4Value15 = autoCloseAndTrailDL4Buffer[15];

                    autoPilotBullishDriftTrend = (Close[1] >= autoCloseAndTrailDL4Value);
                }

                if (CurrentBar > AutoCloseAndTrailDL3Period)
                {
                    autoCloseAndTrailDL3HValue = autoCloseAndTrailDL3HBuffer[1];
                    autoCloseAndTrailDL3LValue = autoCloseAndTrailDL3LBuffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailDL4Period)
                {
                    autoCloseAndTrailDL4HValue = autoCloseAndTrailDL4HBuffer[1];
                    autoCloseAndTrailDL4LValue = autoCloseAndTrailDL4LBuffer[1];
                }

                if (CurrentBar > AutoPilotSetupFilterPeriod)
                {
                    autoPilotBullishTrend = (Close[1] >= autoPilotFilterBuffer[1]);
                }

                if (StopLossInitialATRMultiplier > 0 || TakeProfitInitialATRMultiplier > 0 || ECATargetATRMultiplierPerVolume > 0)
                {
                    if (CurrentBar > ATRPeriod)
                    {
                        atrValue = atrBuffer[1];
                    }
                }


                if (CurrentBar > 4 && IsFirstTickOfBar)
                {
                    //bool isPriceAbovePBMiddle = previous1ClosePrice >= snapPowerBoxMiddleValue;
                    //bool isPriceBelowPBMiddle = previous1ClosePrice <= snapPowerBoxMiddleValue;

                    bool twoOrMoreBullish = (previous1CandleBullish && previous2CandleBullish)
                                || (previous1CandleBullish && previous3CandleBullish)
                                || (previous2CandleBullish && previous3CandleBullish);

                    bool twoOrMoreBearish = (!previous1CandleBullish && !previous2CandleBullish)
                        || (!previous1CandleBullish && !previous3CandleBullish)
                        || (!previous2CandleBullish && !previous3CandleBullish);

                    if (!inBuySliderSetupCycle)
                    {
                        bool buySlider = (twoOrMoreBearish
                            && previous1HighPrice <= previous2HighPrice && previous2HighPrice <= previous3HighPrice
                            && previous1HighPrice <= autoCloseAndTrailRLValue
                            && previous2HighPrice <= autoCloseAndTrailRLValue2
                            && previous3HighPrice <= autoCloseAndTrailRLValue3);
                    }
                    else
                    {
                        bool buySliderBroken = (!twoOrMoreBearish
                            || previous1HighPrice > previous2HighPrice
                            || previous1HighPrice > autoCloseAndTrailRLValue);

                        if (buySliderBroken)
                        {
                            inBuySliderSetupCycle = false;
                            usedBuySliderSetupCycle = false;
                        }
                    }

                    if (!inSellSliderSetupCycle)
                    {
                        bool sellSlider = (twoOrMoreBullish
                            && previous1LowPrice >= previous2LowPrice && previous2LowPrice >= previous3LowPrice
                            && previous1LowPrice >= autoCloseAndTrailRLValue
                            && previous2LowPrice >= autoCloseAndTrailRLValue2
                            && previous3LowPrice >= autoCloseAndTrailRLValue3);

                        if (sellSlider) inSellSliderSetupCycle = true;
                    }
                    else
                    {
                        bool sellSliderBroken = (!twoOrMoreBullish
                            || previous1LowPrice < previous2LowPrice
                            || previous1LowPrice < autoCloseAndTrailRLValue);

                        if (sellSliderBroken)
                        {
                            inSellSliderSetupCycle = false;
                            usedSellSliderSetupCycle = false;
                        }
                    }
                }


                RefreshObjects();

                isPopDropOnBarUpdateCycleReady = true;

                if (CurrentBar > 5) //keep code block at bottom after values set
                {
                    if (IsFirstTickOfBar)
                    {
                        AutoPilotRunOncePerBar.SetNewBar();
                        AutoAddOnRunOncePerBar.SetNewBar();
                        AutoCloseRunOncePerBar.SetNewBar();
                        AutoBreakEvenRunOncePerBar.SetNewBar();
                        PopDelayedEntryRunOncePerBar.SetNewBar();
                    }
                }

                //RealLogger.PrintOutput("atrValue[0]=" + atrValue[0].ToString());
            }
        }

        private double GetBarPeriodSecondInterval(BarsPeriod barPeriod)
        {
            double returnInverval = BarPeriodSecondInterval;

            if (barPeriod != null)
            {
                if (barPeriod.BarsPeriodType == BarsPeriodType.Minute)
                {
                    returnInverval = barPeriod.Value * 60;
                }
                else if (barPeriod.BarsPeriodType == BarsPeriodType.Second)
                {
                    returnInverval = barPeriod.Value;
                }
            }

            return returnInverval;
        }
        private void RefreshObjects()
        {
            HandleEntryVolumeAutoStatusChange();

            HandleEntryVolumeMaxStatusChange();

            HandleAutoPilotStatusChange();

            HandleAutoPilotLiteStatusChange();

            HandleAutoPilotProfileStatusChange();

            HandleAutoAddOnStatusChange();

            HandleTradeSignalStatusChange();

            HandleAutoCloseStatusChange();

            HandleAutoBreakEvenStatusChange();

            HandleProfitTargetStatusChange();
        }

        private void HandleAutoPilotLiteStatusChange()
        {
            if (lastAutoPilotLiteChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastAutoPilotLiteChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoPilotButton != null)
                    {
                        //string nextAutoPilotLiteButtonText = "";
                        //string nextAutoPilotLiteButtonToolTip = "";

                        //GetAutoPilotButtonText(nextAutoPilotStatus, out nextAutoPilotLiteButtonText, out nextAutoPilotLiteButtonToolTip);

                        currentAutoPilotLiteStatus = nextAutoPilotLiteStatus;

                        lastAutoPilotLiteChangeTime = DateTime.MinValue;
                        nextAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoPilotButton.Background = buttonBGColor;
                            //toggleAutoPilotButton.Content = nextAutoPilotLiteButtonText;
                            //toggleAutoPilotButton.ToolTip = nextAutoPilotLiteButtonToolTip;
                        }));
                        RealLogger.PrintOutput("Activated autopilot lite type " + currentAutoPilotLiteStatus + " (" + currentAutoPilotSetupStatus + " / SpeedLineFilter=" + UseAutoPilotSpeedLineFilter.ToString().ToLower() + " / AutoPilotAddOn=" + useAutoPilotAddOnFlag.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleAutoPilotStatusChange()
        {
            if (lastAutoPilotChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastAutoPilotChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoPilotButton != null)
                    {
                        string nextAutoPilotButtonText = "";
                        string nextAutoPilotButtonToolTip = "";

                        GetAutoPilotButtonText(nextAutoPilotStatus, out nextAutoPilotButtonText, out nextAutoPilotButtonToolTip);

                        currentAutoPilotStatus = nextAutoPilotStatus;

                        lastAutoPilotChangeTime = DateTime.MinValue;
                        nextAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentAutoPilotStatus == TickHunterAutoPilotTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoPilotButton.Background = buttonBGColor;
                            toggleAutoPilotButton.Content = nextAutoPilotButtonText;
                            toggleAutoPilotButton.ToolTip = nextAutoPilotButtonToolTip;
                        }));
                        RealLogger.PrintOutput("Activated autopilot type " + currentAutoPilotStatus + " (" + currentTradeSignalStatus + " / " + currentAutoPilotSetupStatus + " / SpeedLineFilter=" + UseAutoPilotSpeedLineFilter.ToString().ToLower() + " / AutoPilotAddOn=" + useAutoPilotAddOnFlag.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleTradeSignalStatusChange()
        {
            if (lastTradeSignalChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastTradeSignalChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleTradeSignalButton != null)
                    {
                        currentTradeSignalStatus = nextTradeSignalStatus;
                        lastTradeSignalChangeTime = DateTime.MinValue;
                        nextTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentTradeSignalStatus == TickHunterTradeSignalTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleTradeSignalButton.Background = buttonBGColor;
                        }));
                        RealLogger.PrintOutput("Activated trade signal type " + currentTradeSignalStatus + " (" + currentAutoPilotSetupStatus + " / SpeedLineFilter=" + UseAutoPilotSpeedLineFilter.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleAutoPilotProfileStatusChange()
        {
            string signalName = "HandleAutoPilotProfileStatusChange";

            if (lastAutoPilotProfileChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastAutoPilotProfileChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoPilotProfileButton != null)
                    {
                        const int colorDelaySeconds = 0;

                        if (nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy)
                        {
                            currentAutoPilotSetupStatus = TickHunterAutoPilotSetupTypes.PeppySetupCombo;
                            //currentAutoPilotOrderStatus = TickHunterAutoPilotOrderTypes.MarketPop;
                            //currentStopLossInitialSnapStatus = TickHunterStopLossSnapTypes.SnapProfilePeppy;

                            breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit;

                            //closeAutoMinProfitFlag = false;
                            limitTrancheVolumePerBarFlag = (LimitTrancheVolumePerBar && MinTrancheVolumeDelaySeconds > 0);
                            popCTRLDelayedEntryFlag = !UsePeppyLimitPopDelayedEntry;
                            popLimitToPullbackFlag = UsePeppyLimitPopToPullback;

                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                string buttonText = "";
                                string buttonToolTip = "";

                                DeactivateBuyPopButton(signalName);
                                DeactivateSellPopButton(signalName);

                                GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                                Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;

                                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, buttonBGColor);

                                GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);
                                buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;

                                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, buttonBGColor);
                                /*
                                lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.CreeperFlip;
                                GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);
                                SetAutoCloseButton(toggleAutoCloseButton, buttonText, buttonToolTip,
                                    lastToggleEntryCloseAutoStatus, colorDelaySeconds, Brushes.DimGray);
                                */
                                lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                                GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);
                                SetAutoBEButton(toggleAutoBEButton, buttonText, buttonToolTip,
                                    lastToggleEntryBreakEvenAutoStatus, colorDelaySeconds, toggleAutoBEButton.Background);

                            }));
                        }
                        else if (nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Sleepy)
                        {
                            currentAutoPilotSetupStatus = TickHunterAutoPilotSetupTypes.SleepySetupCombo;
                            //currentAutoPilotOrderStatus = TickHunterAutoPilotOrderTypes.MarketPop;
                            //currentStopLossInitialSnapStatus = TickHunterStopLossSnapTypes.SnapProfileSleepy;

                            breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit;

                            //closeAutoMinProfitFlag = false;
                            limitTrancheVolumePerBarFlag = (LimitTrancheVolumePerBar && MinTrancheVolumeDelaySeconds > 0);
                            popCTRLDelayedEntryFlag = !UseSleepyLimitPopDelayedEntry;
                            popLimitToPullbackFlag = UseSleepyLimitPopToPullback;

                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                string buttonText = "";
                                string buttonToolTip = "";

                                DeactivateBuyPopButton(signalName);
                                DeactivateSellPopButton(signalName);

                                GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                                Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;

                                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, buttonBGColor);

                                GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);
                                buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;

                                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, buttonBGColor);

                                /*
                                lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
                                GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);
                                SetAutoCloseButton(toggleAutoCloseButton, buttonText, buttonToolTip,
                                    lastToggleEntryCloseAutoStatus, colorDelaySeconds, Brushes.DimGray);
                                */

                                lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                                GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);
                                SetAutoBEButton(toggleAutoBEButton, buttonText, buttonToolTip,
                                    lastToggleEntryBreakEvenAutoStatus, colorDelaySeconds, toggleAutoBEButton.Background);

                            }));
                        }
                        else
                        {
                            currentAutoPilotSetupStatus = AutoPilotSetupType;
                            //currentAutoPilotOrderStatus = AutoPilotOrderType;
                            //currentStopLossInitialSnapStatus = StopLossInitialSnapType;

                            breakEvenAutoTrailNowFlag = BreakEvenAutoTrailNow;

                            //closeAutoMinProfitFlag = UseAutoCloseMinProfit;
                            limitTrancheVolumePerBarFlag = (LimitTrancheVolumePerBar && MinTrancheVolumeDelaySeconds > 0);
                            popCTRLDelayedEntryFlag = UsePopCTRLDelayedEntry;
                            popLimitToPullbackFlag = UsePopLimitToPullback;

                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                string buttonText = "";
                                string buttonToolTip = "";

                                DeactivateBuyPopButton(signalName);
                                DeactivateSellPopButton(signalName);

                                GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                                Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;

                                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, buttonBGColor);

                                GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);
                                buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;

                                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, buttonBGColor);
                                //DisableAutoCloseButton(colorDelaySeconds);

                                //DisableAutoBEButton(colorDelaySeconds);
                            }));
                        }

                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            if (UseAutoPilotLite)
                            {
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotLiteButton(toggleAutoPilotButton, buttonText, buttonToolTip,
                                        lastToggleEntryAutoPilotLiteStatus, 0, Brushes.DimGray);
                            }
                            else
                            {
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(toggleAutoPilotButton, buttonText, buttonToolTip,
                                        lastToggleEntryAutoPilotStatus, 0, Brushes.DimGray);
                            }
                        }));

                        RealLogger.PrintOutput("Activating auto pilot profile feature: currentAutoPilotSetupType=" + currentAutoPilotSetupStatus.ToString());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: currentAutoPilotProfileSetupStatus=" + currentAutoPilotProfileSetupStatus.ToString());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: currentAutoPilotOrderType=" + currentAutoPilotOrderStatus.ToString());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: breakEvenAutoTrailNow=" + breakEvenAutoTrailNowFlag.ToString().ToLower());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: closeAutoMinProfit=" + closeAutoMinProfitFlag.ToString().ToLower());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: limitTrancheVolumeToInProfit=" + limitTrancheVolumeToInProfitFlag.ToString().ToLower() + " (" + maxInitialTrancheVolumeSize.ToString("N0") + ")");
                        RealLogger.PrintOutput("Activating auto pilot profile feature: limitTrancheVolumePerBar=" + limitTrancheVolumePerBarFlag.ToString().ToLower() + " (" + MinTrancheVolumeDelaySeconds.ToString("N0") + " sec)");
                        RealLogger.PrintOutput("Activating auto pilot profile feature: popLimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: popCTRLDelayedEntryFlag=" + popCTRLDelayedEntryFlag.ToString().ToLower());

                        if (nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy)
                        {
                            RealLogger.PrintOutput("Activating auto pilot profile feature: peppyLimitPopAlignedCreeper=" + UsePeppyLimitPopAlignedCreeper.ToString().ToLower());
                            RealLogger.PrintOutput("Activating auto pilot profile feature: peppyLimitPopAlignedRushLine=" + UsePeppyLimitPopAlignedRushLine.ToString().ToLower());
                        }
                        else if (nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Sleepy)
                        {
                            RealLogger.PrintOutput("Activating auto pilot profile feature: sleepyLimitPopCounterCreeper=" + UseSleepyLimitPopCounterCreeper.ToString().ToLower());
                            RealLogger.PrintOutput("Activating auto pilot profile feature: sleepyLimitPopCounterRushLine=" + UseSleepyLimitPopCounterRushLine.ToString().ToLower());
                        }


                        currentAutoPilotProfileStatus = nextAutoPilotProfileStatus;
                        lastAutoPilotProfileChangeTime = DateTime.MinValue;
                        nextAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoPilotProfileButton.Background = buttonBGColor;
                        }));

                        RealLogger.PrintOutput("Activated auto pilot profile type " + currentAutoPilotProfileStatus + " (" + currentAutoPilotSetupStatus + " / AutoAdjust=" + autoPilotProfileAutoAdjustFlag.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleAutoAddOnStatusChange()
        {
            if (lastAutoAddOnChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastAutoAddOnChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoAddOnButton != null)
                    {
                        if (currentAutoAddOnStatus != nextAutoAddOnStatus)
                            RealLogger.PrintOutput("Activated auto addon type " + nextAutoAddOnStatus + " ( AutoAddOnMaxDollars=$" + autoAddOnMaxDollars.ToString("N2") + " / Margin=$" + attachedInstrumentIntradayMarginDollars + " / MaxVol=" + attachedInstrumentPositionMaxVolume + ")");

                        currentAutoAddOnStatus = nextAutoAddOnStatus;
                        lastAutoAddOnChangeTime = DateTime.MinValue;
                        nextAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentAutoAddOnStatus == TickHunterAutoAddOnTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoAddOnButton.Background = buttonBGColor;
                        }));
                    }
                }
            }
        }

        private void HandleAutoBreakEvenStatusChange()
        {
            if (lastBreakEvenAutoChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastBreakEvenAutoChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoBEButton != null)
                    {
                        if (nextBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMonster
                            || nextBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster
                            || nextBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailBoss)
                            AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                        currentBreakEvenAutoStatus = nextBreakEvenAutoStatus;
                        lastBreakEvenAutoChangeTime = DateTime.MinValue;
                        nextBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;

                        if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.HODL)
                        {
                            ActivateHODL(false);
                        }
                        else if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.HODL && breakEvenAutoHODLFlag)
                        {
                            DeactivateHODL(false);
                        }

                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoBEButton.Background = buttonBGColor;
                        }));

                        int period = 0;

                        if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                            period = AutoPilotSpeedLineFilterPeriod;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                            period = AutoCloseAndTrailMA1Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                            period = AutoCloseAndTrailMA2Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                            period = AutoCloseAndTrailMA3Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                            period = AutoCloseAndTrailMA4Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                            period = AutoCloseAndTrailRLPeriod;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                            period = AutoCloseAndTrailDL1Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                            period = AutoCloseAndTrailDL2Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                            period = AutoCloseAndTrailDL3Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                            period = AutoCloseAndTrailDL4Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                            period = AutoCloseAndTrailR1Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                            period = AutoCloseAndTrailR5Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                            period = AutoCloseAndTrailDL3Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                            period = AutoCloseAndTrailDL4Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                            period = AutoCloseAndTrailDL4Period;

                        if (period != 0)
                        {
                            RealLogger.PrintOutput("Activated break-even auto type " + currentBreakEvenAutoStatus + " (period=" + period + " / TrailNow=" + breakEvenAutoTrailNowFlag.ToString().ToLower() + ")");
                        }
                        else
                        {
                            RealLogger.PrintOutput("Activated break-even auto type " + currentBreakEvenAutoStatus + " (TrailNow=" + breakEvenAutoTrailNowFlag.ToString().ToLower() + ")");
                        }
                    }
                }
            }
        }

        private void ActivateHODL(bool enableLogging = true)
        {
            string signalName = "OnAutoBreakStatusChange";

            if (enableLogging) RealLogger.PrintOutput("HODL activated");
            breakEvenAutoHODLFlag = true;

            CancelPositionAllTakeProfitOrders(signalName);
        }

        private void DeactivateHODL(bool enableLogging = true)
        {
            if (enableLogging) RealLogger.PrintOutput("HODL deactivated");
            breakEvenAutoHODLFlag = false;
        }

        private void CancelPositionAllTakeProfitOrders(string signalName)
        {
            CancelPositionTPOrders(signalName, attachedInstrument);
            if (IsBlendedInstrumentEnabled())
            {
                CancelPositionTPOrders(signalName, blendedInstrument);
            }
        }

        /*
        private void OnAutoBreakStatusChange()
        {
            if (IsHODLEnabled())
            {
                CancelPositionTPOrders("OnAutoBreakStatusChange", attachedInstrument);
                if (IsBlendedInstrumentEnabled())
                {
                    CancelPositionTPOrders("OnAutoBreakStatusChange", blendedInstrument);
                }
            }
        }
        */

        private void HandleAutoCloseStatusChange()
        {
            if (lastCloseAutoChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastCloseAutoChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoCloseButton != null)
                    {
                        currentCloseAutoStatus = nextCloseAutoStatus;
                        lastCloseAutoChangeTime = DateTime.MinValue;
                        nextCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;

                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentCloseAutoStatus == TickHunterCloseAutoTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoCloseButton.Background = buttonBGColor;
                            closeAllButton.Content = (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonText : ToggleCloseButtonText;
                            closeAllButton.ToolTip = (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonToolTip : ToggleCloseButtonToolTip;
                        }));

                        RealLogger.PrintOutput("Activated close auto type " + currentCloseAutoStatus + " (MinProfit=" + closeAutoMinProfitFlag.ToString().ToLower() + " / " + " Alert=" + closeAutoAlertFlag.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleProfitTargetStatusChange()
        {
            string signalName = "HandleProfitTargetStatusChange";

            if (lastProfitTargetChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastProfitTargetChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleProfitTargetButton != null)
                    {
                        if (lastToggleProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget)
                        {
                            currentProfitTargetStatus = nextProfitTargetStatus;
                            lastProfitTargetChangeTime = DateTime.MinValue;
                            nextProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                Brush buttonBGColor = (currentProfitTargetStatus == TickHunterProfitTargetTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                                toggleProfitTargetButton.Background = buttonBGColor;
                                closeAllButton.Content = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonText : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonText : ToggleCloseButtonText;
                                closeAllButton.ToolTip = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonToolTip : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonToolTip : ToggleCloseButtonToolTip;
                            }));

                            RealLogger.PrintOutput("Activated profit type " + currentProfitTargetStatus);
                        }
                        else
                        {
                            bool hasProfitTargetChanged = (currentProfitTargetStatus != nextProfitTargetStatus);

                            currentProfitTargetStatus = nextProfitTargetStatus;
                            nextProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;

                            currentBogeyTargetMultiplier = nextBogeyTargetMultiplier;
                            lastProfitTargetChangeTime = DateTime.MinValue;

                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                Brush buttonBGColor = (currentBogeyTargetMultiplier == BogeyTargetMultiplierDisabled) ? Brushes.DimGray : Brushes.HotPink;
                                toggleProfitTargetButton.Background = buttonBGColor;
                                closeAllButton.Content = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonText : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonText : ToggleCloseButtonText;
                                closeAllButton.ToolTip = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonToolTip : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonToolTip : ToggleCloseButtonToolTip;
                            }));

                            if (hasProfitTargetChanged)
                            {
                                if (currentProfitTargetStatus == TickHunterProfitTargetTypes.Disabled
                                    && UseAutoPositionTakeProfit
                                    && (TakeProfitSyncBogeyTargetPrice || TakeProfitSyncECATargetPrice))
                                {
                                    CancelPositionAllTakeProfitOrders(signalName);
                                }
                            }

                            string startWithText = "StartWithFullPnL=false";

                            if (bogeyTargetStartWithFullPnLFlag)
                            {
                                startWithText = "StartWithFullPnL=true";
                            }

                            RealLogger.PrintOutput("Activated profit type " + currentProfitTargetStatus);
                            RealLogger.PrintOutput("Activated bogey target multiplier x " + currentBogeyTargetMultiplier + " (" + startWithText + ")");

                            if (IsBogeyTargetEnabled())
                            {
                                double bogeyTargetMultiplier = currentBogeyTargetMultiplier; // CalculateBogeyTargetMutiplier(currentBogeyTargetStatus);
                                double dpMultipliedAmount = (BogeyTargetBaseDollars * bogeyTargetMultiplier);

                                RealLogger.PrintOutput("Bogey Target Base: $" + BogeyTargetBaseDollars.ToString("N0") + " x " + bogeyTargetMultiplier.ToString("N0") + " ($" + dpMultipliedAmount.ToString("N0") + ")");
                            }
                        }
                    }
                }
            }
        }

        private void HandleEntryVolumeAutoStatusChange()
        {
            if (lastEntryVolumeAutoChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastEntryVolumeAutoChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleEntryVolumeAutoButton != null)
                    {
                        currentEntryVolumeAutoStatus = nextEntryVolumeAutoStatus;
                        lastEntryVolumeAutoChangeTime = DateTime.MinValue;
                        nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;

                        RealLogger.PrintOutput("Activated auto entry volume type " + currentEntryVolumeAutoStatus + " (" + CalculateAutoEntryVolume(currentEntryVolumeAutoStatus) + ")");
                    }
                }
            }
        }

        private void HandleEntryVolumeMaxStatusChange()
        {
            if (lastEntryVolumeMaxChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastEntryVolumeMaxChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleEntryVolumeMaxButton != null)
                    {
                        currentEntryVolumeMaxStatus = nextEntryVolumeMaxStatus;
                        lastEntryVolumeMaxChangeTime = DateTime.MinValue;
                        nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;

                        RealLogger.PrintOutput("Activated entry volume max type " + currentEntryVolumeMaxStatus + " (" + CalculateEntryVolumeMax(currentEntryVolumeMaxStatus) + ")");

                        limitedVolumeMaxSize = LimitVolumeMax();
                        
                        if (limitTrancheVolumeToInProfitFlag)
                        {
                            RealLogger.PrintOutput("Max Initial Tranche Volume Size: " + maxInitialTrancheVolumeSize.ToString("N0") + " (Increment Volume Size: " + (CalculateAutoEntryVolume(currentEntryVolumeAutoStatus)).ToString("N0") +  ")");
                        }
                    }
                }
            }
        }


        private bool IsBlendedInstrumentEnabled()
        {
            bool returnFLag = false;

            if (UseBlendedInstruments && blendedInstrument != null)
            {
                returnFLag = true;
            }

            return returnFLag;
        }

        private Instrument GetBlendedInstrument(Instrument instrument)
        {
            Instrument foundBlendedInstrument = null;

            if (instrument != null)
            {
                if (instrument == mymInstrument)
                {
                    foundBlendedInstrument = ymInstrument;
                }
                else if (instrument == mesInstrument)
                {
                    foundBlendedInstrument = esInstrument;
                }
                else if (instrument == m2kInstrument)
                {
                    foundBlendedInstrument = rtyInstrument;
                }
                else if (instrument == mnqInstrument)
                {
                    foundBlendedInstrument = nqInstrument;
                }
                else if (instrument == ymInstrument)
                {
                    foundBlendedInstrument = mymInstrument;
                }
                else if (instrument == esInstrument)
                {
                    foundBlendedInstrument = mesInstrument;
                }
                else if (instrument == rtyInstrument)
                {
                    foundBlendedInstrument = m2kInstrument;
                }
                else if (instrument == nqInstrument)
                {
                    foundBlendedInstrument = mnqInstrument;
                }
            }

            return foundBlendedInstrument;
        }

        /*
        private string GenerateAutoPilotStatusText(TickHunterAutoPilotTypes autoPilotType)
        {
            string autoPilotStatusText = ToggleAutoPilotButtonDisabledText;

            if (autoPilotType == TickHunterAutoPilotTypes.TradeCount1)
            {
                autoPilotStatusText = ToggleAutoPilotCount1ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount2)
            {
                autoPilotStatusText = ToggleAutoPilotCount2ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount3)
            {
                autoPilotStatusText = ToggleAutoPilotCount3ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount4)
            {
                autoPilotStatusText = ToggleAutoPilotCount4ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount5)
            {
                autoPilotStatusText = ToggleAutoPilotCount5ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount6)
            {
                autoPilotStatusText = ToggleAutoPilotCount6ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount7)
            {
                autoPilotStatusText = ToggleAutoPilotCount7ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount8)
            {
                autoPilotStatusText = ToggleAutoPilotCount8ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount9)
            {
                autoPilotStatusText = ToggleAutoPilotCount9ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount10)
            {
                autoPilotStatusText = ToggleAutoPilotCount10ButtonEnabledText;
            }

            return autoPilotStatusText;
        }

        private string GenerateAutoPilotStatusToolTip(TickHunterAutoPilotTypes autoPilotType)
        {
            string autoPilotStatusToolTip = ToggleAutoPilotButtonDisabledToolTip;

            if (autoPilotType == TickHunterAutoPilotTypes.TradeCount1)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount1ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount2)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount2ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount3)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount3ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount4)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount4ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount5)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount5ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount6)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount6ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount7)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount7ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount8)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount8ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount9)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount9ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount10)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount10ButtonEnabledToolTip;
            }

            return autoPilotStatusToolTip;
        }
        */

        private string GetInstrumentPeriodText()
        {
            string instrumentName = this.attachedInstrument.FullName;
            string periodText = this.BarsPeriod.Value + " " + this.BarsPeriod.BarsPeriodType.ToString();

            string instrumentPeriodText = instrumentName + " (" + periodText + ")";

            return instrumentPeriodText;
        }

        private void RefreshAccount()
        {
            if (hasRanOnceFirstCycle)
            {
                Account tempAccount = GetAccount();
                if (account != null & tempAccount != account)
                {
                    hasRanOnceFirstCycle = false;
                }
            }
        }

        private void RefreshATMStrategyName()
        {
            if (hasRanOnceFirstCycle)
            {
                string tempATMStrategyName = GetATMStrategy();
                if (tempATMStrategyName != atmStrategyName)
                {
                    hasRanOnceFirstCycle = false;
                }
            }
        }

        private void MarketData_Update(object sender, MarketDataEventArgs e)
        {
            bool newBidAsk = false;

            if (e.Instrument != null)
            {
                Interlocked.Exchange(ref marketDataBidAskPulseStatus, 1);

                double lastPrice = 0;
                double newPrice = 0;
                if (e.MarketDataType == MarketDataType.Ask)
                {
                    lastPrice = RealInstrumentService.GetAskPrice(e.Instrument);
                    newPrice = e.Ask;

                    if (lastPrice != newPrice)
                    {
                        newBidAsk = true;
                        RealInstrumentService.SetAskPrice(e.Instrument, newPrice);
                    }
                }
                else if (e.MarketDataType == MarketDataType.Bid)
                {
                    lastPrice = RealInstrumentService.GetBidPrice(e.Instrument);
                    newPrice = e.Bid;

                    if (lastPrice != newPrice)
                    {
                        newBidAsk = true;
                        RealInstrumentService.SetBidPrice(e.Instrument, newPrice);
                    }
                }
                else if (e.MarketDataType == MarketDataType.Last)
                {
                    lastPrice = RealInstrumentService.GetLastPrice(e.Instrument);
                    newPrice = e.Last;

                    if (lastPrice != newPrice)
                    {
                        //newBidAsk = true;
                        RealInstrumentService.SetLastPrice(e.Instrument, newPrice);
                    }
                }

                /*
                if (newBidAsk)
                {
                    Interlocked.Exchange(ref marketDataBidAskChangeStatus, 1);
                }
                */
            }

            if (newBidAsk)
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(RealTimePipelineLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (RealTimePipeLineThrottleMilliseconds <= 0)
                        {
                            lock (ThreadManagerLock)
                            {
                                TriggerCustomEvent(o =>
                                {
                                    RealTimePipeline();
                                }, null);
                            }
                        }
                        else
                        {
                            bool isNextRealTimeCycleReady = lastRealTimePipeLineCycleChangeTime <= GetDateTimeNow();

                            if (isNextRealTimeCycleReady)
                            {
                                lastRealTimePipeLineCycleChangeTime = (GetDateTimeNow()).AddMilliseconds(RealTimePipeLineThrottleMilliseconds);
                                lock (ThreadManagerLock)
                                {
                                    TriggerCustomEvent(o =>
                                    {
                                        RealTimePipeline();
                                    }, null);
                                }
                            }
                        }

                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling RealTimePipeline:" + ex.Message + " " + ex.StackTrace);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                        Monitor.Exit(RealTimePipelineLock);
                }
            }
        }

        private bool hasMultiCycleOrderElementsOutput = false;
        private bool hasActiveOrdersOutput = false;
        private bool hasOrderUpdateCycleOutput = false;
        private void RealTimePipeline()
        {
            const string signalName = "RealTimePipeline";
            //if (DebugLogLevel > 0) RealLogger.PrintOutput("***Starting RealTimePipeline...",PrintTo.OutputTab1, true);

            DetermineIfWindowHidden();

            if (HasRanOnceFirstCycle()
                && account != null
                && !isIndicatorSuspended
                && IsTickHunterActivated())
            {
                IsNinjaTraderOrdersAlreadyLoaded = false;

                if (RealOrderService.AreAllOrderUpdateCyclesComplete())
                {
                    if (hasMultiCycleOrderElementsOutput)
                    {
                        RealLogger.PrintOutput("Multi-cycle order update(s) cleared...", PrintTo.OutputTab1, true);
                        hasMultiCycleOrderElementsOutput = false;
                    }

                    if (hasActiveOrdersOutput)
                    {
                        RealLogger.PrintOutput("Active order(s) cleared...", PrintTo.OutputTab1, true);
                        hasActiveOrdersOutput = false;
                    }

                    if (hasOrderUpdateCycleOutput)
                    {
                        RealLogger.PrintOutput("Order update cycle cleared...", PrintTo.OutputTab1, true);
                        hasOrderUpdateCycleOutput = false;
                    }

                    AttemptToClosePositionsInProfit();
                    AttemptToClosePositionsInLoss();

                    if (accountHadPositions && IsAccountFlat()
                        && RealOrderService.AreAllOrderUpdateCyclesComplete()
                        && RealOrderService.OrderCount == 0)
                    {
                        accountHadPositions = false;
                        RealLogger.PrintOutput("Account is flat... ", PrintTo.OutputTab1, true);
                    }

                    AttemptToEngageAutoPilot();
                    AttemptToEngagePopDelayedEntry();
                    AttemptToEngageAutoAddOn();

                    //AttemptToEngageAutobot();

                    if (!IsAccountFlat())
                    {
                        if (!accountHadPositions) RealLogger.PrintOutput("Account has active orders...", PrintTo.OutputTab1, true);
                        accountHadPositions = true;
                    }
                }
                else
                {
                    bool readyOutputWithThrottle = (lastOrderOutputTime == DateTime.MinValue || lastOrderOutputTime >= (GetDateTimeNow()).AddSeconds(OrderWaitOutputThrottleSeconds));
                    if (readyOutputWithThrottle)
                    {
                        if (RealOrderService.OrderUpdateMultiCycleCache.HasElements())
                        {
                            RealLogger.PrintOutput("Waiting on " + RealOrderService.OrderUpdateMultiCycleCache.Count.ToString() + " multi-cycle order update(s) to clear...", PrintTo.OutputTab1, true);
                            hasMultiCycleOrderElementsOutput = true;
                        }
                        else if (RealOrderService.HasActiveMarketOrders())
                        {
                            RealLogger.PrintOutput("Waiting on active orders to clear...", PrintTo.OutputTab1, true);
                            hasActiveOrdersOutput = true;
                        }
                        else
                        {
                            RealLogger.PrintOutput("Waiting on order update cycle to clear...", PrintTo.OutputTab1, true);
                            hasOrderUpdateCycleOutput = true;
                        }

                        lastOrderOutputTime = GetDateTimeNow();
                    }
                }

                if (RealOrderService.AreAllOrderUpdateCyclesComplete())
                {
                    HandlePositionInfoRefresh(signalName);
                    RefreshDayOverLines();
                    HandleTPSLRefresh(signalName);
                    // Only check for delayed execution if there are scheduled orders to avoid unnecessary calls
                    if (hasScheduledTakeProfit) CheckAndExecuteDelayedTakeProfit(signalName);
                    if (hasScheduledStopLoss) CheckAndExecuteDelayedStopLoss(signalName);
                    
                    // Throttle label refresh calls for performance
                    if ((DateTime.Now - lastLabelRefreshTime).TotalMilliseconds >= LABEL_REFRESH_THROTTLE_MS)
                    {
                        RefreshRiskInfoLabel();
                        RefreshProfitInfoLabel();
                        RefreshHordeTradeCopierInfoLabel();
                        lastLabelRefreshTime = DateTime.Now;
                    }
                    
                    bool hasAnyLabelContent = (hordeTradeCopierInfoLabel != null && hordeTradeCopierInfoLabel.Text != "")
                        || (dayOverMaxLossInfoLabel != null && dayOverMaxLossInfoLabel.Text != "")
                        || (bogeyTargetInfoLabel != null && bogeyTargetInfoLabel.Text != "")
                        || (riskInfoLabel != null && riskInfoLabel.Text != "")
                        || (profitInfoLabel != null && profitInfoLabel.Text != "");
                    
                    Brush newBackground = hasAnyLabelContent ? Brushes.Black : Brushes.Transparent;
                    if (labelGrid != null && newBackground != labelGridBackgroundCache)
                    {
                        labelGridBackgroundCache = newBackground;
                        labelGrid.Background = labelGridBackgroundCache;
                    }

                    bool isNextPopDropCycleReady = lastPopDropCycleChangeTime <= GetDateTimeNow();

                    if (isNextPopDropCycleReady)
                    {
                        if (PopDropThrottleMilliseconds > 0) lastPopDropCycleChangeTime = (GetDateTimeNow()).AddMilliseconds(PopDropThrottleMilliseconds);

                        bool passedOnBarUpdateDelayCheck = false;

                        if (UsePopDropOnBarUpdateDelay)
                        {
                            if (isPopDropOnBarUpdateCycleReady)
                            {
                                passedOnBarUpdateDelayCheck = true;
                            }
                        }
                        else
                        {
                            passedOnBarUpdateDelayCheck = true;
                        }

                        if (passedOnBarUpdateDelayCheck)
                        {
                            isPopDropOnBarUpdateCycleReady = false;

                            HandlePopAutoJumpToSnap(signalName);
                            HandleDropAutoJumpToSnap(signalName);
                        }
                    }

                    AttemptAccountInfoLogging();
                }
            }
        }


        private void OnTimerTick(object sender, EventArgs e)
        {
            var lockTimeout = TimeSpan.FromMilliseconds(250);
            bool lockTaken = false;

            try
            {
                Monitor.TryEnter(DelayedPipelineLock, lockTimeout, ref lockTaken);

                if (lockTaken)
                {
                    lock (ThreadManagerLock)
                    {
                        TriggerCustomEvent(o =>
                        {
                            DelayedPipeline();
                        }, null);
                    }
                }
            }
            catch (Exception ex)
            {
                //log and stuff exception
                RealLogger.PrintOutput("Exception calling DelayedPipeline:" + ex.Message + " " + ex.StackTrace);
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(DelayedPipelineLock);
            }
        }

        private void DelayedPipeline()
        {
            const string signalName = "DelayedPipeline";

            if (!hasDrawnButtons)
            {
                if (IsStrategyAttachedToChart() && HasRanOnceFirstCycle())
                {
                    if (!hasDrawnButtons)
                    {
                        ForceRefresh();
                    }
                }
            }
        }


        private DateTime GetDateTimeNow()
        {
            DateTime now = DateTime.MinValue;

            bool isUsingPlaybackConnection = (NinjaTrader.Cbi.Connection.PlaybackConnection != null);

            if (isUsingPlaybackConnection)
            {
                now = NinjaTrader.Cbi.Connection.PlaybackConnection.Now;
            }
            else
            {
                now = DateTime.Now;
            }

            return now;
        }


        private void OrderUpdate(Account orderAccount, Instrument orderInstrument, long orderId, string exchangeOrderId, string orderName,
            OrderState orderState, OrderAction orderAction, OrderType orderType, int orderQuantity, int orderQuantityChanged, int orderFilled,
            double orderAverageFillPrice, double orderLimitPrice, double orderLimitPriceChanged, double orderStopPrice, double orderStopPriceChanged,
            bool isMarket, bool isStopMarket, bool isLimit, string orderError)
        {
            string signalName = "OrderUpdate";
            try
            {
                //Print("OrderUpdate- exchangeOrderId=" + exchangeOrderId + " orderId=" + orderId + " orderId=" + orderId + " orderState=" + orderState + " orderAction=" + orderAction + " OrderType=" + orderType);

                RealOrderService.InOrderUpdateCycleIncrement();

                bool hasPositionQuantityChanged = false;
                int remainingPositionQuantity = 0;

                RealOrder updatedOrder = RealOrderService.BuildRealOrder(orderAccount, orderInstrument, orderId, exchangeOrderId, orderName, orderType, orderAction,
                    orderQuantity, orderQuantityChanged,
                    orderLimitPrice, orderLimitPriceChanged, orderStopPrice, orderStopPriceChanged, orderState, orderFilled);

                RealOrderService.AddOrUpdateOrder(updatedOrder);

                string instrumentName = attachedInstrument.FullName;
                bool isAttachedInstrument = orderInstrument == attachedInstrument;
                bool isBlendedInstrument = IsBlendedInstrumentEnabled() && orderInstrument == blendedInstrument;
                string orderUniqueId = RealOrderService.BuildOrderUniqueId(orderId);

                if (DebugLogLevel > 15 && isAttachedInstrument && !RealOrderService.OrderUpdateMultiCycleCache.HasElements()) RealLogger.PrintOutput("***** OrderUpdate-" + instrumentName + ": START *****");
                //RealLogger.PrintOutput("DEBUG: orderId=" + exchangeOrderId + " rderId=" + exchangeOrderId + " orderId=" + orderId + " uniqueId=" + orderUniqueId);

                bool isOrderInitialized = (orderState == OrderState.Initialized);
                bool isOrderCancelPending = (orderState == OrderState.CancelPending || orderState == OrderState.CancelSubmitted);
                bool isChangePending = (orderState == OrderState.ChangePending || orderState == OrderState.ChangeSubmitted);

                bool isStopOrderWorking = (isStopMarket && orderState == OrderState.Working);
                
                // Check if this is a TPSL order in a non-terminal state (being processed)
                bool isStopLossOrder = orderName.StartsWith(RealOrderService.BuildStopOrderName());
                bool isTakeProfitOrder = orderName.StartsWith(RealOrderService.BuildTargetOrderName());
                bool isTPSLOrderInProcess = (isStopLossOrder || isTakeProfitOrder) && !Order.IsTerminalState(orderState);

                if (isOrderInitialized || isOrderCancelPending || isChangePending)
                {
                    bool addedToMultiCycleCache = RealOrderService.OrderUpdateMultiCycleCache.RegisterUniqueId(orderUniqueId);
                    if (DebugLogLevel > 5 && isAttachedInstrument && addedToMultiCycleCache) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": Adding to cache OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " orderaction=" + orderAction.ToString() + " orderType=" + orderType.ToString() + " orderQuan=" + orderQuantity.ToString());
                }

                bool isCancelPendingOrdersActivated = ((isStopMarket || isLimit) && orderState == OrderState.CancelSubmitted);
                bool isFilledPendingOrdersActivated = (!isMarket && (orderState == OrderState.Filled || orderState == OrderState.PartFilled));
                bool orderRateLimited = false;

                if (!string.IsNullOrEmpty(orderError) && orderError.IndexOf("rate limit", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    orderRateLimited = true;
                }
                
                bool isRejected = (orderState == OrderState.Rejected || orderRateLimited);
                //bool isFlat = (isMarket && orderState == OrderState.Filled && orderQuantity == orderFilled);

                if (isRejected)
                {
                    if (isAttachedInstrument || isBlendedInstrument)
                    {
                        RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": rejected OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " price=" + Math.Max(orderStopPrice, orderLimitPrice).ToString() + " orderaction=" + orderAction.ToString() + " lastPrice=" + RealInstrumentService.GetLastPrice(orderInstrument).ToString() + " bidPrice=" + RealInstrumentService.GetBidPrice(orderInstrument).ToString() + " askPrice=" + RealInstrumentService.GetAskPrice(orderInstrument).ToString() + " instrument=" + orderInstrument.FullName);

                        // Use the outer scope variables (already declared above)
                        if (isStopLossOrder || isTakeProfitOrder)
                        {
                            RealPosition foundPosition = null;
                            if (RealPositionService.TryGetByInstrumentFullName(orderInstrument.FullName, out foundPosition))
                            {
                                if (foundPosition.IsValid)
                                {
                                    foundPosition.IsValid = false;
                                    string messageTitle = SystemName + " - Critical Error";
                                    string errorMessage = SystemName + " can no longer protect your position with a stoploss or take profit order due to a rejection from the exchange.Refresh indicators using F5 or close position to reset protection.";

                                    Dispatcher.InvokeAsync(() =>
                                    {
                                        NinjaTrader.Gui.Tools.NTMessageBoxSimple.Show(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), errorMessage, messageTitle, MessageBoxButton.OK, MessageBoxImage.Stop);
                                    });
                                }

                                RealLogger.PrintOutput("*** CRITICAL ERROR: OrderUpdate-" + instrumentName + ": rejected OrderState=" + orderState.ToString() + " - TickHunter no longer protecting with SL/TP due to exchange rejection.  Refresh indicators using F5 or close position to reset protection.");
                            }
                        }
                    }
                }

                if (isCancelPendingOrdersActivated || isFilledPendingOrdersActivated || isStopOrderWorking)
                {
                    //RealLogger.PrintOutput("OrderUpdate delay state = " + orderState.ToString() + " name=" + orderName + " quantity=" + orderQuantity + " filled=" + orderFilled + " orderaction=" + orderAction.ToString() + " position=" + Convert.ToString(positionQuantity));
                    //if (DebugLogLevel > 2 && isAttachedInstrument) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": delay OrderState=" + orderState.ToString() + " name=" + orderName + " OrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " quantity=" + orderQuantity + " filled=" + orderFilled + " orderaction=" + orderAction.ToString() + " positionCount=" + Convert.ToString(RealPositionService.PositionCount) + " instrument=" + orderInstrument.FullName);
                    //SetPendingOrderDelay();
                }

                bool hasFilledOrder = orderFilled > 0 && (orderState == OrderState.PartFilled || orderState == OrderState.Filled);

                /*
                if (hasFilledOrder)
                {
                    int filledQuantity = RealOrderService.GetFilledOrderQuantity(orderId, orderState, orderFilled);

                    if (DebugLogLevel > 15) RealLogger.PrintOutput("***** OrderUpdate-" + instrumentName + ": order filled OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " quantity=" + orderQuantity + " filled=" + orderFilled + " orderaction=" + orderAction.ToString() + " positionCount=" + Convert.ToString(RealPositionService.PositionCount));


                    MarketPosition marketPosition = ConvertOrderActionToMarketPosition(orderAction);

                    RealPosition newPosition = RealPositionService.BuildRealPosition(orderAccount, orderInstrument, marketPosition, filledQuantity, orderAverageFillPrice, GetDateTimeNow());


                    if (DebugLogLevel > 15) RealLogger.PrintOutput("OrderUpdate before AddUpdate positioncount=" + RealPositionService.PositionCount + " filledQuantity=" + filledQuantity + " orderFilled=" + orderFilled + " OrderState = " + orderState.ToString());

                    remainingPositionQuantity = RealPositionService.AddOrUpdatePosition(newPosition);

                    if (DebugLogLevel > 15) RealLogger.PrintOutput("OrderUpdate after AddUpdate remainingPositionQuantity=" + remainingPositionQuantity);

                    if (DebugLogLevel > 2)
                    {
                        if (DebugLogLevel > 2 && isAttachedInstrument) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": order filled OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " quantity=" + orderQuantity + " filled=" + orderFilled + " orderaction=" + orderAction.ToString() + " positionCount=" + Convert.ToString(RealPositionService.PositionCount) + " filledquan=" + filledQuantity.ToString() + " poQuan=" + remainingPositionQuantity.ToString() + " instrument=" + orderInstrument.FullName);
                        //RealLogger.PrintOutput("OrderUpdate after" + " poQuan=" + updatedPositionQuantity.ToString() + " filledquan=" + filledQuantity.ToString()); //debug
                    }

                    if (remainingPositionQuantity > 0) hasPositionQuantityChanged = true;
                }
                */


                bool isCompletedMarketOrder = (isMarket && Order.IsTerminalState(orderState));
                bool isCompletedStopOrder = (isStopMarket && (orderState == OrderState.Accepted || orderState == OrderState.Working));
                bool isCompletedLimitOrder = (isLimit && (orderState == OrderState.Accepted || orderState == OrderState.Working));
                bool isCompletedCancelledOrder = (orderState == OrderState.Cancelled);
                bool isFilledStopOrder = (isStopMarket && orderState == OrderState.Filled);
                bool isFilledLimit = (isLimit && orderState == OrderState.Filled);

                bool hadStopLossFilled = isFilledStopOrder && orderName.StartsWith(RealOrderService.BuildStopOrderName());
                bool hadTakeProfitFilled = isFilledLimit && orderName.StartsWith(RealOrderService.BuildTargetOrderName());

                // Cancel scheduled delayed orders if TPSL orders are being filled or are in non-terminal states (market is "eating" them or they're being processed)
                // This prevents creating new orders while existing ones are being processed
                if (hadStopLossFilled || hadTakeProfitFilled || isTPSLOrderInProcess)
                {
                    // Cancel scheduled stop loss if stop loss order was filled or is being processed (only for stop loss orders, not take profit)
                    if ((hadStopLossFilled || (isStopLossOrder && !Order.IsTerminalState(orderState))) && hasScheduledStopLoss && scheduledStopLossInstrument == orderInstrument)
                    {
                        lock (DelayedStopLossLock)
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Canceling scheduled delayed SL: stop loss order being processed (State=" + orderState.ToString() + ") for " + orderInstrument.FullName + " via " + signalName);
                            hasScheduledStopLoss = false;
                            scheduledStopLossInstrument = null;
                            scheduledStopLossOrderAction = null;
                            scheduledStopLossQuantity = 0;
                            scheduledStopLossPrice = 0;
                            scheduledStopLossCreationTime = DateTime.MinValue;
                        }
                    }
                    
                    // Cancel scheduled take profit if take profit order was filled or is being processed (only for take profit orders, not stop loss)
                    if ((hadTakeProfitFilled || (isTakeProfitOrder && !Order.IsTerminalState(orderState))) && hasScheduledTakeProfit && scheduledTakeProfitInstrument == orderInstrument)
                    {
                        lock (DelayedTakeProfitLock)
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Canceling scheduled delayed TP: take profit order being processed (State=" + orderState.ToString() + ") for " + orderInstrument.FullName + " via " + signalName);
                            hasScheduledTakeProfit = false;
                            scheduledTakeProfitInstrument = null;
                            scheduledTakeProfitOrderAction = null;
                            scheduledTakeProfitQuantity = 0;
                            scheduledTakeProfitPrice = 0;
                            scheduledTakeProfitCreationTime = DateTime.MinValue;
                        }
                    }
                }

                bool foundOrderUniqueId = false;

                // Atomic check-and-remove to prevent TOCTOU race condition
                bool shouldRemove = (isCompletedMarketOrder || isCompletedStopOrder || isCompletedLimitOrder || isRejected || isCompletedCancelledOrder || isFilledStopOrder || isFilledLimit);
                
                if (shouldRemove)
                {
                    foundOrderUniqueId = RealOrderService.OrderUpdateMultiCycleCache.TryDeregisterUniqueId(orderUniqueId);
                    if (foundOrderUniqueId && DebugLogLevel > 5 && isAttachedInstrument) 
                        RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": Removing from cache OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " orderaction=" + orderAction.ToString() + " orderType=" + orderType.ToString());
                }
                else
                {
                    // Check if in cache and touch it (atomic operation)
                    foundOrderUniqueId = RealOrderService.OrderUpdateMultiCycleCache.ContainsKey(orderUniqueId);
                    bool foundInCache = false;
                    if (foundOrderUniqueId)
                        foundInCache = RealOrderService.OrderUpdateMultiCycleCache.TouchUniqueId(orderUniqueId);

                    if (DebugLogLevel > 8 && isAttachedInstrument) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": Not removed from cache OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " orderaction=" + orderAction.ToString() + " orderType=" + orderType.ToString() + " foundInCache=" + foundInCache);
                }

                /*
                if (1==2 && orderFilled > 0)
                {
                    try
                    {
                        StrategyBase atmStrategy = e.Order.GetOwnerStrategy();

                        //if ()

                        //if (atmStrategy == null)
                        {
                            //HandleTPSLRefresh("OrderUpdate");
                        }
                    }
                    catch (Exception ex)
                    {
                        RealLogger.PrintOutput("Exception calling OrderUpdate:" + ex.Message + " " + ex.StackTrace);
                        ///stuff exception
                    }
                }
                */
                //RealLogger.PrintOutput("******** OrderUpdate: OrderServiceCount=" + RealOrderService.OrderCount + " PositionCount=" + RealPositionService.PositionCount);
                if (Order.IsTerminalState(orderState))  //RealPositionService.PositionCount == 0) //Order.IsTerminalState(orderState)) //
                {
                    //RealLogger.PrintOutput("OrderUpdate: before remove OrderServiceCount=" + RealOrderService.OrderCount);
                    //RealOrderService.RemoveAllTerminalStateOrders();
                    RealOrderService.RemoveOrder(orderId);
                    //RealLogger.PrintOutput("OrderUpdate: after remove OrderServiceCount=" + RealOrderService.OrderCount);



                    int orderCount = RealOrderService.OrderCount;

                    for (int index = 0; index < orderCount; index++)
                    {
                        RealOrder order = null;

                        if (RealOrderService.TryGetByIndex(index, out order))
                        {
                            //RealLogger.PrintOutput("OrderUpdate: OrderId=" + order.OrderId + " OrderState=" + order.OrderState);
                        }
                    }

                }
                else
                {
                    //RealLogger.PrintOutput("OrderUpdate: not terminal OrderServiceCount=" + RealOrderService.OrderCount + " exchangeOrderId=" + exchangeOrderId + " OrderState=" + orderState);
                }

                if (hadStopLossFilled)
                {
                    validateAttachedPositionTakeProfitQuantityStage1 = true;
                    if (IsBlendedInstrumentEnabled()) validateBlendedPositionTakeProfitQuantityStage1 = true;

                }
                else if (hadTakeProfitFilled)
                {
                    validateAttachedPositionStopLossQuantityStage1 = true;
                    if (IsBlendedInstrumentEnabled()) validateBlendedPositionStopLossQuantityStage1 = true;
                }
                else if (hasFilledOrder)
                {
                    validateAttachedPositionStopLossQuantityStage1 = true;
                    validateAttachedPositionTakeProfitQuantityStage1 = true;

                    if (IsBlendedInstrumentEnabled())
                    {
                        validateBlendedPositionStopLossQuantityStage1 = true;
                        validateBlendedPositionTakeProfitQuantityStage1 = true;
                    }
                }

                /*
                if (hasPositionQuantityChanged)
                {
                    if (remainingPositionQuantity > 0)
                    {
                        if (hadTakeProfitFilled)
                        {
                            validateAttachedPositionStopLossQuantityStage1 = true;
                            if (IsBlendedInstrumentEnabled()) validateBlendedPositionStopLossQuantityStage1 = true;
                            //validateAttachedPositionStopLossQuantity = true;
                            //validateBlendedPositionStopLossQuantity = true;
                        }
                        else if (hadStopLossFilled)
                        {
                            validateAttachedPositionTakeProfitQuantityStage1 = true;
                            if (IsBlendedInstrumentEnabled()) validateBlendedPositionTakeProfitQuantityStage1 = true;

                            //validateAttachedPositionTakeProfitQuantity = true;
                            //validateBlendedPositionTakeProfitQuantity = true;
                        }
                        else
                        {
                            validateAttachedPositionStopLossQuantityStage1 = true;
                            validateAttachedPositionTakeProfitQuantityStage1 = true;

                            if (IsBlendedInstrumentEnabled())
                            {
                                validateBlendedPositionStopLossQuantityStage1 = true;
                                validateBlendedPositionTakeProfitQuantityStage1 = true;
                            }

                            //validateAttachedPositionStopLossQuantity = true;
                            //validateBlendedPositionStopLossQuantity = true;
                            //validateAttachedPositionTakeProfitQuantity = true;
                            //validateBlendedPositionTakeProfitQuantity = true;
                        }
                    }
                    else
                    {
                        validateAttachedPositionStopLossQuantityStage1 = true;
                        validateAttachedPositionTakeProfitQuantityStage1 = true;

                        if (IsBlendedInstrumentEnabled())
                        {
                            validateBlendedPositionStopLossQuantityStage1 = true;
                            validateBlendedPositionTakeProfitQuantityStage1 = true;
                        }

                        //validateAttachedPositionStopLossQuantity = false;
                        //validateAttachedPositionTakeProfitQuantity = false;
                        //validateBlendedPositionStopLossQuantity = false;
                        //validateBlendedPositionTakeProfitQuantity = false;
                    }
                }
                */

                if (DebugLogLevel > 15 && isAttachedInstrument && !RealOrderService.OrderUpdateMultiCycleCache.HasElements()) RealLogger.PrintOutput("***** OrderUpdate-" + instrumentName + ": END *****");
            }
            catch (Exception ex)
            {
                //log and stuff exception
                RealLogger.PrintOutput("Exception calling OrderUpdate:" + ex.Message + " " + ex.StackTrace);
            }
            finally
            {
                RealOrderService.InOrderUpdateCycleDecrement();
            }
        }


        private void OnOrderUpdate(object sender, OrderEventArgs e)
        {
            try
            {
                if (e != null && e.Order != null)
                {
                    Account orderAccount = e.Order.Account;
                    Instrument orderInstrument = e.Order.Instrument;
                    OrderState orderState = e.OrderState;
                    OrderAction orderAction = e.Order.OrderAction;
                    OrderType orderType = e.Order.OrderType;
                    int orderQuantity = e.Quantity;
                    int orderQuantityChanged = e.Order.QuantityChanged;
                    int orderFilled = e.Filled;
                    double orderAverageFillPrice = e.AverageFillPrice;
                    double orderLimitPrice = e.LimitPrice;
                    double orderStopPrice = e.StopPrice;
                    double orderStopPriceChanged = e.Order.StopPriceChanged;
                    double orderLimitPriceChanged = e.Order.LimitPriceChanged;
                    long orderId = e.Order.Id;
                    string exchangeOrderId = e.Order.OrderId;
                    string orderName = e.Order.Name;
                    bool isStopMarket = e.Order.IsStopMarket;
                    bool isMarket = e.Order.IsMarket;
                    bool isLimit = e.Order.IsLimit;
                    string orderError = e.Comment;

                    OrderUpdate(orderAccount, orderInstrument, orderId, exchangeOrderId, orderName, orderState,
                        orderAction, orderType, orderQuantity, orderQuantityChanged, orderFilled, orderAverageFillPrice,
                        orderLimitPrice, orderLimitPriceChanged, orderStopPrice, orderStopPriceChanged, isMarket, isStopMarket,
                        isLimit, orderError);
                }
            }
            catch (Exception ex)
            {
                //log and stuff exception
                RealLogger.PrintOutput("Exception calling OnOrderUpdate:" + ex.Message + " " + ex.StackTrace);
            }
        }

        private void LoadPositions()
        {
            RealPositionService.LoadPositions(account);
            RealOrderService.LoadOrders(account, RealPositionService.PositionCount);

            if (RealPositionService.PositionCount > 0)
            {
                validateAttachedPositionStopLossQuantity = true;
                validateAttachedPositionTakeProfitQuantity = true;
                validateBlendedPositionStopLossQuantity = true;
                validateBlendedPositionTakeProfitQuantity = true;
            }
        }

        private string EscapeKeyName(string keyName)
        {
            string newKeyName = keyName.Replace(' ', '_');

            return newKeyName;
        }

        string BuildBogeyTargetHLineKey()
        {
            string key = BuildObjectFullName("dayoverbt_");

            return key;
        }

        string BuildBogeyTargetBreakEvenHLineKey()
        {
            string key = BuildObjectFullName("btbe_");

            return key;
        }

        string BuildBogeyTargetDaily1HLineKey()
        {
            string key = BuildObjectFullName("btd1_");

            return key;
        }

        string BuildBogeyTargetDaily2HLineKey()
        {
            string key = BuildObjectFullName("btd2_");

            return key;
        }

        string BuildBogeyTargetDaily3HLineKey()
        {
            string key = BuildObjectFullName("btd3_");

            return key;
        }

        string BuildBogeyTargetDaily4HLineKey()
        {
            string key = BuildObjectFullName("btd4_");

            return key;
        }

        string BuildBogeyTargetDaily5HLineKey()
        {
            string key = BuildObjectFullName("btd5_");

            return key;
        }

        string BuildDayOverMaxLossHLineKey()
        {
            string key = BuildObjectFullName("dayoverdml_");

            return key;
        }

        string BuildDayOverAccountBalanceFloorHLineKey()
        {
            string key = BuildObjectFullName("dayoverabfl_");

            return key;
        }

        string BuildECATakeProfitHLineKey()
        {
            string key = BuildObjectFullName("ecatpl_");

            return key;
        }

        string BuildAveragePriceHLineKey()
        {
            string key = BuildObjectFullName("avgpl_");

            return key;
        }

        private string BuildObjectFullName(string name)
        {
            string fullName = ObjectPrefix + name;
            return fullName;
        }

        private bool RemoveDayOverMaxLossLine()
        {
            bool returnFlag = false;

            if (dayOverMaxLossLineVisible)
            {
                string key = BuildDayOverMaxLossHLineKey();

                RemoveDrawObject(key);

                dayOverMaxLossLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetLine()
        {
            bool returnFlag = false;

            if (bogeyTargetLineVisible)
            {
                string key = BuildBogeyTargetHLineKey();

                RemoveDrawObject(key);

                bogeyTargetLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetBreakEvenLine()
        {
            bool returnFlag = false;

            if (bogeyTargetBreakEvenLineVisible)
            {
                string key = BuildBogeyTargetBreakEvenHLineKey();

                RemoveDrawObject(key);

                bogeyTargetBreakEvenLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily1Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily1LineVisible)
            {
                string key = BuildBogeyTargetDaily1HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily1LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily2Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily2LineVisible)
            {
                string key = BuildBogeyTargetDaily2HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily2LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily3Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily3LineVisible)
            {
                string key = BuildBogeyTargetDaily3HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily3LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily4Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily4LineVisible)
            {
                string key = BuildBogeyTargetDaily4HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily4LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily5Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily5LineVisible)
            {
                string key = BuildBogeyTargetDaily5HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily5LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveDayOverAccountBalanceFloorLine()
        {
            bool returnFlag = false;

            if (dayOverAccountBalanceFloorLineVisible)
            {
                string key = BuildDayOverAccountBalanceFloorHLineKey();

                RemoveDrawObject(key);

                dayOverAccountBalanceFloorLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveECATakeProfitLine()
        {
            bool returnFlag = false;

            if (ecaTakeProfitLineVisible)
            {
                string key = BuildECATakeProfitHLineKey();

                RemoveDrawObject(key);

                ecaTakeProfitLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveAveragePriceLine()
        {
            bool returnFlag = false;

            if (averagePriceLineVisible)
            {
                string key = BuildAveragePriceHLineKey();

                RemoveDrawObject(key);

                averagePriceLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private void DrawHLine(string key, double price, Brush lineColor, DashStyleHelper lineDashStyle, int lineWidth, int zOrder = 10000)
        {
            HorizontalLine tempObject = Draw.HorizontalLine(this, key, false, price, lineColor, lineDashStyle, lineWidth);
            tempObject.IsLocked = true;
            tempObject.IgnoresUserInput = true;
            tempObject.ZOrder = zOrder;

            tempObject.Dispose();
        }
        private void DrawLabeledHLine(string key, double price, Brush lineColor, DashStyleHelper lineDashStyle, int lineWidth, string text, double horizontalOffset, int zOrder = 10000)
        {
            int fontSize = 13;
            int opacity = 100;

            ZLabeledHorizontalLine tempObject = DrawZLabledLine.ZLabeledHorizontalLine(this, key, false, price, lineColor, lineDashStyle, lineWidth);
            tempObject.AppendPriceTime = false;
            tempObject.DisplayText = text;
            tempObject.Font = new SimpleFont(this.ChartControl.Properties.LabelFont.Family.ToString(), fontSize);
            tempObject.HorizontalOffset = horizontalOffset;
            tempObject.OutlineStroke = new Stroke(lineColor, lineWidth);
            tempObject.AreaOpacity = opacity;
            tempObject.TextBrush = Brushes.Black;
            tempObject.BackgroundBrush = lineColor;
            tempObject.ZOrder = zOrder;

            tempObject.IsLocked = true;
            tempObject.IgnoresUserInput = true;

            tempObject.Dispose();
        }

        private void RefreshDayOverLines()
        {
            string signalName = "RefreshDayOverLines";
            bool removedLine = false;

            if (IsDayOverAccountBalanceFloorEnabled() && dayOverAccountBalanceFloorHasChanged)
            {
                if (IsDayOverAccountBalanceFloorEnabled())
                {
                    bool readyForRefresh = lastDayOverAccountBalanceRefreshTime <= GetDateTimeNow();

                    if (readyForRefresh || lastDayOverAccountBalance <= 0)
                    {
                        lastDayOverAccountBalance = Math.Round(account.Get(AccountItem.CashValue, Currency.UsDollar), 2);
                        lastDayOverAccountBalanceRefreshTime = (GetDateTimeNow()).AddSeconds(DayOverAccountBalanceRefreshDelaySeconds);
                    }
                }

                bool lastDayOverAccountBalanceFloorDollarsChanged = lastDayOverAccountBalance != lastDayOverAccountBalanceFloorDollars;
                if (lastDayOverAccountBalanceFloorDollarsChanged) lastDayOverAccountBalanceFloorDollars = lastDayOverAccountBalance;
                bool lastDayOverAccountBalanceFloorPositionTypeChanged = dayOverAccountBalanceFloorMarketPosition != lastDayOverAccountBalanceFloorPositionType;
                bool lastDayOverAccountBalanceFloorPositionPriceChanged = dayOverAccountBalanceFloorPositionPrice != lastDayOverAccountBalanceFloorPositionPrice;
                bool lastDayOverAccountBalanceFloorPositionQuantityChanged = dayOverAccountBalanceFloorPositionQuantity != lastDayOverAccountBalanceFloorPositionQuantity;

                if (attachedInstrumentHasPosition && lastDayOverAccountBalance > 0 &&
                    (lastDayOverAccountBalanceFloorPositionTypeChanged ||
                    lastDayOverAccountBalanceFloorDollarsChanged ||
                    lastDayOverAccountBalanceFloorPositionPriceChanged ||
                    lastDayOverAccountBalanceFloorPositionQuantityChanged))
                {

                    lastDayOverAccountBalanceFloorPositionType = dayOverAccountBalanceFloorMarketPosition;
                    lastDayOverAccountBalanceFloorPositionPrice = dayOverAccountBalanceFloorPositionPrice;
                    lastDayOverAccountBalanceFloorPositionQuantity = dayOverAccountBalanceFloorPositionQuantity;

                    double newLinePrice = 0;

                    double equityToFloorDiff = lastDayOverAccountBalance - DayOverAccountBalanceFloorDollars;

                    if (lastDayOverAccountBalanceFloorPositionType == MarketPosition.Long)
                    {
                        int balanceToFloorRemainingTicks = (int)Math.Ceiling((equityToFloorDiff / (lastDayOverAccountBalanceFloorPositionQuantity * attachedInstrumentTickValue)));
                        newLinePrice = lastDayOverAccountBalanceFloorPositionPrice - (balanceToFloorRemainingTicks * attachedInstrumentTickSize);
                    }
                    else if (lastDayOverAccountBalanceFloorPositionType == MarketPosition.Short)
                    {
                        int balanceToFloorRemainingTicks = (int)Math.Floor(equityToFloorDiff / (lastDayOverAccountBalanceFloorPositionQuantity * attachedInstrumentTickValue));
                        newLinePrice = lastDayOverAccountBalanceFloorPositionPrice + (balanceToFloorRemainingTicks * attachedInstrumentTickSize);
                    }

                    bool isLinePriceValid = newLinePrice > 0;

                    if (isLinePriceValid)
                    {
                        bool dayOverAccountBalanceFloorLinePriceChanged = (newLinePrice != lastDayOverAccountBalanceFloorLinePrice);

                        if (dayOverAccountBalanceFloorLinePriceChanged)
                        {
                            lastDayOverAccountBalanceFloorLinePrice = newLinePrice;

                            string key = BuildDayOverAccountBalanceFloorHLineKey();
                            DrawHLine(key, lastDayOverAccountBalanceFloorLinePrice, dayOverAccountBalanceFloorLineBrush, dayOverAccountBalanceFloorLineDashStyle, dayOverAccountBalanceFloorLineWidth);
                            dayOverAccountBalanceFloorLineVisible = true;
                        }
                    }
                }
            }

            if (dayOverAccountBalanceFloorLineVisible && (!attachedInstrumentHasPosition || !IsDayOverAccountBalanceFloorEnabled()))
            {
                lastDayOverAccountBalanceRefreshTime = GetDateTimeNow();
                lastDayOverAccountBalanceFloorPositionType = MarketPosition.Flat;
                lastDayOverAccountBalanceFloorLinePrice = 0;
                lastDayOverAccountBalanceFloorPositionPrice = 0;
                lastDayOverAccountBalanceFloorPositionQuantity = 0;

                removedLine = (RemoveDayOverAccountBalanceFloorLine()) ? true : removedLine;
            }

            bool isBogeyTargetBreakEvenEnabled = (ShowBogeyTargetDailyBreakEvenLine && !bogeyTargetBreakEvenLineIsBrushTransparent);
            bool isBogeyTargetDaily1Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily1Line && !bogeyTargetDaily1LineIsBrushTransparent);
            bool isBogeyTargetDaily2Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily2Line && !bogeyTargetDaily2LineIsBrushTransparent);
            bool isBogeyTargetDaily3Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily3Line && !bogeyTargetDaily3LineIsBrushTransparent);
            bool isBogeyTargetDaily4Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily4Line && !bogeyTargetDaily4LineIsBrushTransparent);
            bool isBogeyTargetDaily5Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily5Line && !bogeyTargetDaily5LineIsBrushTransparent);

            bool hasAnySupportedBogeyTarget = (IsBogeyTargetEnabled()
                || isBogeyTargetBreakEvenEnabled
                || isBogeyTargetDaily1Enabled
                || isBogeyTargetDaily2Enabled
                || isBogeyTargetDaily3Enabled
                || isBogeyTargetDaily4Enabled
                || isBogeyTargetDaily5Enabled);

            //if (BogeyTargetBaseDollars > 0 && currentBogeyTargetMultiplier != BogeyTargetMultiplierDisabled
            //&& currentProfitTargetStatus == TickHunterProfitTargetTypes.BogeyTarget)

            if (hasAnySupportedBogeyTarget && bogeyTargetHasChanged) //needs to be modified
            {
                double newLastBogeyTargetClosedOrderProfit = Math.Round(account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);
                bool lastBogeyTargetClosedOrderProfitChanged = newLastBogeyTargetClosedOrderProfit != lastBogeyTargetClosedOrderProfit;
                if (lastBogeyTargetClosedOrderProfitChanged) lastBogeyTargetClosedOrderProfit = newLastBogeyTargetClosedOrderProfit;

                double newBogeyTargetBaseDollars = 0;

                if (IsBogeyTargetEnabled())
                {
                    double bogeyTargetMultiplier = currentBogeyTargetMultiplier;

                    if (bogeyTargetStartWithFullPnLFlag)
                    {
                        newBogeyTargetBaseDollars = (this.BogeyTargetBaseDollars * bogeyTargetMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);
                    }
                    else
                    {
                        newBogeyTargetBaseDollars = this.BogeyTargetBaseDollars;
                    }

                    /*
                     if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetBaseDollars = (this.BogeyTargetBaseDollars * bogeyTargetMultiplier) - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        if (bogeyTargetStartWithFullPnLFlag)
                        {
                            newBogeyTargetBaseDollars = (this.BogeyTargetBaseDollars * bogeyTargetMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);
                        }
                        else
                        {
                            newBogeyTargetBaseDollars = (this.BogeyTargetBaseDollars * bogeyTargetMultiplier);
                        }
                    }
                     */

                    if (newBogeyTargetBaseDollars <= 0) newBogeyTargetBaseDollars = 0.1;
                }

                bool lastBogeyTargetBaseDollarsChanged = newBogeyTargetBaseDollars != lastBogeyTargetBaseDollars;
                if (lastBogeyTargetBaseDollarsChanged) lastBogeyTargetBaseDollars = newBogeyTargetBaseDollars;

                if (IsBogeyTargetEnabled() && bogeyTargetInfoLabel != null && (bogeyTargetInfoLabel.Text == "" || lastBogeyTargetBaseDollarsChanged))
                {
                    string bogeyTargetInfoText = "BogeyTarget: $" + this.BogeyTargetBaseDollars.ToString("N0") + " / $" + lastBogeyTargetBaseDollars.ToString("N0");

                    if (bogeyTargetInfoText != bogeyTargetInfoTextCache)
                    {
                        bogeyTargetInfoTextCache = bogeyTargetInfoText;
                        bogeyTargetInfoLabel.Text = bogeyTargetInfoTextCache;
                        
                        Visibility newVisibility = (string.IsNullOrEmpty(bogeyTargetInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible;
                        if (newVisibility != bogeyTargetInfoVisibilityCache)
                        {
                            bogeyTargetInfoVisibilityCache = newVisibility;
                            bogeyTargetInfoLabel.Visibility = bogeyTargetInfoVisibilityCache;
                        }
                    }
                }

                bool lastBogeyTargetPositionTypeChanged = bogeyTargetMarketPosition != lastBogeyTargetPositionType;
                bool lastBogeyTargetPositionPriceChanged = bogeyTargetPositionPrice != lastBogeyTargetPositionPrice;
                bool lastBogeyTargetPositionQuantityChanged = bogeyTargetPositionQuantity != lastBogeyTargetPositionQuantity;

                double newBogeyTargetBreakEvenDollars = 0;
                bool flippedBogeyTargetBreakEvenDollars = false;

                if (isBogeyTargetBreakEvenEnabled)
                {
                    double adjustedBogeyBreakEvenDollars = lastBogeyTargetClosedOrderProfit;

                    if (adjustedBogeyBreakEvenDollars < 0)
                    {
                        flippedBogeyTargetBreakEvenDollars = true;
                        adjustedBogeyBreakEvenDollars *= -1;
                    }

                    if (adjustedBogeyBreakEvenDollars <= 0) adjustedBogeyBreakEvenDollars = 0.1;
                    newBogeyTargetBreakEvenDollars = adjustedBogeyBreakEvenDollars;

                    /*
                    const double BreakEventBaseDollars = 1.0;

                    if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetBreakEvenDollars = BreakEventBaseDollars - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        newBogeyTargetBreakEvenDollars = (BreakEventBaseDollars) + (lastBogeyTargetClosedOrderProfit * -1);
                    }

                    if (newBogeyTargetBreakEvenDollars <= 0) newBogeyTargetBreakEvenDollars = 0.1;
                    */
                }
                

                bool lastBogeyTargetBreakEvenDollarsChanged = newBogeyTargetBreakEvenDollars != lastBogeyTargetBreakEvenDollars;
                if (lastBogeyTargetBreakEvenDollarsChanged) lastBogeyTargetBreakEvenDollars = newBogeyTargetBreakEvenDollars;
                

                double newBogeyTargetDaily1Dollars = 0;

                if (isBogeyTargetDaily1Enabled)
                {
                    newBogeyTargetDaily1Dollars = (this.BogeyTargetDailyBaseDollars) + (lastBogeyTargetClosedOrderProfit * -1);

                    if (newBogeyTargetDaily1Dollars <= 0) newBogeyTargetDaily1Dollars = 0.1;
                }

                bool lastBogeyTargetDaily1DollarsChanged = newBogeyTargetDaily1Dollars != lastBogeyTargetDaily1Dollars;
                if (lastBogeyTargetDaily1DollarsChanged) lastBogeyTargetDaily1Dollars = newBogeyTargetDaily1Dollars;

                double newBogeyTargetDaily2Dollars = 0;

                if (isBogeyTargetDaily2Enabled)
                {
                    const double BogyTargetDailyMultiplier = 2;

                    newBogeyTargetDaily2Dollars = (this.BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);

                    if (newBogeyTargetDaily2Dollars <= 0) newBogeyTargetDaily2Dollars = 0.1;
                }

                bool lastBogeyTargetDaily2DollarsChanged = newBogeyTargetDaily2Dollars != lastBogeyTargetDaily2Dollars;
                if (lastBogeyTargetDaily2DollarsChanged) lastBogeyTargetDaily2Dollars = newBogeyTargetDaily2Dollars;

                double newBogeyTargetDaily3Dollars = 0;

                if (isBogeyTargetDaily3Enabled)
                {
                    const double BogyTargetDailyMultiplier = 3;

                    newBogeyTargetDaily3Dollars = (this.BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);

                    if (newBogeyTargetDaily3Dollars <= 0) newBogeyTargetDaily3Dollars = 0.1;
                }

                bool lastBogeyTargetDaily3DollarsChanged = newBogeyTargetDaily3Dollars != lastBogeyTargetDaily3Dollars;
                if (lastBogeyTargetDaily3DollarsChanged) lastBogeyTargetDaily3Dollars = newBogeyTargetDaily3Dollars;

                double newBogeyTargetDaily4Dollars = 0;

                if (isBogeyTargetDaily4Enabled)
                {
                    const double BogyTargetDailyMultiplier = 4;

                    newBogeyTargetDaily4Dollars = (this.BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);

                    if (newBogeyTargetDaily4Dollars <= 0) newBogeyTargetDaily4Dollars = 0.1;
                }

                bool lastBogeyTargetDaily4DollarsChanged = newBogeyTargetDaily4Dollars != lastBogeyTargetDaily4Dollars;
                if (lastBogeyTargetDaily4DollarsChanged) lastBogeyTargetDaily4Dollars = newBogeyTargetDaily4Dollars;

                double newBogeyTargetDaily5Dollars = 0;

                if (isBogeyTargetDaily5Enabled)
                {
                    const double BogyTargetDailyMultiplier = 5;

                    newBogeyTargetDaily5Dollars = (this.BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);

                    if (newBogeyTargetDaily5Dollars <= 0) newBogeyTargetDaily5Dollars = 0.1;
                }

                bool lastBogeyTargetDaily5DollarsChanged = newBogeyTargetDaily5Dollars != lastBogeyTargetDaily5Dollars;
                if (lastBogeyTargetDaily5DollarsChanged) lastBogeyTargetDaily5Dollars = newBogeyTargetDaily5Dollars;

                if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                {
                    if (lastBogeyTargetBaseDollarsChanged
                        || lastBogeyTargetBreakEvenDollarsChanged
                        || lastBogeyTargetDaily1DollarsChanged || lastBogeyTargetDaily2DollarsChanged || lastBogeyTargetDaily3DollarsChanged
                        || lastBogeyTargetDaily4DollarsChanged || lastBogeyTargetDaily5DollarsChanged
                        || lastBogeyTargetPositionTypeChanged || lastBogeyTargetPositionPriceChanged || lastBogeyTargetPositionQuantityChanged)
                    {
                        lastBogeyTargetPositionType = bogeyTargetMarketPosition;
                        lastBogeyTargetPositionPrice = bogeyTargetPositionPrice;
                        lastBogeyTargetPositionQuantity = bogeyTargetPositionQuantity;

                        if (IsBogeyTargetEnabled())
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBaseDollars);
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBaseDollars);
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetLinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetLinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetHLineKey();
                                    DrawHLine(key, lastBogeyTargetLinePrice, bogeyTargetLineBrush, bogeyTargetLineDashStyle, bogeyTargetLineWidth);

                                    bogeyTargetLineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetBreakEvenEnabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                if (flippedBogeyTargetBreakEvenDollars)
                                    newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBreakEvenDollars);
                                else
                                    newLinePrice = GetDayOverMaxLossFromDollars(MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBreakEvenDollars);
                                
                                    //newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBreakEvenDollars);

                                /*
                                RealLogger.PrintOutput("DEBUG newLinePrice=" + newLinePrice + " lastBogeyTargetPositionPrice=" + lastBogeyTargetPositionPrice + " lastBogeyTargetBreakEvenDollars=" + lastBogeyTargetBreakEvenDollars + " flippedBogeyBreakEvenDollars=" + flippedBogeyBreakEvenDollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    //newLinePrice = 0;
                                }
                                */
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                if (flippedBogeyTargetBreakEvenDollars)
                                    newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBreakEvenDollars);
                                else
                                    newLinePrice = GetDayOverMaxLossFromDollars(MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBreakEvenDollars);

                                /*
                                RealLogger.PrintOutput("DEBUG newLinePrice=" + newLinePrice + " lastBogeyTargetPositionPrice=" + lastBogeyTargetPositionPrice + " lastBogeyTargetBreakEvenDollars=" + lastBogeyTargetBreakEvenDollars + " flippedBogeyBreakEvenDollars=" + flippedBogeyBreakEvenDollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                                */
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetBreakEvenLinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetBreakEvenLinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetBreakEvenHLineKey();
                                    DrawHLine(key, lastBogeyTargetBreakEvenLinePrice, bogeyTargetBreakEvenLineBrush, bogeyTargetBreakEvenLineDashStyle, bogeyTargetBreakEvenLineWidth);

                                    bogeyTargetBreakEvenLineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily1Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily1Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily1Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily1LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily1LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily1HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily1LinePrice, bogeyTargetDaily1LineBrush, bogeyTargetDaily1LineDashStyle, bogeyTargetDaily1LineWidth);

                                    bogeyTargetDaily1LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily2Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily2Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily2Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily2LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily2LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily2HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily2LinePrice, bogeyTargetDaily2LineBrush, bogeyTargetDaily2LineDashStyle, bogeyTargetDaily2LineWidth);

                                    bogeyTargetDaily2LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily3Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily3Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily3Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily3LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily3LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily3HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily3LinePrice, bogeyTargetDaily3LineBrush, bogeyTargetDaily3LineDashStyle, bogeyTargetDaily3LineWidth);

                                    bogeyTargetDaily3LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily4Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily4Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily4Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily4LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily4LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily4HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily4LinePrice, bogeyTargetDaily4LineBrush, bogeyTargetDaily4LineDashStyle, bogeyTargetDaily4LineWidth);

                                    bogeyTargetDaily4LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily5Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily5Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily5Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily5LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily5LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily5HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily5LinePrice, bogeyTargetDaily5LineBrush, bogeyTargetDaily5LineDashStyle, bogeyTargetDaily5LineWidth);

                                    bogeyTargetDaily5LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                    }
                }
            }

            if (!IsBogeyTargetEnabled())
            {
                if (bogeyTargetInfoLabel != null)
                {
                    string emptyText = "";
                    if (emptyText != bogeyTargetInfoTextCache)
                    {
                        bogeyTargetInfoTextCache = emptyText;
                        bogeyTargetInfoLabel.Text = bogeyTargetInfoTextCache;
                        
                        Visibility newVisibility = (string.IsNullOrEmpty(bogeyTargetInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible;
                        if (newVisibility != bogeyTargetInfoVisibilityCache)
                        {
                            bogeyTargetInfoVisibilityCache = newVisibility;
                            bogeyTargetInfoLabel.Visibility = bogeyTargetInfoVisibilityCache;
                        }
                    }
                }
            }

            if (bogeyTargetLineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !IsBogeyTargetEnabled()))
            {
                lastBogeyTargetPositionType = MarketPosition.Flat;
                lastBogeyTargetLinePrice = 0;
                lastBogeyTargetPositionPrice = 0;
                lastBogeyTargetPositionQuantity = 0;
                removedLine = (RemoveBogeyTargetLine()) ? true : removedLine;
            }

            if (bogeyTargetBreakEvenLineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetBreakEvenEnabled))
            {
                lastBogeyTargetBreakEvenLinePrice = 0;
                lastBogeyTargetBreakEvenDollars = 0;
                RemoveBogeyTargetBreakEvenLine();
            }

            if (bogeyTargetDaily1LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily1Enabled))
            {
                lastBogeyTargetDaily1LinePrice = 0;
                lastBogeyTargetDaily1Dollars = 0;
                RemoveBogeyTargetDaily1Line();
            }

            if (bogeyTargetDaily2LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily2Enabled))
            {
                lastBogeyTargetDaily2LinePrice = 0;
                lastBogeyTargetDaily2Dollars = 0;
                RemoveBogeyTargetDaily2Line();
            }

            if (bogeyTargetDaily3LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily3Enabled))
            {
                lastBogeyTargetDaily3LinePrice = 0;
                lastBogeyTargetDaily3Dollars = 0;
                RemoveBogeyTargetDaily3Line();
            }

            if (bogeyTargetDaily4LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily4Enabled))
            {
                lastBogeyTargetDaily4LinePrice = 0;
                lastBogeyTargetDaily4Dollars = 0;
                RemoveBogeyTargetDaily4Line();
            }

            if (bogeyTargetDaily5LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily5Enabled))
            {
                lastBogeyTargetDaily5LinePrice = 0;
                lastBogeyTargetDaily5Dollars = 0;
                RemoveBogeyTargetDaily5Line();
            }

            if (IsDayOverMaxLossEnabled() && dayOverMaxLossHasChanged)
            {
                double newLastDayOverMaxLossClosedOrderProfit = Math.Round(account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);
                bool lastDayOverMaxLossClosedOrderProfitChanged = newLastDayOverMaxLossClosedOrderProfit != lastDayOverMaxLossClosedOrderProfit;
                if (lastDayOverMaxLossClosedOrderProfitChanged) lastDayOverMaxLossClosedOrderProfit = newLastDayOverMaxLossClosedOrderProfit;

                //if (lastDayOverMaxLossClosedOrderProfitChanged && newLastDayOverMaxLossClosedOrderProfit > lastDayOverMaxLossHighestPnLInSessionPnL)
                //{
                //    lastDayOverMaxLossHighestPnLInSessionPnL = newLastDayOverMaxLossClosedOrderProfit;
                //    StoreStateDayOverMaxLossHighestPnLInSession();
                //}

                //RealLogger.PrintOutput("lastDayOverMaxLossHighestPnLInSessionPnL=" + lastDayOverMaxLossHighestPnLInSessionPnL + " newLastDayOverMaxLossClosedOrderProfit=" + newLastDayOverMaxLossClosedOrderProfit);

                double newDayOverMaxLossDollars = 0;

                //if (DayOverMaxLossIncludeProfit)
                //{

                //}
                //else
                //{
                //    newDayOverMaxLossDollars = this.DayOverMaxLossDollars - lastDayOverMaxLossHighestPnLInSessionPnL + lastDayOverMaxLossClosedOrderProfit;
                //}
                newDayOverMaxLossDollars = this.dayOverMaxLossDollars + lastDayOverMaxLossClosedOrderProfit;

                bool lastDayOverMaxLossDollarsChanged = newDayOverMaxLossDollars != lastDayOverMaxLossDollars;
                if (lastDayOverMaxLossDollarsChanged)
                {
                    lastDayOverMaxLossDollars = newDayOverMaxLossDollars;

                    if (UseDayOverMaxLossTrailing)
                    {
                        if (DayOverMaxAccountPnLPeakDollars > 0)
                        {
                            dayOverMaxAccountPnLPeakDollars = Math.Max(DayOverMaxAccountPnLPeakDollars, lastDayOverMaxLossClosedOrderProfit);
                        }
                        else
                        {
                            dayOverMaxAccountPnLPeakDollars = Math.Max(dayOverMaxAccountPnLPeakDollars, lastDayOverMaxLossClosedOrderProfit);
                        }

                        lastDayOverMaxLossDollars = (this.dayOverMaxLossDollars + lastDayOverMaxLossClosedOrderProfit) - dayOverMaxAccountPnLPeakDollars;
                    }

                    double lastAutoAddOnMaxDollar = autoAddOnMaxDollars;
                    autoAddOnMaxDollars = CalculateAutoAddOnMaxDollars(AutoAddOnMaxDollars, StopLossInitialDollars, lastDayOverMaxLossDollars);
                    bool autoAddOnMaxDollarsChanged = lastAutoAddOnMaxDollar != autoAddOnMaxDollars;

                    if (toggleAutoAddOnButton != null && autoAddOnMaxDollarsChanged && currentAutoAddOnStatus == TickHunterAutoAddOnTypes.Disabled)
                    {
                        DisableAutoAddOnButton(0);
                    }
                }

                bool lastDayOverMaxLossPositionTypeChanged = dayOverMaxLossMarketPosition != lastDayOverMaxLossPositionType;
                bool lastDayOverMaxLossPositionPriceChanged = dayOverMaxLossPositionPrice != lastDayOverMaxLossPositionPrice;
                bool lastDayOverMaxLossPositionQuantityChanged = dayOverMaxLossPositionQuantity != lastDayOverMaxLossPositionQuantity;

                if (lastDayOverMaxLossDollars <= 0)
                {
                    activeDayOverMaxLossAutoClose = true;
                }
                else
                {
                    activeDayOverMaxLossAutoClose = false;
                }

                if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                {
                    if (!activeDayOverMaxLossAutoClose &&
                        (lastDayOverMaxLossPositionTypeChanged || lastDayOverMaxLossDollarsChanged || lastDayOverMaxLossPositionPriceChanged || lastDayOverMaxLossPositionQuantityChanged))
                    {
                        lastDayOverMaxLossPositionType = dayOverMaxLossMarketPosition;
                        lastDayOverMaxLossPositionPrice = dayOverMaxLossPositionPrice;
                        lastDayOverMaxLossPositionQuantity = dayOverMaxLossPositionQuantity;

                        double newLinePrice = 0;

                        if (lastDayOverMaxLossPositionType == MarketPosition.Long)
                        {
                            newLinePrice = GetDayOverMaxLossFromDollars(MarketPosition.Long, lastDayOverMaxLossPositionPrice, lastDayOverMaxLossPositionQuantity, lastDayOverMaxLossDollars);
                        }
                        else if (lastDayOverMaxLossPositionType == MarketPosition.Short)
                        {
                            newLinePrice = GetDayOverMaxLossFromDollars(MarketPosition.Short, lastDayOverMaxLossPositionPrice, lastDayOverMaxLossPositionQuantity, lastDayOverMaxLossDollars);
                        }

                        bool isLinePriceValid = newLinePrice > 0;

                        if (isLinePriceValid)
                        {
                            bool dayOverMaxLossLinePriceChanged = (newLinePrice != lastDayOverMaxLossLinePrice);

                            if (dayOverMaxLossLinePriceChanged)
                            {
                                lastDayOverMaxLossLinePrice = newLinePrice;

                                string key = BuildDayOverMaxLossHLineKey();
                                DrawHLine(key, lastDayOverMaxLossLinePrice, dayOverMaxLossLineBrush, dayOverMaxLossLineDashStyle, dayOverMaxLossLineWidth);

                                dayOverMaxLossLineVisible = true;

                                dayOverMaxLossLinePriceChanged = false;
                            }
                        }
                    }
                }
            }


            if (dayOverMaxLossLineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !IsDayOverMaxLossEnabled()))
            {
                lastDayOverMaxLossPositionType = MarketPosition.Flat;
                lastDayOverMaxLossLinePrice = 0;
                lastDayOverMaxLossPositionPrice = 0;
                lastDayOverMaxLossPositionQuantity = 0;
                removedLine = (RemoveDayOverMaxLossLine()) ? true : removedLine;
            }

            //Print("dayOverAccountBalanceFloorHasChanged=" + dayOverAccountBalanceFloorHasChanged + " lastDayOverAccountBalanceFloorDollars=" + lastDayOverAccountBalanceFloorDollars);

            if (dayOverMaxLossInfoLabel != null && (dayOverMaxLossHasChanged || dayOverAccountBalanceFloorHasChanged))
            {
                bool lastDayOverAccountFloorInfoDollarsChanged = false;
                bool lastDayOverMaxLossInfoDollarsChanged = false;

                if (IsDayOverAccountBalanceFloorEnabled() && dayOverAccountBalanceFloorHasChanged)
                {
                    lastDayOverAccountFloorInfoDollarsChanged = lastDayOverAccountFloorInfoDollars != DayOverAccountBalanceFloorDollars;
                    if (lastDayOverAccountFloorInfoDollarsChanged) lastDayOverAccountFloorInfoDollars = DayOverAccountBalanceFloorDollars;

                    if (lastDayOverAccountFloorInfoDollarsChanged)
                    {
                        string formattedAccountFloorDollars = "";

                        formattedAccountFloorDollars = "$" + lastDayOverAccountFloorInfoDollars.ToString("N0");

                        lastDayOverAccountFloorLabelText = "Floor: " + formattedAccountFloorDollars;
                    }
                }

                if (IsDayOverMaxLossEnabled() && dayOverMaxLossHasChanged)
                {
                    lastDayOverMaxLossInfoDollarsChanged = lastDayOverMaxLossInfoDollars != lastDayOverMaxLossDollars;
                    if (lastDayOverMaxLossInfoDollarsChanged) lastDayOverMaxLossInfoDollars = lastDayOverMaxLossDollars;

                    if (lastDayOverMaxLossInfoDollarsChanged)
                    {
                        double tempDayOverMaxLossRemaining = lastDayOverMaxLossDollars;
                        string formattedDailyMaxDollars = "";
                        if (lastDayOverMaxLossDollars > 0)
                        {
                            formattedDailyMaxDollars = "$" + tempDayOverMaxLossRemaining.ToString("N0");
                        }
                        else
                        {
                            formattedDailyMaxDollars = "($" + tempDayOverMaxLossRemaining.ToString("N0") + ")";
                        }

                        //lastDayOverMaxLossLabelText = formattedDailyMaxDollars + " / $" + dayOverMaxLossDollars.ToString("N0");
                        lastDayOverMaxLossLabelText = "MaxLoss: $" + dayOverMaxLossDollars.ToString("N0") + " / " + formattedDailyMaxDollars;
                    }
                }

                if (IsDayOverMaxLossEnabled() && dayOverMaxLossHasChanged && UseDayOverMaxLossTrailing)
                {
                    bool lastDayOverMaxLossAccountPnLPeakInfoDollarsChanged = lastDayOverMaxLossAccountPnLPeakInfoDollars != dayOverMaxAccountPnLPeakDollars;
                    if (lastDayOverMaxLossAccountPnLPeakInfoDollarsChanged) lastDayOverMaxLossAccountPnLPeakInfoDollars = dayOverMaxAccountPnLPeakDollars;

                    if (lastDayOverMaxLossAccountPnLPeakInfoDollarsChanged || lastDayOverMaxAccountPnLPeakLabelText == "")
                    {
                        string formattedAccountPnLPeakDollars = "";

                        formattedAccountPnLPeakDollars = "$" + dayOverMaxAccountPnLPeakDollars.ToString("N0");

                        lastDayOverMaxAccountPnLPeakLabelText = "Peak: " + formattedAccountPnLPeakDollars;
                    }
                }

                if (lastDayOverAccountFloorInfoDollarsChanged || lastDayOverMaxLossInfoDollarsChanged)
                {
                    labelTextBuilder.Clear();
                    
                    if (lastDayOverMaxLossLabelText != "" && lastDayOverAccountFloorLabelText != "" && lastDayOverMaxAccountPnLPeakLabelText != "")
                    {
                        labelTextBuilder.Append(lastDayOverMaxLossLabelText).Append("   ")
                            .Append(lastDayOverMaxAccountPnLPeakLabelText).Append("   ")
                            .Append(lastDayOverAccountFloorLabelText);
                    }
                    else if (lastDayOverMaxLossLabelText != "" && lastDayOverAccountFloorLabelText != "")
                    {
                        labelTextBuilder.Append(lastDayOverMaxLossLabelText).Append("   ").Append(lastDayOverAccountFloorLabelText);
                    }
                    else if (lastDayOverMaxLossLabelText != "" && lastDayOverMaxAccountPnLPeakLabelText != "")
                    {
                        labelTextBuilder.Append(lastDayOverMaxLossLabelText).Append("   ").Append(lastDayOverMaxAccountPnLPeakLabelText);
                    }
                    else if (lastDayOverMaxLossLabelText != "")
                    {
                        labelTextBuilder.Append(lastDayOverMaxLossLabelText);
                    }
                    else if (lastDayOverAccountFloorLabelText != "")
                    {
                        labelTextBuilder.Append(lastDayOverAccountFloorLabelText);
                    }
                    
                    string dayOverMaxLossInfoText = labelTextBuilder.ToString();

                    if (dayOverMaxLossInfoText != dayOverMaxLossInfoTextCache)
                    {
                        dayOverMaxLossInfoTextCache = dayOverMaxLossInfoText;
                        dayOverMaxLossInfoLabel.Text = dayOverMaxLossInfoTextCache;
                        
                        Visibility newVisibility = (string.IsNullOrEmpty(dayOverMaxLossInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible;
                        if (newVisibility != dayOverMaxLossInfoVisibilityCache)
                        {
                            dayOverMaxLossInfoVisibilityCache = newVisibility;
                            dayOverMaxLossInfoLabel.Visibility = dayOverMaxLossInfoVisibilityCache;
                        }
                    }
                }
            }

            dayOverAccountBalanceFloorHasChanged = false;
            dayOverMaxLossHasChanged = false;
            bogeyTargetHasChanged = false;

            if (IsECATPEnabled() && ecaTakeProfitHasChanged)
            {
                if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                {
                    bool lastECATakeProfitDollarsChanged = cacheECATakeProfitDollars != lastECATakeProfitDollars;
                    if (lastECATakeProfitDollarsChanged) lastECATakeProfitDollars = cacheECATakeProfitDollars;

                    bool lastECATakeProfitPositionTypeChanged = ecaTakeProfitMarketPosition != lastECATakeProfitPositionType;
                    bool lastECATakeProfitPositionPriceChanged = ecaTakeProfitPositionPrice != lastECATakeProfitPositionPrice;
                    bool lastECATakeProfitPositionQuantityChanged = ecaTakeProfitPositionQuantity != lastECATakeProfitPositionQuantity;

                    if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                    {
                        if (lastECATakeProfitPositionTypeChanged || lastECATakeProfitDollarsChanged || lastECATakeProfitPositionPriceChanged || lastECATakeProfitPositionQuantityChanged)
                        {
                            lastECATakeProfitPositionType = ecaTakeProfitMarketPosition;
                            lastECATakeProfitPositionPrice = ecaTakeProfitPositionPrice;
                            lastECATakeProfitPositionQuantity = ecaTakeProfitPositionQuantity;

                            double newLinePrice = 0;

                            if (lastECATakeProfitPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetECATakeProfitPriceFromDollars(MarketPosition.Long, lastECATakeProfitPositionPrice, lastECATakeProfitPositionQuantity, lastECATakeProfitDollars);
                            }
                            else if (lastECATakeProfitPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetECATakeProfitPriceFromDollars(MarketPosition.Short, lastECATakeProfitPositionPrice, lastECATakeProfitPositionQuantity, lastECATakeProfitDollars);
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool ecaTakeProfitLinePriceChanged = (newLinePrice != lastECATakeProfitLinePrice);

                                if (ecaTakeProfitLinePriceChanged)
                                {
                                    lastECATakeProfitLinePrice = newLinePrice;



                                    string key = BuildECATakeProfitHLineKey();
                                    DrawHLine(key, lastECATakeProfitLinePrice, ecaTakeProfitLineBrush, ecaTakeProfitLineDashStyle, ecaTakeProfitLineWidth);

                                    ecaTakeProfitLineVisible = true;
                                    ecaTakeProfitLinePriceChanged = false;
                                }
                            }
                        }
                    }
                }
            }

            if (ecaTakeProfitLineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !IsECATPEnabled()))
            {
                lastECATakeProfitPositionType = MarketPosition.Flat;
                lastECATakeProfitLinePrice = 0;
                lastECATakeProfitPositionPrice = 0;
                lastECATakeProfitPositionQuantity = 0;
                removedLine = (RemoveECATakeProfitLine()) ? true : removedLine;

            }

            ecaTakeProfitHasChanged = false;

            if (averagePriceHasChanged)
            {
                if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                {
                    bool lastAveragePricePositionTypeChanged = averagePriceMarketPosition != lastAveragePricePositionType;
                    bool lastAveragePricePositionPriceChanged = averagePricePositionPrice != lastAveragePricePositionPrice;
                    bool lastAveragePricePositionQuantityChanged = averagePricePositionQuantity != lastAveragePricePositionQuantity;

                    if (lastAveragePricePositionTypeChanged || lastAveragePricePositionPriceChanged || lastAveragePricePositionQuantityChanged)
                    {
                        lastAveragePricePositionType = averagePriceMarketPosition;
                        lastAveragePricePositionPrice = averagePricePositionPrice;
                        lastAveragePricePositionQuantity = averagePricePositionQuantity;

                        double newLinePrice = 0;

                        newLinePrice = lastAveragePricePositionPrice;
                        /*
                        if (averagePriceHasPosition && blendedInstrumentHasPosition)
                        {
                            int eminiQuantity = 0;
                            double eminiAveragePrice = 0;
                            int microQuantity = 0;
                            double microAveragePrice = 0;

                            if (IsEminiInstrument(attachedInstrument))
                            {
                                microQuantity = lastBlendedInstrumentPositionQuantity;
                                microAveragePrice = lastBlendedInstrumentPositionPrice;

                                eminiQuantity = lastAveragePricePositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                eminiAveragePrice = lastAveragePricePositionPrice;
                            }
                            else
                            {
                                microQuantity = lastAveragePricePositionQuantity;
                                microAveragePrice = lastAveragePricePositionPrice;

                                eminiQuantity = lastBlendedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                eminiAveragePrice = lastBlendedInstrumentPositionPrice;
                            }

                            int quantitySum = microQuantity + eminiQuantity;
                            double newWeightedAveragePrice = ((microAveragePrice * microQuantity) + (eminiAveragePrice * eminiQuantity)) / quantitySum;

                            newLinePrice = newWeightedAveragePrice;
                        }
                        else if (averagePriceHasPosition && !blendedInstrumentHasPosition)
                        {
                            newLinePrice = lastAveragePricePositionPrice;
                        }
                        else if (!averagePriceHasPosition && blendedInstrumentHasPosition)
                        {
                            newLinePrice = lastBlendedInstrumentPositionPrice;
                        }
                        */
                        bool isLinePriceValid = newLinePrice > 0;

                        if (isLinePriceValid)
                        {
                            bool averagePriceLinePriceChanged = (newLinePrice != lastAveragePriceLinePrice
                                || lastAveragePricePositionPriceChanged || lastAveragePricePositionQuantityChanged);

                            if (averagePriceLinePriceChanged)
                            {
                                lastAveragePriceLinePrice = newLinePrice;

                                string key = BuildAveragePriceHLineKey();



                                /*
                                int mixedInstrumentQuantity = lastAveragePricePositionQuantity;

                                if (attachedInstrumentHasPosition)
                                {
                                    if (attachedIsEMini)
                                    {
                                        blendQuantity += (lastAveragePricePositionQuantity * MICRO_TO_EMINI_MULTIPLIER);
                                    }
                                    else
                                    {
                                        blendQuantity += lastAveragePricePositionQuantity;
                                    }
                                }

                                if (blendedInstrumentHasPosition)
                                {
                                    if (!attachedIsEMini)
                                    {
                                        blendQuantity += (lastBlendedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER);
                                    }
                                    else
                                    {
                                        blendQuantity += lastBlendedInstrumentPositionQuantity;
                                    }
                                }
                                */

                                if (ShowAveragePriceLine && !averagePriceLineIsBrushTransparent)
                                {
                                    string formatter = "N" + RealInstrumentService.GetTickSizeDecimalPlaces(attachedInstrumentTickSize);
                                    string lineText = lastAveragePriceLinePrice.ToString(formatter);

                                    if (ShowAveragePriceLineQuantity)
                                    {
                                        lineText += " (" + lastAveragePricePositionQuantity.ToString("N0") + ")";
                                    }

                                    DrawLabeledHLine(key, lastAveragePriceLinePrice, averagePriceLineBrush, averagePriceLineDashStyle,
                                        averagePriceLineWidth, lineText, averagePriceLevelHorizontalOffset, AveragePriceLineZOrder);

                                    averagePriceLineVisible = true;
                                }

                                averagePriceLinePriceChanged = false;
                            }
                        }
                    }
                }
            }

            if (averagePriceLineVisible && !attachedInstrumentHasPosition && !blendedInstrumentHasPosition)
            {
                lastAveragePricePositionType = MarketPosition.Flat;
                lastAveragePricePositionPrice = 0;
                lastAveragePricePositionQuantity = 0;
                lastAveragePriceLinePrice = 0;

                removedLine = (RemoveAveragePriceLine()) ? true : removedLine;
            }

            averagePriceHasChanged = false;

            if (removedLine && currentBogeyTargetMultiplier != BogeyTargetMultiplierDisabled && nextBogeyTargetMultiplier != BogeyTargetMultiplierDisabled)
            {
                RealLogger.PrintOutput("Attempting Bogey Target button smart jump...");
                bool hasBogeyTargetJumped = AttemptBogeyTargetSmartJump();

                if (hasBogeyTargetJumped)
                {
                    DeactivateAutoEntryFeatures(signalName);
                }
            }
        }

        private double CalculateAutoAddOnMaxDollars(double originalAutoAddOnMaxDollars, double originalStopLossInitialDollars, double originalDayOverMaxLossDollars)
        {
            double newAutoAddOnMaxDollars = 0;
            bool isStopLossInitialDollarsEnabled = originalStopLossInitialDollars > 0;
            bool isAutoAddOnMaxDollarsEnabled = originalAutoAddOnMaxDollars > 0;
            bool isDayOverMaxDollarsEnabled = IsDayOverMaxLossEnabled();

            if (isStopLossInitialDollarsEnabled && isAutoAddOnMaxDollarsEnabled && isDayOverMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = Math.Min(Math.Min(originalStopLossInitialDollars, originalAutoAddOnMaxDollars), originalDayOverMaxLossDollars);
            }
            else if (isStopLossInitialDollarsEnabled && isAutoAddOnMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = Math.Min(originalStopLossInitialDollars, originalAutoAddOnMaxDollars);
            }
            else if (isStopLossInitialDollarsEnabled && isDayOverMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = Math.Min(originalStopLossInitialDollars, originalDayOverMaxLossDollars);
            }
            else if (isAutoAddOnMaxDollarsEnabled && isDayOverMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = Math.Min(originalAutoAddOnMaxDollars, originalDayOverMaxLossDollars);
            }
            else if (isDayOverMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = originalDayOverMaxLossDollars;
            }
            else if (isAutoAddOnMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = originalAutoAddOnMaxDollars;
            }
            else if (isStopLossInitialDollarsEnabled)
            {
                newAutoAddOnMaxDollars = originalStopLossInitialDollars;
            }

            bool isInvalidAutoAddOnMaxDollars = newAutoAddOnMaxDollars <= 0;

            if (isInvalidAutoAddOnMaxDollars) newAutoAddOnMaxDollars = DEFAULT_ADDON_MAX_DOLLARS;

            return newAutoAddOnMaxDollars;
        }

        private void RefreshProfitInfoLabel()
        {
            if (profitInfoLabel != null && profitInfoHasChanged)
            {
                double profitInfoTotalDollars = 0;

                int profitInfoAttachedTicks = 0;
                double profitInfoAttachedDollars = 0;
                
                // Check for actual take profit orders, not just calculated prices
                bool attachedInstrumentHasTakeProfit = false;
                bool blendedInstrumentHasTakeProfit = false;
                double actualAttachedTakeProfitPrice = 0;
                double actualBlendedTakeProfitPrice = 0;
                
                if (attachedInstrumentHasPosition && account != null)
                {
                    OrderType orderType;
                    int orderQuantity;
                    int orderCount;
                    actualAttachedTakeProfitPrice = RealOrderService.GetTakeProfitInfo(account, attachedInstrument, ConvertMarketPositionToTPOrderAction(attachedInstrumentMarketPosition), out orderType, out orderQuantity, out orderCount);
                    attachedInstrumentHasTakeProfit = actualAttachedTakeProfitPrice > 0;
                    
                    if (attachedInstrumentHasTakeProfit)
                    {
                        profitInfoAttachedDollars = Math.Round(GetPositionProfitWithStoLoss(attachedInstrument, attachedInstrumentMarketPosition, attachedInstrumentPositionQuantity, attachedInstrumentPositionPrice, actualAttachedTakeProfitPrice), 2);
                        profitInfoAttachedTicks = (int)Math.Round(((profitInfoAttachedDollars / attachedInstrumentPositionQuantity) / RealInstrumentService.GetTickValue(attachedInstrument)), MidpointRounding.ToEven);
                        profitInfoTotalDollars += profitInfoAttachedDollars;
                    }
                }

                double profitInfoBlendedDollars = 0;
                double profitInfoBlendedTicks = 0;

                if (blendedInstrumentHasPosition && account != null)
                {
                    OrderType orderType;
                    int orderQuantity;
                    int orderCount;
                    actualBlendedTakeProfitPrice = RealOrderService.GetTakeProfitInfo(account, blendedInstrument, ConvertMarketPositionToTPOrderAction(blendedInstrumentMarketPosition), out orderType, out orderQuantity, out orderCount);
                    blendedInstrumentHasTakeProfit = actualBlendedTakeProfitPrice > 0;
                    
                    if (blendedInstrumentHasTakeProfit)
                    {
                        profitInfoBlendedDollars = Math.Round(GetPositionProfitWithStoLoss(blendedInstrument, blendedInstrumentMarketPosition, blendedInstrumentPositionQuantity, blendedInstrumentPositionPrice, actualBlendedTakeProfitPrice), 2);
                        profitInfoBlendedTicks = (int)Math.Round(((profitInfoBlendedDollars / blendedInstrumentPositionQuantity) / RealInstrumentService.GetTickValue(blendedInstrument)), MidpointRounding.ToEven);
                        profitInfoTotalDollars += profitInfoBlendedDollars;
                    }
                }

                if ((attachedInstrumentHasPosition && profitInfoHasChanged) || (blendedInstrumentHasPosition && profitInfoHasChanged))
                {
                    string profitDollarText = "";
                    string profitFullText = "";
                    Brush newForeground;

                    if (attachedInstrumentHasPosition
                        && attachedInstrumentHasTakeProfit
                        && profitInfoAttachedTicks != 0
                        && blendedInstrumentHasPosition
                        && blendedInstrumentHasTakeProfit
                        && profitInfoBlendedTicks != 0)
                    {
                        int profitInfoMaxTicks = (int)Math.Max(profitInfoAttachedTicks, profitInfoBlendedTicks);
                        
                        if (profitInfoTotalDollars >= 0)
                        {
                            newForeground = Brushes.LightGreen;
                            profitDollarText = "$" + profitInfoTotalDollars.ToString("N2");
                        }
                        else
                        {
                            newForeground = Brushes.Tomato;
                            profitDollarText = "-$" + profitInfoTotalDollars.ToString("N2").Replace("-", "");
                        }
                        profitFullText = "TakeProfit: " + profitDollarText + " (" + profitInfoMaxTicks.ToString("N0") + ")";
                    }
                    else if (attachedInstrumentHasPosition
                        && attachedInstrumentHasTakeProfit
                        && profitInfoAttachedTicks != 0
                        && !blendedInstrumentHasPosition
                        && !blendedInstrumentHasTakeProfit
                        && profitInfoBlendedTicks == 0)
                    {
                        if (profitInfoTotalDollars >= 0)
                        {
                            newForeground = Brushes.LightGreen;
                            profitDollarText = "$" + profitInfoTotalDollars.ToString("N2");
                        }
                        else
                        {
                            newForeground = Brushes.Tomato;
                            profitDollarText = "-$" + profitInfoTotalDollars.ToString("N2").Replace("-", "");
                        }
                        profitFullText = "TakeProfit: " + profitDollarText + " (" + profitInfoAttachedTicks.ToString("N0") + ")";
                    }
                    else if (!attachedInstrumentHasPosition
                        && !attachedInstrumentHasTakeProfit
                        && profitInfoAttachedTicks == 0
                        && blendedInstrumentHasPosition
                        && blendedInstrumentHasTakeProfit
                        && profitInfoBlendedTicks != 0)
                    {
                        if (profitInfoTotalDollars >= 0)
                        {
                            newForeground = Brushes.LightGreen;
                            profitDollarText = "$" + profitInfoTotalDollars.ToString("N2");
                        }
                        else
                        {
                            newForeground = Brushes.Tomato;
                            profitDollarText = "-$" + profitInfoTotalDollars.ToString("N2").Replace("-", "");
                        }
                        profitFullText = "TakeProfit: " + profitDollarText + " (" + profitInfoBlendedTicks.ToString("N0") + ")";
                    }
                    else
                    {
                        newForeground = Brushes.White;
                        profitFullText = "TakeProfit: " + "none";
                    }
                    
                    if (newForeground != profitInfoForegroundCache)
                    {
                        profitInfoForegroundCache = newForeground;
                        profitInfoLabel.Foreground = profitInfoForegroundCache;
                    }

                    if (profitFullText != profitInfoTextCache)
                    {
                        profitInfoTextCache = profitFullText;
                        profitInfoLabel.Text = profitInfoTextCache;
                        
                        Visibility newVisibility = (string.IsNullOrEmpty(profitInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible;
                        if (newVisibility != profitInfoVisibilityCache)
                        {
                            profitInfoVisibilityCache = newVisibility;
                            profitInfoLabel.Visibility = profitInfoVisibilityCache;
                        }
                    }
                }
                else
                {
                    string emptyText = "";
                    if (emptyText != profitInfoTextCache)
                    {
                        profitInfoTextCache = emptyText;
                        
                        Brush newForeground = Brushes.White;
                        if (newForeground != profitInfoForegroundCache)
                        {
                            profitInfoForegroundCache = newForeground;
                            profitInfoLabel.Foreground = profitInfoForegroundCache;
                        }
                        
                        profitInfoLabel.Text = profitInfoTextCache;
                        
                        Visibility newVisibility = (string.IsNullOrEmpty(profitInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible;
                        if (newVisibility != profitInfoVisibilityCache)
                        {
                            profitInfoVisibilityCache = newVisibility;
                            profitInfoLabel.Visibility = profitInfoVisibilityCache;
                        }
                    }
                }

                profitInfoHasChanged = false;
            }
        }

        private void RefreshRiskInfoLabel()
        {
            if (riskInfoLabel != null && riskInfoHasChanged)
            {
                double riskInfoTotalDollars = 0;

                int riskInfoAttachedTicks = 0;
                double riskInfoAttachedDollars = 0;
                
                // Check for actual stop loss orders, not just calculated prices
                bool attachedInstrumentHasStopLoss = false;
                bool blendedInstrumentHasStopLoss = false;
                double actualAttachedStopLossPrice = 0;
                double actualBlendedStopLossPrice = 0;
                
                if (attachedInstrumentHasPosition && account != null)
                {
                    OrderType orderType;
                    int orderQuantity;
                    int orderCount;
                    actualAttachedStopLossPrice = RealOrderService.GetStopLossInfo(account, attachedInstrument, ConvertMarketPositionToSLOrderAction(attachedInstrumentMarketPosition), out orderType, out orderQuantity, out orderCount);
                    attachedInstrumentHasStopLoss = actualAttachedStopLossPrice > 0;
                    
                    if (attachedInstrumentHasStopLoss)
                    {
                        riskInfoAttachedDollars = Math.Round(GetPositionProfitWithStoLoss(attachedInstrument, attachedInstrumentMarketPosition, attachedInstrumentPositionQuantity, attachedInstrumentPositionPrice, actualAttachedStopLossPrice), 2);
                        riskInfoAttachedTicks = (int)Math.Round(((riskInfoAttachedDollars / attachedInstrumentPositionQuantity) / RealInstrumentService.GetTickValue(attachedInstrument)), MidpointRounding.ToEven);
                        riskInfoTotalDollars += riskInfoAttachedDollars;
                    }
                }

                double riskInfoBlendedDollars = 0;
                double riskInfoBlendedTicks = 0;

                if (blendedInstrumentHasPosition && account != null)
                {
                    OrderType orderType;
                    int orderQuantity;
                    int orderCount;
                    actualBlendedStopLossPrice = RealOrderService.GetStopLossInfo(account, blendedInstrument, ConvertMarketPositionToSLOrderAction(blendedInstrumentMarketPosition), out orderType, out orderQuantity, out orderCount);
                    blendedInstrumentHasStopLoss = actualBlendedStopLossPrice > 0;
                    
                    if (blendedInstrumentHasStopLoss)
                    {
                        riskInfoBlendedDollars = Math.Round(GetPositionProfitWithStoLoss(blendedInstrument, blendedInstrumentMarketPosition, blendedInstrumentPositionQuantity, blendedInstrumentPositionPrice, actualBlendedStopLossPrice), 2);
                        riskInfoBlendedTicks = (int)Math.Round(((riskInfoBlendedDollars / blendedInstrumentPositionQuantity) / RealInstrumentService.GetTickValue(blendedInstrument)), MidpointRounding.ToEven);
                        riskInfoTotalDollars += riskInfoBlendedDollars;
                    }
                }

                if ((attachedInstrumentHasPosition && riskInfoHasChanged) || (blendedInstrumentHasPosition && riskInfoHasChanged))
                {
                    string riskDollarText = "";
                    string riskFullText = "";
                    Brush newForeground;

                    if (attachedInstrumentHasPosition
                        && attachedInstrumentHasStopLoss
                        && riskInfoAttachedTicks != 0
                        && blendedInstrumentHasPosition
                        && blendedInstrumentHasStopLoss
                        && riskInfoBlendedTicks != 0)
                    {
                        int riskInfoMaxTicks = (int)Math.Max(riskInfoAttachedTicks, riskInfoBlendedTicks);
                        
                        if (riskInfoTotalDollars >= 0)
                        {
                            newForeground = Brushes.LightGreen;
                            riskDollarText = "$" + riskInfoTotalDollars.ToString("N2");
                        }
                        else
                        {
                            newForeground = Brushes.Tomato;
                            riskDollarText = "-$" + riskInfoTotalDollars.ToString("N2").Replace("-", "");
                        }
                        riskFullText = "StopLoss: " + riskDollarText + " (" + riskInfoMaxTicks.ToString("N0") + ")";
                    }
                    else if (attachedInstrumentHasPosition
                        && attachedInstrumentHasStopLoss
                        && riskInfoAttachedTicks != 0
                        && !blendedInstrumentHasPosition
                        && !blendedInstrumentHasStopLoss
                        && riskInfoBlendedTicks == 0)
                    {
                        if (riskInfoTotalDollars >= 0)
                        {
                            newForeground = Brushes.LightGreen;
                            riskDollarText = "$" + riskInfoTotalDollars.ToString("N2");
                        }
                        else
                        {
                            newForeground = Brushes.Tomato;
                            riskDollarText = "-$" + riskInfoTotalDollars.ToString("N2").Replace("-", "");
                        }
                        riskFullText = "StopLoss: " + riskDollarText + " (" + riskInfoAttachedTicks.ToString("N0") + ")";
                    }
                    else if (!attachedInstrumentHasPosition
                        && !attachedInstrumentHasStopLoss
                        && riskInfoAttachedTicks == 0
                        && blendedInstrumentHasPosition
                        && blendedInstrumentHasStopLoss
                        && riskInfoBlendedTicks != 0)
                    {
                        if (riskInfoTotalDollars >= 0)
                        {
                            newForeground = Brushes.LightGreen;
                            riskDollarText = "$" + riskInfoTotalDollars.ToString("N2");
                        }
                        else
                        {
                            newForeground = Brushes.Tomato;
                            riskDollarText = "-$" + riskInfoTotalDollars.ToString("N2").Replace("-", "");
                        }
                        riskFullText = "StopLoss: " + riskDollarText + " (" + riskInfoBlendedTicks.ToString("N0") + ")";
                    }
                    else
                    {
                        newForeground = Brushes.White;
                        riskFullText = "StopLoss: " + "none";
                    }
                    
                    if (newForeground != riskInfoForegroundCache)
                    {
                        riskInfoForegroundCache = newForeground;
                        riskInfoLabel.Foreground = riskInfoForegroundCache;
                    }

                    if (riskFullText != riskInfoTextCache)
                    {
                        riskInfoTextCache = riskFullText;
                        riskInfoLabel.Text = riskInfoTextCache;
                        
                        Visibility newVisibility = (string.IsNullOrEmpty(riskInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible;
                        if (newVisibility != riskInfoVisibilityCache)
                        {
                            riskInfoVisibilityCache = newVisibility;
                            riskInfoLabel.Visibility = riskInfoVisibilityCache;
                        }
                    }
                }
                else
                {
                    string emptyText = "";
                    if (emptyText != riskInfoTextCache)
                    {
                        riskInfoTextCache = emptyText;
                        
                        Brush newForeground = Brushes.White;
                        if (newForeground != riskInfoForegroundCache)
                        {
                            riskInfoForegroundCache = newForeground;
                            riskInfoLabel.Foreground = riskInfoForegroundCache;
                        }
                        
                        riskInfoLabel.Text = riskInfoTextCache;
                        
                        Visibility newVisibility = (string.IsNullOrEmpty(riskInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible;
                        if (newVisibility != riskInfoVisibilityCache)
                        {
                            riskInfoVisibilityCache = newVisibility;
                            riskInfoLabel.Visibility = riskInfoVisibilityCache;
                        }
                    }
                }

                riskInfoHasChanged = false;
            }
        }

        private bool NoOpenPositionsOnAnyAccount()
        {
            // Throttle: don't run faster than once per second, return cached result
            TimeSpan timeSinceLastCheck = DateTime.Now - lastNoOpenPositionsCheckTime;
            if (timeSinceLastCheck.TotalSeconds < 1.0)
            {
                return cachedNoOpenPositionsResult;
            }

            // Update timestamp
            lastNoOpenPositionsCheckTime = DateTime.Now;

            // First check tracked horde positions (faster, no API call needed)
            if (UseHordeTradeCopier && hasFollowerAccounts)
            {
                lock (hordeAccountPositions)
                {
                    if (totalHordePositionCount > 0)
                    {
                        cachedNoOpenPositionsResult = false;
                        return false;
                    }
                }
            }

            // Snapshot Account.All first  prevents collection-modified exceptions
            foreach (Account acc in Account.All.ToArray())
            {
                // Snapshot Positions  safe even if a fill happens mid-check
                if (acc.Positions.ToArray().Length > 0)
                {
                    cachedNoOpenPositionsResult = false;
                    return false;
                }
            }
            
            cachedNoOpenPositionsResult = true;
            return true;
        }

        /// <summary>
        /// Returns true if there are any open positions in follower accounts based on tracked fills
        /// </summary>
        private bool HasOpenHordePositions()
        {
            lock (hordeAccountPositions)
            {
                return totalHordePositionCount > 0;
            }
        }


        private void RefreshHordeTradeCopierInfoLabel()
        {
            if (hordeTradeCopierInfoLabel != null && hordeTradeCopierHasChanged)
            {
                string tempInfoText = string.Empty;
                bool activePositions = false;

                if (UseHordeTradeCopier && hasFollowerAccounts)
                {
                    if (HasOpenHordePositions())
                    {
                        tempInfoText = " Horde Trade Copier: Active ";
                        activePositions = true;
                    }
                    else
                    {
                        tempInfoText = " Horde Trade Copier: On ";
                    }
                }
                else
                {
                    tempInfoText  = string.Empty;
                }


                if (tempInfoText != hordeTradeCopierInfoTextCache)
                {
                    hordeTradeCopierInfoTextCache = tempInfoText;
                    hordeTradeCopierInfoLabel.Text = hordeTradeCopierInfoTextCache;
                    
                    Visibility newVisibility = (string.IsNullOrEmpty(hordeTradeCopierInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible;
                    if (newVisibility != hordeTradeCopierInfoVisibilityCache)
                    {
                        hordeTradeCopierInfoVisibilityCache = newVisibility;
                        hordeTradeCopierInfoLabel.Visibility = hordeTradeCopierInfoVisibilityCache;
                    }
                    
                    Brush newForeground = (activePositions) ? Brushes.DeepSkyBlue : Brushes.Silver;
                    if (newForeground != hordeTradeCopierForegroundCache)
                    {
                        hordeTradeCopierForegroundCache = newForeground;
                        hordeTradeCopierInfoLabel.Foreground = hordeTradeCopierForegroundCache;
                    }
                }

                hordeTradeCopierHasChanged = false;
            }
        }


        private void OnButtonClick(object sender, RoutedEventArgs re)
        {
            System.Windows.Controls.Button button = sender as System.Windows.Controls.Button;

                if (button == revButton && button.Name == HHRevButtonName)
                {
                    ReverseButtonAction("ReverseButtonClick");
                }
                else if (button == closeAllButton && button.Name == HHCloseAllButtonName)
                {
                    FlattenEverythingButtonAction("FlattenEverythingButtonClick");
                }
                else if (button == toggleAutoCloseButton && button.Name == HHToggleAutoCloseButtonName)
                {
                    ToggleAutoCloseButtonAction("AutoCloseButtonClick", button);
                }
                else if (button == toggleEntryVolumeAutoButton && button.Name == HHToggleEntryVolumeAutoButtonName)
                {
                    ToggleEntryVolumeAutoButtonAction("VolumeButtonClick", button);
                }
                else if (button == toggleEntryVolumeMaxButton && button.Name == HHToggleEntryVolumeMaxButtonName)
                {
                    ToggleEntryVolumeMaxButtonAction("VolumeMaxButtonClick", button);
                }
                else if (button == toggleAutoPilotProfileButton && button.Name == HHToggleAutoPilotProfileButtonName)
                {
                    ToggleAutoPilotProfileButtonAction("AutoPilotProfileButtonClick", button);
                }
                else if (button == toggleAutoPilotButton && button.Name == HHToggleAutoPilotButtonName)
                {
                    ToggleAutoPilotButtonAction("AutoPilotButtonClick", button);
                }
                else if (button == toggleTradeSignalButton && button.Name == HHToggleTradeSignalButtonName)
                {
                    ToggleTradeSignalButtonAction("TradeSignalButtonClick", button);
                }
                else if (button == toggleAutoAddOnButton && button.Name == HHToggleAutoAddOnButtonName)
                {
                    ToggleAutoAddOnButtonAction("AutoAddOnButtonClick", button);
                }
                else if (button == toggleProfitTargetButton && button.Name == HHToggleProfitTargetButtonName)
                {
                    ToggleProfitTargetButtonAction("ProfitTargetButtonClick", button);
                }
                else if (button == toggleAutoBEButton && button.Name == HHToggleAutoBEButtonName)
                {
                    ToggleAutoBEButtonAction("AutoBreak-EvenButtonClick", button);
                }
                else if (button == TPButton && button.Name == HHTPButtonName)
                {
                    TPButtonAction("TP+ButtonClick");
                }
                else if (button == BEButton && button.Name == HHBEButtonName)
                {
                    BEButtonAction("BE+ButtonClick");
                }
                else if (button == SLButton && button.Name == HHSLButtonName)
                {
                    SLButtonAction("SL+ButtonClick");
                }
                else if (button == BuyMarketButton && button.Name == HHBuyMarketButtonName)
                {
                    BuyMarketButtonAction("BuyMarketButtonClick");
                }
                else if (button == SellMarketButton && button.Name == HHSellMarketButtonName)
                {
                    SellMarketButtonAction("SellMarketButtonClick");
                }
                else if (button == BuyPopButton && button.Name == HHBuyPopButtonName)
                {
                    BuyPopButtonAction("Pop+ButtonClick", button);
                }
                else if (button == SellPopButton && button.Name == HHSellPopButtonName)
                {
                    SellPopButtonAction("Pop-ButtonClick", button);
                }
                else if (button == BuyDropButton && button.Name == HHBuyDropButtonName)
                {
                    BuyDropButtonAction("Drop+ButtonClick");
                }
                else if (button == SellDropButton && button.Name == HHSellDropButtonName)
                {
                    SellDropButtonAction("Drop-ButtonClick");
                }
        }

        private void ReverseButtonAction(string signalName)
        {
            RealLogger.PrintOutput("Reverse action via " + signalName);

            /*
            string messageTitle = CloseAlertMessageTitle;
            
            ExitCloseAlertWindows();

            ChartControl.Dispatcher.InvokeAsync(new Action(() =>
            {
                MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), "test", messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, true);

                if (result == MessageBoxResult.Yes)
                {
                    RealLogger.PrintOutput("AutoClose close alert prompt accepted ");

                    
                }
                else
                {
                    RealLogger.PrintOutput("AutoClose close alert prompt declined ");
                }
            }));
            
            */

            //CreatePositionStopLoss(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, 1, 3824);

            bool positionFound = HandleReverse(signalName);

            if (!positionFound)
            {
                if (IsBlendedInstrumentEnabled())
                {
                    RealLogger.PrintOutput("Reverse Error: No position found for " + attachedInstrument.FullName.ToString() + " or " + blendedInstrument.FullName.ToString());
                }
                else
                {
                    RealLogger.PrintOutput("Reverse Error: No position found for " + attachedInstrument.FullName.ToString());
                }
            }
        }

        private void FlattenEverythingButtonAction(string signalName)
        {
            RealLogger.PrintOutput("Close action via " + signalName);

            Instrument closeAttachedInstrument = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? null : attachedInstrument;
            Instrument closeBlendedInstrument = null;

            if (IsBlendedInstrumentEnabled())
            {
                if (closeAttachedInstrument != null)
                {
                    closeBlendedInstrument = blendedInstrument;
                }
                else
                {
                    closeBlendedInstrument = blendedInstrument;
                }
            }

            bool attachedPositionFound = FlattenEverything(signalName, true, closeAttachedInstrument);
            bool blendedPositionFound = FlattenEverything(signalName, true, closeBlendedInstrument);

            DeactivatePopDelayedEntryFeatures(signalName);
            CancelPopDropOrders(signalName);

            if (!attachedPositionFound && !blendedPositionFound)
            {
                RealLogger.PrintOutput("Close Error: No position found for " + attachedInstrument.FullName.ToString());
            }
        }

        private void TPButtonAction(string signalName)
        {
            RealLogger.PrintOutput("TP+ action via " + signalName);

            bool isSHIFTKeyDown = KeyboardManager.IsShiftKeyDown();

            if (isSHIFTKeyDown)
            {
                if (!bypassAutoPositionTakeProfit)
                {
                    CancelPositionAllTakeProfitOrders("TP+ Click");

                    RealLogger.PrintOutput("Activated: Bypass auto position take profit");
                    bypassAutoPositionTakeProfit = true;
                }
                else
                {
                    RealLogger.PrintOutput("Deactivated: Bypass auto position take profit");
                    bypassAutoPositionTakeProfit = false;
                }
            }
            else
            {
                bool positionFound = HandleTakeProfitPlus(signalName);

                if (!positionFound)
                {
                    RealLogger.PrintOutput("TP+ Error: No position found for " + attachedInstrument.FullName.ToString());
                }
            }
        }

        private void BEButtonAction(string signalName)
        {
            RealLogger.PrintOutput("BE+ action via " + signalName);

            bool positionFound = HandleBreakEvenPlus(signalName);

            if (!positionFound)
            {
                RealLogger.PrintOutput("BE+ Error: No position found for " + attachedInstrument.FullName.ToString());
            }
        }

        private void SLButtonAction(string signalName)
        {
            RealLogger.PrintOutput("SL+ action via " + signalName);

            bool positionFound = HandleStopLossPlus(signalName);

            if (!positionFound)
            {
                RealLogger.PrintOutput("SL+ Error: No position found for " + attachedInstrument.FullName.ToString());
            }
        }

        private void BuyMarketButtonAction(string signalName)
        {
            RealLogger.PrintOutput("Buy Market action via " + signalName);

            HandleBuyMarket(signalName);
        }

        private void SellMarketButtonAction(string signalName)
        {
            RealLogger.PrintOutput("Sell Market action via " + signalName);

            HandleSellMarket(signalName);
        }

        private void ToggleTradeSignalButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Trade Signal action via " + signalName);

            if (KeyboardManager.IsCtrlKeyDown())
            {
                DisableTradeSignalButton(0);
            }
            else
            {
                string buttonContent = button.Content.ToString();

                if (currentTradeSignalStatus != TickHunterTradeSignalTypes.Disabled && nextTradeSignalStatus == TickHunterTradeSignalTypes.Disabled)
                {
                    currentTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
                    DisableTradeSignalButton(0);
                }
                else if (buttonContent == ToggleTradeSignalButtonDisabledText)
                {
                    SetTradeSignalButton(button, ToggleTradeSignalBSAButtonEnabledText, ToggleTradeSignalBSAButtonEnabledTextToolTip,
                        TickHunterTradeSignalTypes.BuySellAll, TradeSignalColorDelaySeconds, Brushes.DimGray);
                }
                else if (buttonContent == ToggleTradeSignalBSAButtonEnabledText)
                {
                    SetTradeSignalButton(button, ToggleTradeSignalBSFButtonEnabledText, ToggleTradeSignalBSFButtonEnabledTextToolTip,
                        TickHunterTradeSignalTypes.BuySellFiltered, TradeSignalColorDelaySeconds, Brushes.DimGray);
                }
                else if (buttonContent == ToggleTradeSignalBSFButtonEnabledText)
                {
                    SetTradeSignalButton(button, ToggleTradeSignalBOButtonEnabledText, ToggleTradeSignalBOButtonEnabledTextToolTip,
                        TickHunterTradeSignalTypes.BuyOnly, TradeSignalColorDelaySeconds, Brushes.DimGray);
                }
                else if (buttonContent == ToggleTradeSignalBOButtonEnabledText)
                {
                    SetTradeSignalButton(button, ToggleTradeSignalSOButtonEnabledText, ToggleTradeSignalSOButtonEnabledTextToolTip,
                        TickHunterTradeSignalTypes.SellOnly, TradeSignalColorDelaySeconds, Brushes.DimGray);
                }
                else
                {
                    DisableTradeSignalButton(TradeSignalColorDelaySeconds);
                }
            }
        }

        private void ToggleAutoAddOnButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Auto AddOn action via " + signalName);

            if (KeyboardManager.IsCtrlKeyDown())
            {
                DisableAutoAddOnButton(0);
            }
            else
            {
                string buttonContent = button.Content.ToString();

                if (currentAutoAddOnStatus != TickHunterAutoAddOnTypes.Disabled && nextAutoAddOnStatus == TickHunterAutoAddOnTypes.Disabled)
                {
                    currentAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
                    DisableAutoAddOnButton(0);
                }
                else if (buttonContent == ToggleAutoAddOnButtonDisabledText)
                {
                    SetAutoAddOnButton(button, ToggleAutoAddOnButtonEnabledText, string.Format(ToggleAutoAddOnButtonEnabledToolTip, autoAddOnMaxDollars.ToString("N0")),
                        TickHunterAutoAddOnTypes.Enabled, AutoAddOnColorDelaySeconds, Brushes.DimGray);
                }
                else
                {
                    DisableAutoAddOnButton(AutoAddOnColorDelaySeconds);
                }
            }
        }

        private void ToggleProfitTargetButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Profit Target action via " + signalName);

            bool isCTRLKeyDown = KeyboardManager.IsCtrlKeyDown();
            bool isSHIFTKeyDown = KeyboardManager.IsShiftKeyDown();

            if (isCTRLKeyDown && !isSHIFTKeyDown)
            {
                DisableProfitTargetButton(0);
            }
            else if (isSHIFTKeyDown && !isCTRLKeyDown)
            {
                if (bogeyTargetStartWithFullPnLFlag)
                {
                    bogeyTargetStartWithFullPnLFlag = false;
                }
                else
                {
                    bogeyTargetStartWithFullPnLFlag = true;
                }

                string buttonText = "";
                string buttonToolTip = "";
                GetBogeyTargetTypeButtonText(lastToggleEntryBogeyTargetMultiplier, out buttonText, out buttonToolTip);

                SetProfitTargetButton(button, buttonText, buttonToolTip,
                   TickHunterProfitTargetTypes.BogeyTarget, lastToggleEntryBogeyTargetMultiplier, 0, Brushes.DimGray);
            }
            else
            {
                if (lastToggleProfitTargetStatus == TickHunterProfitTargetTypes.Disabled)
                {
                    lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.EquityCloseAllTarget;

                    string buttonText = ToggleProfitTargetECAButtonEnabledText;
                    string buttonToolTip = ToggleProfitTargetECAButtonEnabledToolTip;

                    SetProfitTargetButton(button, buttonText, buttonToolTip,
                        TickHunterProfitTargetTypes.EquityCloseAllTarget, BogeyTargetMultiplierDisabled, BogeyTargetColorDelaySeconds, Brushes.DimGray);
                }
                else
                {
                    lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.BogeyTarget;

                    bool hasBogeyTargetSmartJumped = AttemptBogeyTargetSmartJump();

                    if (!hasBogeyTargetSmartJumped)
                    {
                        if (lastToggleEntryBogeyTargetMultiplier >= BogeyTargetMultiplierDisabled)
                        {
                            if (isCTRLKeyDown && isSHIFTKeyDown)
                                lastToggleEntryBogeyTargetMultiplier += 10;
                            else
                                lastToggleEntryBogeyTargetMultiplier++;

                            int nextMultiplier = lastToggleEntryBogeyTargetMultiplier;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBogeyTargetTypeButtonText(nextMultiplier, out buttonText, out buttonToolTip);

                            SetProfitTargetButton(button, buttonText, buttonToolTip,
                               TickHunterProfitTargetTypes.BogeyTarget, nextMultiplier, BogeyTargetColorDelaySeconds, Brushes.DimGray);
                        }
                        else
                        {
                            DisableProfitTargetButton(BogeyTargetColorDelaySeconds);
                        }
                    }
                }
            }
        }

        private void ToggleAutoCloseButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Auto Close action via " + signalName);

            if (KeyboardManager.IsCtrlKeyDown())
            {
                DisableAutoCloseButton(0);
            }
            else if (KeyboardManager.IsShiftKeyDown())
            {
                if (closeAutoMinProfitFlag)
                {
                    closeAutoMinProfitFlag = false;
                }
                else
                {
                    closeAutoMinProfitFlag = true;
                }

                string buttonText = "";
                string buttonToolTip = "";
                GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                SetAutoCloseButton(button, buttonText, buttonToolTip,
                    lastToggleEntryCloseAutoStatus, 0, Brushes.DimGray);
            }
            else
            {
                string buttonContent = button.Content.ToString();


                if (lastToggleEntryCloseAutoStatus != TickHunterCloseAutoTypes.Disabled
                    && currentCloseAutoStatus != TickHunterCloseAutoTypes.Disabled
                    && nextCloseAutoStatus == TickHunterCloseAutoTypes.Disabled)
                {
                    currentCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
                    DisableAutoCloseButton(0);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.Disabled)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.ZombieFlip;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.ZLineDualFlip;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.KLineDualFlip;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.KZFlip;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.CreeperFlip;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.ZombieStackedFlip;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.ZombieStackedFlip)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.ZombieBoostedFlip;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.MovingAverage1Slope;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.MovingAverage2Slope;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.MovingAverage3Slope;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.MovingAverage4Break;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage4Break)
                {
                    lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.DriftLine4Break;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoCloseButton(button, buttonText, buttonToolTip,
                        lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                }
                else
                {
                    DisableAutoCloseButton(CloseAutoColorDelaySeconds);
                }
            }
        }

        private void ToggleEntryVolumeAutoButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Volume action via " + signalName);

            if (KeyboardManager.IsCtrlKeyDown() || !IsTickHunterActivated())
            {
                if (!IsTickHunterActivated())
                {
                    ActivateTickHunter(signalName);
                }
                else
                {
                    DeactivateTickHunter(signalName);
                }
            }
            else
            {
                if (lastToggleEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option1)
                {
                    lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option2;
                    button.Content = ToggleAutoEntryVolOption2ButtonEnabledText;
                    button.ToolTip = ToggleAutoEntryVolOption2ButtonEnabledToolTip;
                    currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option2;
                    nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option2;
                    lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                }
                else if (lastToggleEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option2)
                {
                    lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option3;
                    button.Content = ToggleAutoEntryVolOption3ButtonEnabledText;
                    button.ToolTip = ToggleAutoEntryVolOption3ButtonEnabledToolTip;
                    currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option3;
                    nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option3;
                    lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                }
                else if (lastToggleEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option3)
                {
                    lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option4;
                    button.Content = ToggleAutoEntryVolOption4ButtonEnabledText;
                    button.ToolTip = ToggleAutoEntryVolOption4ButtonEnabledToolTip;
                    currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option4;
                    nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option4;
                    lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                }
                else if (lastToggleEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option4)
                {
                    lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option5;
                    button.Content = ToggleAutoEntryVolOption5ButtonEnabledText;
                    button.ToolTip = ToggleAutoEntryVolOption5ButtonEnabledToolTip;
                    currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option5;
                    nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option5;
                    lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                }
                else
                {
                    lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
                    button.Content = ToggleAutoEntryVolOption1ButtonEnabledText;
                    button.ToolTip = ToggleAutoEntryVolOption1ButtonEnabledToolTip;
                    currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
                    nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
                    lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                }
            }
        }

        private void ToggleEntryVolumeMaxButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Volume max action via " + signalName);

            if (KeyboardManager.IsCtrlKeyDown())
            {
                lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                button.Content = ToggleEntryVolMaxOption1ButtonEnabledText;
                button.ToolTip = ToggleEntryVolMaxOption1ButtonEnabledToolTip;
                currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                lastEntryVolumeMaxChangeTime = GetDateTimeNow();
            }
            else
            {
                if (lastToggleEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option1)
                {
                    lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option2;
                    button.Content = ToggleEntryVolMaxOption2ButtonEnabledText;
                    button.ToolTip = ToggleEntryVolMaxOption2ButtonEnabledToolTip;
                    currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option2;
                    nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option2;
                    lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                }
                else if (lastToggleEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option2)
                {
                    lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option3;
                    button.Content = ToggleEntryVolMaxOption3ButtonEnabledText;
                    button.ToolTip = ToggleEntryVolMaxOption3ButtonEnabledToolTip;
                    currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option3;
                    nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option3;
                    lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                }
                else if (lastToggleEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option3)
                {
                    lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option4;
                    button.Content = ToggleEntryVolMaxOption4ButtonEnabledText;
                    button.ToolTip = ToggleEntryVolMaxOption4ButtonEnabledToolTip;
                    currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option4;
                    nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option4;
                    lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                }
                else if (lastToggleEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option4)
                {
                    lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option5;
                    button.Content = ToggleEntryVolMaxOption5ButtonEnabledText;
                    button.ToolTip = ToggleEntryVolMaxOption5ButtonEnabledToolTip;
                    currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option5;
                    nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option5;
                    lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                }
                else
                {
                    lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                    button.Content = ToggleEntryVolMaxOption1ButtonEnabledText;
                    button.ToolTip = ToggleEntryVolMaxOption1ButtonEnabledToolTip;
                    currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                    nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                    lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                }
            }
        }

        private void ToggleAutoPilotButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("AutoPilot action via " + signalName);

            if (KeyboardManager.IsCtrlKeyDown())
            {
                if (UseAutoPilotLite) { DisableAutoPilotLiteButton(0); } else { DisableAutoPilotButton(0); }
            }
            else if (KeyboardManager.IsShiftKeyDown())
            {
                if (useAutoPilotAddOnFlag)
                {
                    useAutoPilotAddOnFlag = false;
                }
                else
                {
                    useAutoPilotAddOnFlag = true;
                }

                if (UseAutoPilotLite)
                {
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                    SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotLiteStatus, 0, Brushes.DimGray);
                }
                else
                {
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                    SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, 0, Brushes.DimGray);
                }
            }
            else
            {
                if (UseAutoPilotLite)
                {
                    string buttonContent = button.Content.ToString();

                    if (lastToggleEntryAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.Disabled
                        && currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.Disabled
                        && nextAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.Disabled)
                    {
                        lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
                        currentAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
                        DisableAutoPilotLiteButton(0);
                    }
                    else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.Disabled)
                    {
                        lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.AlertSetup;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup)
                    {
                        lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.NextSetup;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup)
                    {
                        lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.NextFilteredSetup;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
                    {
                        lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.BuySetup;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup)
                    {
                        lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.SellSetup;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                    }
                    else
                    {
                        lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
                        DisableAutoPilotLiteButton(AutoPilotLiteColorDelaySeconds);
                    }
                }
                else
                {
                    string buttonContent = button.Content.ToString();

                    if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.Disabled)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount1;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount1)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount2;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount2)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount3;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount3)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount4;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount4)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount5;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount5)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount6;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount6)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount7;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount7)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount8;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount8)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount9;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                           lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount9)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount10;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount10)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount11;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount11)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount12;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount12)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount13;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount13)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount14;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount14)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount15;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount15)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount16;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount16)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount17;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount17)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount18;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount18)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount19;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    else //if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount19)
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount20;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotButton(button, buttonText, buttonToolTip,
                            lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                    }
                    /*
                    else
                    {
                        lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
                        DisableAutoPilotButton(AutoPilotColorDelaySeconds);
                    }
                    */
                }
            }
        }

        private void ToggleAutoPilotProfileButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("AutoPilot Profile action via " + signalName);

            if (KeyboardManager.IsCtrlKeyDown())
            {
                DisableAutoPilotProfileButton(0);
            }
            else if (KeyboardManager.IsShiftKeyDown())
            {
                if (autoPilotProfileAutoAdjustFlag)
                {
                    autoPilotProfileAutoAdjustFlag = false;
                }
                else
                {
                    autoPilotProfileAutoAdjustFlag = false; //not supported at this time
                }

                string buttonText = "";
                string buttonToolTip = "";
                GetAutoPilotProfileButtonText(lastToggleAutoPilotProfileStatus, out buttonText, out buttonToolTip);

                SetAutoPilotProfileButton(button, buttonText, buttonToolTip,
                    lastToggleAutoPilotProfileStatus, 0, Brushes.DimGray);
            }
            else
            {
                string buttonContent = button.Content.ToString();

                /*if (lastToggleAutoPilotProfileStatus != TickHunterAutoPilotProfileTypes.Disabled
                    && currentAutoPilotProfileStatus != TickHunterAutoPilotProfileTypes.Disabled
                    && nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Disabled)
                {
                    currentAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
                    DisableAutoPilotProfileButton(0);
                }
                else*/
                if (lastToggleAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Disabled)
                {
                    lastToggleAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Peppy;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoPilotProfileButtonText(lastToggleAutoPilotProfileStatus, out buttonText, out buttonToolTip);

                    SetAutoPilotProfileButton(button, buttonText, buttonToolTip,
                        lastToggleAutoPilotProfileStatus, AutoPilotProfileColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy)
                {
                    lastToggleAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Sleepy;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetAutoPilotProfileButtonText(lastToggleAutoPilotProfileStatus, out buttonText, out buttonToolTip);

                    SetAutoPilotProfileButton(button, buttonText, buttonToolTip,
                        lastToggleAutoPilotProfileStatus, AutoPilotProfileColorDelaySeconds, Brushes.DimGray);
                }
                else
                {
                    DisableAutoPilotProfileButton(AutoPilotProfileColorDelaySeconds);
                }
            }
        }

        string previousVolumeButtonText = "";
        string previousVolumeButtonToolTipText = "";

        private void ActivateTickHunter(string signalName)
        {
            isTickHunterActivated = true;
            SetButtonPanelVisiblity();
            if (toggleEntryVolumeAutoButton != null && ShowButtonVolume)
            {
                toggleEntryVolumeAutoButton.Content = previousVolumeButtonText;
                toggleEntryVolumeAutoButton.ToolTip = previousVolumeButtonToolTipText;
            }

            RealLogger.PrintOutput("Activated " + FullSystemName + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ") via " + signalName, PrintTo.OutputTab1);
            RealLogger.PrintOutput("Activated " + FullSystemName + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ") via " + signalName, PrintTo.OutputTab2);
            
            // Check for existing positions and create TPSL orders if they don't exist and auto TPSL is enabled
            // Use isInitialLoad=true to bypass delay on activation
            if (account != null && account.ConnectionStatus == ConnectionStatus.Connected && RealOrderService.AreAllOrderUpdateCyclesComplete())
            {
                HandleTPSLRefresh(signalName, true);
            }
        }

        private void DeactivateTickHunter(string signalName)
        {
            isTickHunterActivated = false;
            activeDayOverMaxLossAutoClose = false;

            DeactivatePopDelayedEntryFeatures(signalName);
            if (UseAutoPilotLite) { DisableAutoPilotLiteButton(0); } else { DisableAutoPilotButton(0); }
            
            SetButtonPanelHidden();
            if (toggleEntryVolumeAutoButton != null && ShowButtonVolume)
            {
                toggleEntryVolumeAutoButton.Visibility = Visibility.Visible;
                previousVolumeButtonText = (string)toggleEntryVolumeAutoButton.Content;
                previousVolumeButtonToolTipText = (string)toggleEntryVolumeAutoButton.ToolTip;

                toggleEntryVolumeAutoButton.Content = "Start";
                toggleEntryVolumeAutoButton.ToolTip = "Click to Activate " + SystemName;
            }

            RealLogger.PrintOutput("Deactivated " + FullSystemName + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ") via " + signalName, PrintTo.OutputTab1);
            RealLogger.PrintOutput("Deactivated " + FullSystemName + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ") via " + signalName, PrintTo.OutputTab2);
        }

        private void ActivateBuyPopButton(string signalName)
        {
            bool passedMaxCountCheck = ((int)lastToggleBuyPopDelayedStatus < popDelayedEntryMaxCountFlag);

            if (passedMaxCountCheck)
            {
                string buttonText = "";
                string buttonToolTip = "";

                if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                {
                    PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();
                    useBuyPopActivateFlag = true;

                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else
                {
                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount5;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }

                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, lastToggleBuyPopDelayedStatus, PopActivateColorDelaySeconds, Brushes.HotPink);

                currentBuyPopDelayedStatus = lastToggleBuyPopDelayedStatus;
                lastBuyPopDelayedChangeTime = GetDateTimeNow(); // no delay

                RealLogger.PrintOutput("Activated pop+ buy stop delayed entry (EntryQueueLength=" + (int)currentBuyPopDelayedStatus + " / LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")  via " + signalName);
            }
            else
            {
                RealLogger.PrintOutput("BLOCKED pop+ buy stop delayed entry increment due to CurrentPopDelayedEntryCount=" + ((int)lastToggleBuyPopDelayedStatus).ToString("N0") + " while PopDelayedEntryMaxCount=" + popDelayedEntryMaxCountFlag.ToString("N0") + " via " + signalName);
            }
        }

        private void ActivateSellPopButton(string signalName)
        {
            bool passedMaxCountCheck = ((int)lastToggleSellPopDelayedStatus < popDelayedEntryMaxCountFlag);

            if (passedMaxCountCheck)
            {
                string buttonText = "";
                string buttonToolTip = "";

                if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                {
                    PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();
                    useSellPopActivateFlag = true;

                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else
                {
                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount5;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }

                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, lastToggleSellPopDelayedStatus, PopActivateColorDelaySeconds, Brushes.HotPink);

                currentSellPopDelayedStatus = lastToggleSellPopDelayedStatus;
                lastSellPopDelayedChangeTime = GetDateTimeNow(); // no delay

                RealLogger.PrintOutput("Activated pop- sell stop delayed entry (EntryQueueLength=" + (int)currentSellPopDelayedStatus + " / LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")");
            }
            else
            {
                RealLogger.PrintOutput("BLOCKED pop- sell stop delayed entry increment due to CurrentPopDelayedEntryCount=" + ((int)lastToggleSellPopDelayedStatus).ToString("N0") + " while PopDelayedEntryMaxCount=" + popDelayedEntryMaxCountFlag.ToString("N0") + " via " + signalName);
            }
        }

        private void DeactivateBuyPopButton(string signalName)
        {
            RealLogger.PrintOutput("Deactivated pop+ buy stop delayed entry via " + signalName);

            useBuyPopActivateFlag = false;

            if (BuyPopButton != null)
            {
                string buttonText = "";
                string buttonToolTip = "";

                lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;

                GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);

                Brush popBgColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;
                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, lastToggleBuyPopDelayedStatus, 0, popBgColor);

                currentBuyPopDelayedStatus = lastToggleBuyPopDelayedStatus;
                lastBuyPopDelayedChangeTime = GetDateTimeNow(); // no delay
            }
        }

        private void DeactivateSellPopButton(string signalName)
        {
            RealLogger.PrintOutput("Deactivated pop- sell stop delayed entry via " + signalName);
            useSellPopActivateFlag = false;

            if (SellPopButton != null)
            {
                string buttonText = "";
                string buttonToolTip = "";

                lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;

                GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);

                Brush popBgColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;
                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, lastToggleSellPopDelayedStatus, 0, popBgColor);

                currentSellPopDelayedStatus = lastToggleSellPopDelayedStatus;
                lastSellPopDelayedChangeTime = GetDateTimeNow(); // no delay
            }
        }

        private void DisableTradeSignalButton(int delaySeconds)
        {
            lastToggleEntryTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
            SetTradeSignalButton(toggleTradeSignalButton, ToggleTradeSignalButtonDisabledText, ToggleTradeSignalButtonDisabledToolTip,
                lastToggleEntryTradeSignalStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoCloseButton(int delaySeconds)
        {
            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
            SetAutoCloseButton(toggleAutoCloseButton, ToggleAutoCloseButtonDisabledText, ToggleAutoCloseButtonDisabledToolTip,
                lastToggleEntryCloseAutoStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoBEButton(int delaySeconds)
        {
            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
            SetAutoBEButton(toggleAutoBEButton, ToggleAutoBEButtonDisabledText, ToggleAutoBEButtonDisabledToolTip,
                lastToggleEntryBreakEvenAutoStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableProfitTargetButton(int delaySeconds)
        {
            lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
            SetProfitTargetButton(toggleProfitTargetButton, ToggleProfitTargetButtonDisabledText, ToggleProfitTargetButtonDisabledToolTip,
                lastToggleProfitTargetStatus, BogeyTargetMultiplierDisabled, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoPilotProfileButton(int delaySeconds)
        {
            lastToggleAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
            SetAutoPilotProfileButton(toggleAutoPilotProfileButton, ToggleAutoPPButtonDisabledText, ToggleAutoPPButtonDisabledToolTip,
                lastToggleAutoPilotProfileStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoAddOnButton(int delaySeconds)
        {
            lastToggleEntryAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
            SetAutoAddOnButton(toggleAutoAddOnButton, ToggleAutoAddOnButtonDisabledText, string.Format(ToggleAutoAddOnButtonDisabledToolTip, autoAddOnMaxDollars.ToString("N0")),
                lastToggleEntryAutoAddOnStatus, delaySeconds, Brushes.DimGray);
        }

        private void ToggleAutoBEButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Auto Break-Even action via " + signalName);

            if (KeyboardManager.IsCtrlKeyDown())
            {
                DisableAutoBEButton(0);
            }
            else if (KeyboardManager.IsShiftKeyDown())
            {

                if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                {
                    breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.TrailNowBeforeBE;
                }
                else if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowBeforeBE)
                {
                    breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit;
                }
                else
                {
                    breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.Disabled;
                }

                string buttonText = "";
                string buttonToolTip = "";
                GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                SetAutoBEButton(button, buttonText, buttonToolTip,
                    lastToggleEntryBreakEvenAutoStatus, 0, Brushes.DimGray);
            }
            else
            {
                string buttonContent = button.Content.ToString();

                if (lastToggleEntryBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled
                    && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled
                    && nextBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Disabled)
                {
                    currentBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
                    DisableAutoBEButton(0);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Disabled)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.HODL;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.HODL)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Enabled;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Enabled)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMix;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMix)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailBoss;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailBoss)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailZombieFlip;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZombieFlip)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailKLineDual;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailKZ;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMonster;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMonster)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrail5Bar;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrail3Bar;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrail2Bar;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrail1Bar;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailRushLine;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailStingRay;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailStingRay)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailRiver5;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailRiver1;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailCreek5;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailCreek1;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailZipLine2;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                {
                    lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.CreeperFlipTrail;
                    string buttonText = "";
                    string buttonToolTip = "";
                    GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                    SetAutoBEButton(button, buttonText, buttonToolTip,
                        lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                }
                else
                {
                    DisableAutoBEButton(BeakEvenAutoColorDelaySeconds);
                }
            }
        }

        private void BuyPopButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Buy Pop action via " + signalName + " (LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")");

            bool isCTRLKeyDown = KeyboardManager.IsCtrlKeyDown();
            bool isSHIFTKeyDown = KeyboardManager.IsShiftKeyDown();

            bool popDelayedEntry = (popCTRLDelayedEntryFlag && isCTRLKeyDown) || (!popCTRLDelayedEntryFlag && !isCTRLKeyDown);

            if (isCTRLKeyDown && isSHIFTKeyDown)
            {
                if (limitTrancheVolumeToInProfitFlag) HandleBuyPop(signalName);
            }
            else if (isSHIFTKeyDown)
            {
                if (popLimitToPullbackFlag)
                {
                    popLimitToPullbackFlag = false;
                }
                else
                {
                    popLimitToPullbackFlag = true;
                }

                string buttonText = "";
                string buttonToolTip = "";

                GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);

                Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;

                if (useBuyPopActivateFlag)
                {
                    buttonBGColor = Brushes.HotPink;
                }

                SetBuyPopButton(button, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, buttonBGColor);

                GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);

                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, SellPopButton.Background);
            }
            else if (popDelayedEntry)
            {
                bool cancelledSellPop = HandleBuyPop(signalName, true);

                if (useSellPopActivateFlag)
                {
                    DeactivateSellPopButton(signalName);
                }
                /*
                if (useBuyPopActivateFlag)
                {
                    IncrementBuyPopDelayedTradeCount();

                    if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                        DeactivateBuyPopButton(signalName);
                }
                else
                */
                if (!cancelledSellPop)
                {
                    ActivateBuyPopButton(signalName);
                }
            }
            else
            {
                if (useBuyPopActivateFlag || useSellPopActivateFlag)
                {
                    //HandleBuyPop(signalName, true);

                    DeactivatePopDelayedEntryFeatures(signalName);
                }
                else
                {
                    bool positionFound = HandleBuyPop(signalName);
                }
            }

            /*
            if (positionFound)
            {
                RealLogger.PrintOutput("SNAP+ Error: Not supported position found for " + attachedInstrument.FullName.ToString());
            }
            */
        }

        private void SellPopButtonAction(string signalName, System.Windows.Controls.Button button)
        {
            RealLogger.PrintOutput("Sell Pop action via " + signalName + " (LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")");

            bool isCTRLKeyDown = KeyboardManager.IsCtrlKeyDown();
            bool isSHIFTKeyDown = KeyboardManager.IsShiftKeyDown();

            bool popDelayedEntry = (popCTRLDelayedEntryFlag && isCTRLKeyDown) || (!popCTRLDelayedEntryFlag && !isCTRLKeyDown);

            if (isCTRLKeyDown && isSHIFTKeyDown)
            {
                if (limitTrancheVolumeToInProfitFlag) HandleSellPop(signalName);
            }
            else if (isSHIFTKeyDown)
            {
                if (popLimitToPullbackFlag)
                {
                    popLimitToPullbackFlag = false;
                }
                else
                {
                    popLimitToPullbackFlag = true;
                }

                string buttonText = "";
                string buttonToolTip = "";
                GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);

                Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;

                if (useSellPopActivateFlag)
                {
                    buttonBGColor = Brushes.HotPink;
                }

                SetSellPopButton(button, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, buttonBGColor);

                GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);

                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, BuyPopButton.Background);
            }
            else if (popDelayedEntry)
            {
                bool cancelledBuyPop = HandleSellPop(signalName, true);

                if (useBuyPopActivateFlag)
                {
                    DeactivateBuyPopButton(signalName);
                }

                /*
                if (useSellPopActivateFlag)
                {
                    IncrementSellPopDelayedTradeCount();

                    if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                        DeactivateSellPopButton(signalName);
                }
                else
                */

                if (!cancelledBuyPop)
                {
                    ActivateSellPopButton(signalName);
                }
            }
            else
            {
                if (useBuyPopActivateFlag || useSellPopActivateFlag)
                {
                    //HandleSellPop(signalName, true);

                    DeactivatePopDelayedEntryFeatures(signalName);
                }
                else
                {
                    bool positionFound = HandleSellPop(signalName);
                }
            }

            /*
            if (positionFound)
            {
                RealLogger.PrintOutput("SNAP- Error: Not supported when position found for " + attachedInstrument.FullName.ToString());
            }
            */
        }

        private void BuyDropButtonAction(string signalName)
        {
            RealLogger.PrintOutput("Buy Drop action via " + signalName + " (LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")");

            bool positionFound = HandleBuyDrop(signalName);

            /*
            if (positionFound)
            {
                RealLogger.PrintOutput("SNAP+ Error: Not supported position found for " + attachedInstrument.FullName.ToString());
            }
            */
        }

        private void SellDropButtonAction(string signalName)
        {
            RealLogger.PrintOutput("Sell Drop action via " + signalName);

            bool positionFound = HandleSellDrop(signalName);

            /*
            if (positionFound)
            {
                RealLogger.PrintOutput("SNAP- Error: Not supported when position found for " + attachedInstrument.FullName.ToString());
            }
            */
        }

        private void DisableAutoPilotButton(int delaySeconds)
        {
            lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
            SetAutoPilotButton(toggleAutoPilotButton, ToggleAutoPilotButtonDisabledText, ToggleAutoPilotButtonDisabledToolTip,
                lastToggleEntryAutoPilotStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoPilotLiteButton(int delaySeconds)
        {
            lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
            SetAutoPilotLiteButton(toggleAutoPilotButton, ToggleAutoPilotLiteButtonDisabledText, ToggleAutoPilotLiteButtonDisabledToolTip,
                lastToggleEntryAutoPilotLiteStatus, delaySeconds, Brushes.DimGray);
        }

        private void SetAutoAddOnButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterAutoAddOnTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextAutoAddOnStatus = nextType;
            lastAutoAddOnChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoCloseButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterCloseAutoTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextCloseAutoStatus = nextType;
            lastCloseAutoChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoPilotLiteButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterAutoPilotLiteTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            if (button != null)
            {
                button.Content = buttonText;
                button.ToolTip = buttonToolTip;
                button.Background = backgroundColor;
            }

            nextAutoPilotLiteStatus = nextType;
            lastAutoPilotLiteChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoPilotButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterAutoPilotTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            if (button != null)
            {
                button.Content = buttonText;
                button.ToolTip = buttonToolTip;
                button.Background = backgroundColor;
            }

            nextAutoPilotStatus = nextType;
            lastAutoPilotChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetTradeSignalButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterTradeSignalTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextTradeSignalStatus = nextType;
            lastTradeSignalChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetBuyPopButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterPopDelayedTypes nextType, int delaySeconds, Brush backgroundColor)
        {
            if (button != null)
            {
                button.Content = buttonText;
                button.ToolTip = buttonToolTip;
                button.Background = backgroundColor;
            }

            nextBuyPopDelayedStatus = nextType;
            lastBuyPopActivateChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetSellPopButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterPopDelayedTypes nextType, int delaySeconds, Brush backgroundColor)
        {
            if (button != null)
            {
                button.Content = buttonText;
                button.ToolTip = buttonToolTip;
                button.Background = backgroundColor;
            }

            nextSellPopDelayedStatus = nextType;
            lastSellPopActivateChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetProfitTargetButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterProfitTargetTypes nextType,
            int nextMultiplier, int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextProfitTargetStatus = nextType;
            nextBogeyTargetMultiplier = nextMultiplier;
            lastProfitTargetChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoBEButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterBreakEvenAutoTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextBreakEvenAutoStatus = nextType;
            lastBreakEvenAutoChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoPilotProfileButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterAutoPilotProfileTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextAutoPilotProfileStatus = nextType;
            lastAutoPilotProfileChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private bool AttemptBogeyTargetSmartJump()
        {
            bool returnFlag = false;

            if (BogeyTargetBaseDollars > 0)
            {
                double sessionPnL = Math.Round(account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);
                //double currentBogeyTargetMultiplier = currentBogeyTargetMultiplier; // CalculateBogeyTargetMutiplier(currentBogeyTargetStatus);
                double nextBogeyMultiplier = nextBogeyTargetMultiplier; // CalculateBogeyTargetMutiplier(nextBogeyTargetStatus);

                const double toleranceBelowPercent = 0.05;
                double tolerancePercentagetOfMaxProfitDollars = this.BogeyTargetBaseDollars * toleranceBelowPercent;
                double jumpDecimalMultiplier = (sessionPnL + tolerancePercentagetOfMaxProfitDollars) / BogeyTargetBaseDollars;
                int jumpDPMultiplier = (int)Math.Ceiling(jumpDecimalMultiplier);
                if (jumpDPMultiplier <= 0)
                    jumpDPMultiplier = 1;
                else if (jumpDPMultiplier == jumpDecimalMultiplier)
                    jumpDPMultiplier++;

                //TickHunterBogeyTargetTypes jumpBogeyTargetType = GetBogeyTargetTypeByMultiplier(jumpDPMultiplier);
                int jumpBogeyTargetMultiplier = jumpDPMultiplier;// CalculateBogeyTargetMutiplier(jumpBogeyTargetType);

                if (jumpBogeyTargetMultiplier == BogeyTargetMultiplierDisabled)
                {
                    lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
                    nextProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;

                    lastToggleEntryBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
                    toggleProfitTargetButton.Content = ToggleProfitTargetButtonDisabledText;
                    toggleProfitTargetButton.ToolTip = ToggleProfitTargetButtonDisabledToolTip;
                    toggleProfitTargetButton.Background = Brushes.DimGray;
                    nextBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
                    lastProfitTargetChangeTime = (GetDateTimeNow()).AddSeconds(BogeyTargetColorDelaySeconds);
                    returnFlag = true;
                }
                else if (jumpBogeyTargetMultiplier > nextBogeyMultiplier)
                {
                    lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.BogeyTarget;
                    nextProfitTargetStatus = TickHunterProfitTargetTypes.BogeyTarget;
                    string buttonText = "";
                    string buttonToolTipText = "";
                    GetBogeyTargetTypeButtonText(jumpBogeyTargetMultiplier, out buttonText, out buttonToolTipText);

                    lastToggleEntryBogeyTargetMultiplier = jumpBogeyTargetMultiplier;
                    toggleProfitTargetButton.Content = buttonText;
                    toggleProfitTargetButton.ToolTip = buttonToolTipText;
                    toggleProfitTargetButton.Background = Brushes.DimGray;
                    nextBogeyTargetMultiplier = jumpBogeyTargetMultiplier;
                    lastProfitTargetChangeTime = (GetDateTimeNow()).AddSeconds(BogeyTargetColorDelaySeconds);
                    returnFlag = true;
                }
            }

            return returnFlag;
        }

        private bool IsTickHunterActivated()
        {
            return isTickHunterActivated;
        }

        private void UnloadAccountEvents(string signalName)
        {
            if (account != null)
            {
                lock (AccountLock)
                {
                    if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** UnloadAccountEvents: Unsubscribing via " + signalName);
                    UnsubscribeToOrderUpdate(account);
                    UnsubscribeToExecutionUpdate(account);
                    UnsubscribeToPositionUpdate(account);

                    // Performance optimization: iterate only through active follower accounts instead of all 24 indexes
                    // Use index-based loop to avoid issues if list changes during iteration
                    for (int i = 0; i < activeFollowerAccounts.Count; i++)
                    {
                        var followerInfo = activeFollowerAccounts[i];
                        if (followerInfo.Account != null)
                        {
                            UnsubscribeToExecutionUpdateHorde(followerInfo.Account);
                        }
                    }
                    
                    // Clear active follower accounts list when unloading
                    activeFollowerAccounts.Clear();

                    //if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** UnloadAccountEvents: Unsubscribing to PositionUpdate:");
                    //WeakEventManager<Account, PositionEventArgs>.RemoveHandler(account, "PositionUpdate", OnPositionUpdate);





                    //WeakEventManager<Account, AccountStatusEventArgs>.RemoveHandler(account, "AccountStatusUpdate", OnAccountStatusUpdate);
                    //WeakEventManager<Account, AccountItemEventArgs>.RemoveHandler(account, "AccountItemUpdate", OnAccountItemUpdate);


                    account = null;
                }

            }

            // Clear horde position tracking when unloading account events
            lock (hordeAccountPositions)
            {
                hordeAccountPositions.Clear();
                totalHordePositionCount = 0;
            }
        }


        private int LimitVolumeMax()
        {
            int newVolumeSize = DEFAULT_VOLUME_SIZE;

            if (LimitToVolumeMaxOption)
            {
                if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option1)
                {
                    bool maxVolumeGroup1Enabled = EntryVolumeMaxOption1 > 0;

                    if (maxVolumeGroup1Enabled)
                    {
                        newVolumeSize = EntryVolumeMaxOption1;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option2)
                {
                    bool maxVolumeGroup2Enabled = EntryVolumeMaxOption2 > 0;

                    if (maxVolumeGroup2Enabled)
                    {
                        newVolumeSize = EntryVolumeMaxOption2;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option3)
                {
                    bool maxVolumeGroup3Enabled = EntryVolumeMaxOption3 > 0;

                    if (maxVolumeGroup3Enabled)
                    {
                        newVolumeSize = EntryVolumeMaxOption3;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option4)
                {
                    bool maxVolumeGroup4Enabled = EntryVolumeMaxOption4 > 0;

                    if (maxVolumeGroup4Enabled)
                    {
                        newVolumeSize = EntryVolumeMaxOption4;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option5)
                {
                    bool maxVolumeGroup5Enabled = EntryVolumeMaxOption5 > 0;

                    if (maxVolumeGroup5Enabled)
                    {
                        newVolumeSize = EntryVolumeMaxOption5;
                    }
                }
            }

            return newVolumeSize;
        }

        private bool HandleReverse(string signalName)
        {
            bool positionFound = false;

            Instrument tempInstrument = null;
            int tempQuantity = 0;
            MarketPosition tempMarketPosition;
            OrderAction revOrderAction;

            RealPosition foundAttachedPosition = null;
            RealPosition foundBlendedPosition = null;

            int foundAttachedQuantity = 0;
            int foundBlendedQuantity = 0;

            OrderAction foundAttachedOrderAction = OrderAction.Buy;
            OrderAction foundBlendedOrderAction = OrderAction.Buy;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;

                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    bool isAttachedPosition = RealPositionService.IsValidPosition(position, attachedInstrument);
                    bool isBlendedPosition = IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument);

                    if (isAttachedPosition || isBlendedPosition)
                    {
                        position.StoreState();
                        positionFound = true;

                        if (isAttachedPosition)
                        {
                            foundAttachedPosition = position;
                            foundAttachedQuantity = position.Quantity;
                            foundAttachedOrderAction = ConvertMarketPositionToRevOrderAction(position.MarketPosition);
                        }
                        else if (isBlendedPosition)
                        {
                            foundBlendedPosition = position;
                            foundBlendedQuantity = position.Quantity;
                            foundBlendedOrderAction = ConvertMarketPositionToRevOrderAction(position.MarketPosition);
                        }
                    }
                }
            }

            Instrument firstInstrumentReadyToClose = null;
            Instrument secondInstrumentReadyToClose = null;

            bool hasAttachedPositionReadyToClose = foundAttachedPosition != null && !foundAttachedPosition.HasStateChanged() && !foundAttachedPosition.IsFlat();
            bool hasBlendPositionReadyToClose = foundBlendedPosition != null && !foundBlendedPosition.HasStateChanged() && !foundBlendedPosition.IsFlat();

            if (hasAttachedPositionReadyToClose && hasBlendPositionReadyToClose)
            {
                firstInstrumentReadyToClose = foundAttachedPosition.Instrument;
                secondInstrumentReadyToClose = foundBlendedPosition.Instrument;
            }
            else if (hasAttachedPositionReadyToClose && !hasBlendPositionReadyToClose)
            {
                firstInstrumentReadyToClose = foundAttachedPosition.Instrument;
            }
            else if (!hasAttachedPositionReadyToClose && hasBlendPositionReadyToClose)
            {
                firstInstrumentReadyToClose = foundBlendedPosition.Instrument;
            }

            if (firstInstrumentReadyToClose != null)
            {
                FlattenEverything(signalName, true, firstInstrumentReadyToClose);
                if (secondInstrumentReadyToClose != null) FlattenEverything(signalName, true, secondInstrumentReadyToClose);

                if (hasAttachedPositionReadyToClose)
                {
                    int limitedMaxVolume = DEFAULT_VOLUME_SIZE;

                    int limitedAttachedQuantity = foundAttachedQuantity;

                    if (KeyboardManager.IsCtrlKeyDown() && KeyboardManager.IsShiftKeyDown() && limitTrancheVolumeToInProfitFlag && foundAttachedQuantity > maxInitialTrancheVolumeSize)
                    {
                        limitedAttachedQuantity = maxInitialTrancheVolumeSize;
                    }

                    RealLogger.PrintOutput(signalName + " opening " + foundAttachedOrderAction.ToString().ToLower() + " " + foundAttachedPosition.Instrument.FullName + " Quantity=" + limitedAttachedQuantity, PrintTo.OutputTab1);
                    SubmitMarketOrder(signalName, foundAttachedPosition.Instrument, foundAttachedOrderAction, OrderEntry.Manual, limitedAttachedQuantity);
                }

                if (hasBlendPositionReadyToClose)
                {
                    RealLogger.PrintOutput(signalName + " opening " + foundAttachedOrderAction.ToString().ToLower() + " " + foundBlendedPosition.Instrument.FullName + " Quantity=" + foundBlendedQuantity, PrintTo.OutputTab1);
                    SubmitMarketOrder(signalName, foundBlendedPosition.Instrument, foundBlendedOrderAction, OrderEntry.Manual, foundBlendedQuantity);
                }
            }



            return positionFound;
        }

        private bool HandleBreakEvenPlus(string signalName)
        {
            double oldStopLossPrice = 0;
            int oldOrderQuantity = 0;
            double newStopLossPrice = 0;
            int tempQuantity = 0;
            bool positionFound = false;
            bool hasStopLoss = false;
            bool hasValidNewStopLossPrice = false;
            bool hasStopLossPriceMismatch = false;
            int stopLossOrderCount = 0;
            OrderType orderType = OrderType.Unknown;
            double multiPositionAveragePrice = 0;
            bool attachedHasBeenProcessed = false;
            bool blendedHasBeenProcessed = false;
            double tempAttachedInstrumentPositionStopLossPrice = 0;
            double tempBlendedInstrumentPositionStopLossPrice = 0;


            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;

                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newStopLossPrice = 0;
                        stopLossOrderCount = 0;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;
                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);

                        hasStopLoss = (oldStopLossPrice > 0);

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " via " + signalName);
                        if (!hasStopLoss)
                        {
                            newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0)
                                newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    // Button click: bypass delay and create immediately when stop loss doesn't exist
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                }
                            }
                        }
                        else
                        {
                            if (position.MarketPosition == MarketPosition.Long)
                            {
                                newStopLossPrice = GetInitialBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                                if (newStopLossPrice > multiPositionAveragePrice && oldStopLossPrice >= newStopLossPrice)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, GetBreakEvenJumpTicks());
                                }

                                if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0 && blendedHasBeenProcessed)
                                    newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                                double bidPrice = RealInstrumentService.GetBidPrice(position.Instrument);
                                if (newStopLossPrice > bidPrice)
                                {
                                    newStopLossPrice = 0;
                                }
                            }
                            else if (position.MarketPosition == MarketPosition.Short)
                            {
                                newStopLossPrice = GetInitialBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                                if (newStopLossPrice < multiPositionAveragePrice && oldStopLossPrice <= newStopLossPrice)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, GetBreakEvenJumpTicks());
                                }

                                if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0 && blendedHasBeenProcessed)
                                    newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                                double askPrice = RealInstrumentService.GetAskPrice(position.Instrument);
                                if (newStopLossPrice < askPrice)
                                {
                                    newStopLossPrice = 0;
                                }
                            }

                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);
                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newStopLossPrice);
                                }
                            }
                        }

                        attachedHasBeenProcessed = true;
                        tempAttachedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                        //break; //only one postion per instrument so exit early
                    }
                    else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newStopLossPrice = 0;
                        stopLossOrderCount = 0;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;
                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);

                        hasStopLoss = (oldStopLossPrice > 0);

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " via " + signalName);
                        if (!hasStopLoss)
                        {
                            newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionStopLossPrice > 0)
                                newStopLossPrice = tempAttachedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    // Button click: bypass delay and create immediately when stop loss doesn't exist
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                }
                            }
                        }
                        else
                        {
                            newStopLossPrice = GetInitialBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                            if (position.MarketPosition == MarketPosition.Long)
                            {
                                if (newStopLossPrice > multiPositionAveragePrice && oldStopLossPrice >= newStopLossPrice)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, GetBreakEvenJumpTicks());
                                }

                                if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionStopLossPrice > 0 && attachedHasBeenProcessed)
                                    newStopLossPrice = tempAttachedInstrumentPositionStopLossPrice;

                                double bidPrice = RealInstrumentService.GetBidPrice(position.Instrument);
                                if (newStopLossPrice > bidPrice)
                                {
                                    newStopLossPrice = 0;
                                }
                            }
                            else if (position.MarketPosition == MarketPosition.Short)
                            {
                                if (newStopLossPrice < multiPositionAveragePrice && oldStopLossPrice <= newStopLossPrice)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, GetBreakEvenJumpTicks());
                                }

                                double askPrice = RealInstrumentService.GetAskPrice(position.Instrument);
                                if (newStopLossPrice < askPrice)
                                {
                                    newStopLossPrice = 0;
                                }
                            }
                            RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);

                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);
                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newStopLossPrice);
                                }
                            }
                        }

                        blendedHasBeenProcessed = true;
                        tempBlendedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                        //break; //only one postion per instrument so exit early
                    }
                }
            }


            return positionFound;
        }

        private int GetBreakEvenJumpTicks()
        {
            int jumpTicks = this.BreakEvenJumpTicks;

            if (KeyboardManager.IsCtrlKeyDown())
            {
                jumpTicks = this.BreakEvenTurboJumpTicks;
            }

            return jumpTicks;
        }

        private bool HandleStopLossPlus(string signalName, double overrideStopLossPrice = 0)
        {
            double oldStopLossPrice = 0;
            int oldOrderQuantity = 0;
            double newStopLossPrice = 0;
            bool positionFound = false;
            bool hasStopLoss = false;
            bool hasValidNewStopLossPrice = false;
            bool hasStopLossPriceMismatch = false;
            int stopLossOrderCount = 0;
            OrderType orderType = OrderType.Unknown;
            int tempQuantity = 0;
            bool isCtrlKeyDown = KeyboardManager.IsCtrlKeyDown();
            MarketPosition positionFoundMarketPosition = MarketPosition.Flat;
            double multiPositionAveragePrice = 0;
            int positionCount = RealPositionService.PositionCount;
            bool attachedHasBeenProcessed = false;
            bool blendedHasBeenProcessed = false;
            double tempAttachedInstrumentPositionStopLossPrice = 0;
            double tempBlendedInstrumentPositionStopLossPrice = 0;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;
                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    //if (position.Instrument == attachedInstrument)
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newStopLossPrice = 0;
                        stopLossOrderCount = 0;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;
                        positionFoundMarketPosition = position.MarketPosition;



                        //if (isCtrlKeyDown && overrideStopLossPrice == 0) break;

                        //oldStopLossPrice = (overrideStopLossPrice != 0) ? overrideStopLossPrice : RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);

                        hasStopLoss = (oldStopLossPrice > 0);

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " via " + signalName);

                        if (!hasStopLoss)
                        {
                            if (overrideStopLossPrice != 0)
                                newStopLossPrice = overrideStopLossPrice;
                            else
                                newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);
                            //newStopLossPrice = (overrideStopLossPrice != 0) ? overrideStopLossPrice : GetInitialStopLossPrice(position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0)
                                newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);

                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    // Button click: bypass delay and create immediately when stop loss doesn't exist
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                }
                            }
                        }
                        else
                        {
                            if (StopLossCTRLJumpTicks)
                            {
                                if (isCtrlKeyDown)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);
                                }
                                else
                                {
                                    newStopLossPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice);
                                }
                            }
                            else
                            {
                                if (isCtrlKeyDown)
                                {
                                    newStopLossPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice);
                                }
                                else
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);
                                }
                            }

                            if (overrideStopLossPrice != 0) newStopLossPrice = overrideStopLossPrice;

                            //newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0 && blendedHasBeenProcessed)
                                newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);
                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newStopLossPrice);
                                }
                            }
                        }

                        attachedHasBeenProcessed = true;
                        tempAttachedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                        //break; //only one postion per instrument so exit early
                    }
                    else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newStopLossPrice = 0;
                        stopLossOrderCount = 0;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;
                        positionFoundMarketPosition = position.MarketPosition;

                        //oldStopLossPrice = (overrideStopLossPrice != 0) ? overrideStopLossPrice : RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        hasStopLoss = (oldStopLossPrice > 0);

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " via " + signalName);

                        if (!hasStopLoss)
                        {
                            if (overrideStopLossPrice != 0)
                                newStopLossPrice = overrideStopLossPrice;
                            else
                                newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            //newStopLossPrice = (overrideStopLossPrice != 0) ? overrideStopLossPrice : GetInitialStopLossPrice(position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionStopLossPrice > 0)
                                newStopLossPrice = tempAttachedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);

                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                }
                            }
                        }
                        else
                        {
                            if (StopLossCTRLJumpTicks)
                            {
                                if (isCtrlKeyDown)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);
                                }
                                else
                                {
                                    newStopLossPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice);
                                }
                            }
                            else
                            {
                                if (isCtrlKeyDown)
                                {
                                    newStopLossPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice);
                                }
                                else
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);
                                }
                            }

                            if (overrideStopLossPrice != 0) newStopLossPrice = overrideStopLossPrice;

                            //newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionStopLossPrice > 0 && attachedHasBeenProcessed)
                                newStopLossPrice = tempAttachedInstrumentPositionStopLossPrice;


                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);
                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newStopLossPrice);
                                }
                            }
                        }

                        blendedHasBeenProcessed = true;
                        tempBlendedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                        //break; //only one postion per instrument so exit early
                    }
                }
            }

            /*
            if (positionFound && isCtrlKeyDown && overrideStopLossPrice == 0)
            {
                if (positionFoundMarketPosition == MarketPosition.Long)
                {
                    HandleBuySnap("HandleStopLossPlus");
                }
                else if (positionFoundMarketPosition == MarketPosition.Short)
                {
                    HandleSellSnap("HandleStopLossPlus");
                }
            }
            */

            return positionFound;
        }

        private double GetNextSnapPrice(MarketPosition marketPosition, double oldStopLossPrice, bool returnSamePriceWhenPriceIsSame = false)
        {
            double snapStopLossPrice = 0;


            if (marketPosition == MarketPosition.Long)
            {
                double snapPBLevel50 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel50);
                double snapPBLevel40 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel40);
                double snapPBLevel30 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel30);
                double snapPBLevel20 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel20);
                double snapPBLevel10 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel10);
                double snapPBLevel = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel);
                double snapKeltnerInnerRing = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapKeltnerInnerRing);
                double snapRiver5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapRiver5);
                double snapRiver1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapRiver1);
                double snapCreek5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapCreek5);
                double snapCreek1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapCreek1);
                double snapZipLine1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine1);
                double snapZipLine2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine2);
                double snapZipLine3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine3);
                double snapZipLine4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine4);
                double snapDriftLine1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine1);
                double snapDriftLine2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine2);
                double snapDriftLine3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine3);
                double snapDriftLine4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine4);
                double snapKineticLine1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapKineticLine1);
                double snapKineticLine2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapKineticLine2);
                double snapSpeedLine = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapSpeedLine);
                double snapRushLine = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapRushLine);
                double snapStingRayLevel1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel1);
                double snapStingRayLevel2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel2);
                double snapStingRayLevel3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel3);
                double snapStingRayLevel4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel4);
                double snapStingRayLevel5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel5);
                double snap20 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap20Bar);
                double snap19 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap19Bar);
                double snap18 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap18Bar);
                double snap17 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap17Bar);
                double snap16 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap16Bar);
                double snap15 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap15Bar);
                double snap14 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap14Bar);
                double snap13 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap13Bar);
                double snap12 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap12Bar);
                double snap11 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap11Bar);
                double snap10 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap10Bar);
                double snap9 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap9Bar);
                double snap8 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap8Bar);
                double snap7 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap7Bar);
                double snap6 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap6Bar);
                double snap5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap5Bar);
                double snap4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap4Bar);
                double snap3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap3Bar);
                double snap2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap2Bar);
                double snap1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap1Bar);

                double min1 = 0;
                double min2 = 0;
                double min3 = 0;
                double min4 = 0;
                double min5 = 0;
                double min6 = 0;
                double min7 = 0;
                double min8 = 0;
                double min9 = 0;
                double min10 = 0;
                double min11 = 0;
                double min12 = 0;
                double min13 = 0;
                double min14 = 0;
                double min15 = 0;
                double min16 = 0;
                double min17 = 0;
                double min18 = 0;
                double min19 = 0;
                double min20 = 0;
                double min21 = 0;
                double min22 = 0;
                double min23 = 0;
                double min24 = 0;
                double min25 = 0;
                double min26 = 0;
                double min27 = 0;
                double min28 = 0;
                double min29 = 0;
                double min30 = 0;
                double min31 = 0;
                double min32 = 0;
                double min33 = 0;
                double min34 = 0;
                double min35 = 0;
                double min36 = 0;
                double min37 = 0;
                double min38 = 0;
                double min39 = 0;
                double min40 = 0;
                double min41 = 0;
                double min42 = 0;
                double min43 = 0;
                double min44 = 0;
                double min45 = 0;
                double min46 = 0;
                double min47 = 0;
                double min48 = 0;

                List<double> minList = new List<double>();
                minList.Add(snapPBLevel50);
                minList.Add(snapPBLevel40);
                minList.Add(snapPBLevel30);
                minList.Add(snapPBLevel20);
                minList.Add(snapPBLevel10);
                minList.Add(snapPBLevel);
                minList.Add(snapKeltnerInnerRing);
                minList.Add(snapRiver5);
                minList.Add(snapRiver1);
                minList.Add(snapCreek5);
                minList.Add(snapCreek1);
                minList.Add(snapZipLine4);
                minList.Add(snapZipLine3);
                minList.Add(snapZipLine2);
                minList.Add(snapZipLine1);
                minList.Add(snapStingRayLevel1);
                minList.Add(snapStingRayLevel2);
                minList.Add(snapStingRayLevel3);
                minList.Add(snapStingRayLevel4);
                minList.Add(snapStingRayLevel5);
                minList.Add(snapKineticLine1);
                minList.Add(snapKineticLine2);
                minList.Add(snapDriftLine4);
                minList.Add(snapDriftLine3);
                minList.Add(snapDriftLine2);
                minList.Add(snapDriftLine1);
                minList.Add(snapSpeedLine);
                minList.Add(snapRushLine);
                minList.Add(snap20);
                minList.Add(snap19);
                minList.Add(snap18);
                minList.Add(snap17);
                minList.Add(snap16);
                minList.Add(snap15);
                minList.Add(snap14);
                minList.Add(snap13);
                minList.Add(snap12);
                minList.Add(snap11);
                minList.Add(snap10);
                minList.Add(snap9);
                minList.Add(snap8);
                minList.Add(snap7);
                minList.Add(snap6);
                minList.Add(snap5);
                minList.Add(snap4);
                minList.Add(snap3);
                minList.Add(snap2);
                minList.Add(snap1);
                minList.Sort();

                /*
                RealLogger.PrintOutput("*** DEBUG before snapPBLevel=" + snapPBLevel);
                RealLogger.PrintOutput("*** DEBUG before snapRiver5=" + snapRiver5);
                RealLogger.PrintOutput("*** DEBUG before snapRiver1=" + snapRiver1);
                RealLogger.PrintOutput("*** DEBUG before snap8=" + snap8);
                RealLogger.PrintOutput("*** DEBUG before snap5=" + snap5);
                RealLogger.PrintOutput("*** DEBUG before snap2=" + snap2);
                RealLogger.PrintOutput("*** DEBUG before min1=" + min1);
                */

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in minList)
                {
                    index++;

                    if (index == 1)
                    {
                        min1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        min2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        min3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        min4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        min5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 6)
                    {
                        min6 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min6 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 7)
                    {
                        min7 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min7 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 8)
                    {
                        min8 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min8 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 9)
                    {
                        min9 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min9 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 10)
                    {
                        min10 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min10 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 11)
                    {
                        min11 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min11 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 12)
                    {
                        min12 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min12 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 13)
                    {
                        min13 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min13 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 14)
                    {
                        min14 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min14 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 15)
                    {
                        min15 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min15 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 16)
                    {
                        min16 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min16 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 17)
                    {
                        min17 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min17 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 18)
                    {
                        min18 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min18 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 19)
                    {
                        min19 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min19 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 20)
                    {
                        min20 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min20 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 21)
                    {
                        min21 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min21 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 22)
                    {
                        min22 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min22 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 23)
                    {
                        min23 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min23 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 24)
                    {
                        min24 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min24 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 25)
                    {
                        min25 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min25 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 26)
                    {
                        min26 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min26 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 27)
                    {
                        min27 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min27 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 28)
                    {
                        min28 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min28 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 29)
                    {
                        min29 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min29 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 30)
                    {
                        min30 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min30 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 31)
                    {
                        min31 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min31 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 32)
                    {
                        min32 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min32 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 33)
                    {
                        min33 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min33 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 34)
                    {
                        min34 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min34 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 35)
                    {
                        min35 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min35 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 36)
                    {
                        min36 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min36 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 37)
                    {
                        min37 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min37 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 38)
                    {
                        min38 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min38 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 39)
                    {
                        min39 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min39 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 40)
                    {
                        min40 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min40 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 41)
                    {
                        min41 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min41 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 42)
                    {
                        min42 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min42 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 43)
                    {
                        min43 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min43 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 44)
                    {
                        min44 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min44 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 45)
                    {
                        min45 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min45 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 46)
                    {
                        min46 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min46 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 47)
                    {
                        min47 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min47 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 48)
                    {
                        min48 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min48 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after min8=" + min8);
                RealLogger.PrintOutput("*** DEBUG after min7=" + min7);
                RealLogger.PrintOutput("*** DEBUG after min6=" + min6);
                RealLogger.PrintOutput("*** DEBUG after min5=" + min5);
                RealLogger.PrintOutput("*** DEBUG after min4=" + min4);
                RealLogger.PrintOutput("*** DEBUG after min3=" + min3);
                RealLogger.PrintOutput("*** DEBUG after min2=" + min2);
                RealLogger.PrintOutput("*** DEBUG after min1=" + min1);
                */

                snapStopLossPrice = min1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                {
                    snapStopLossPrice = min2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                    {
                        snapStopLossPrice = min3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                        {
                            snapStopLossPrice = min4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                            {
                                snapStopLossPrice = min5;

                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                {
                                    snapStopLossPrice = min6;

                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                    {
                                        snapStopLossPrice = min7;

                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                        {
                                            snapStopLossPrice = min8;

                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                            {
                                                snapStopLossPrice = min9;

                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                {
                                                    snapStopLossPrice = min10;

                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                    {
                                                        snapStopLossPrice = min11;

                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                        {
                                                            snapStopLossPrice = min12;

                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                            {
                                                                snapStopLossPrice = min13;

                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                {
                                                                    snapStopLossPrice = min14;

                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                    {
                                                                        snapStopLossPrice = min15;

                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                        {
                                                                            snapStopLossPrice = min16;

                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                            {
                                                                                snapStopLossPrice = min17;

                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                {
                                                                                    snapStopLossPrice = min17;

                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                    {
                                                                                        snapStopLossPrice = min18;

                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                        {
                                                                                            snapStopLossPrice = min19;

                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                            {
                                                                                                snapStopLossPrice = min20;

                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                {
                                                                                                    snapStopLossPrice = min21;

                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                    {
                                                                                                        snapStopLossPrice = min22;

                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                        {
                                                                                                            snapStopLossPrice = min23;

                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                            {
                                                                                                                snapStopLossPrice = min24;

                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                {
                                                                                                                    snapStopLossPrice = min25;

                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                    {
                                                                                                                        snapStopLossPrice = min26;

                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                        {
                                                                                                                            snapStopLossPrice = min27;

                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                            {
                                                                                                                                snapStopLossPrice = min28;

                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                {
                                                                                                                                    snapStopLossPrice = min29;

                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                    {
                                                                                                                                        snapStopLossPrice = min30;

                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                        {
                                                                                                                                            snapStopLossPrice = min31;

                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                            {
                                                                                                                                                snapStopLossPrice = min32;

                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                {
                                                                                                                                                    snapStopLossPrice = min33;

                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                    {
                                                                                                                                                        snapStopLossPrice = min34;

                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                        {
                                                                                                                                                            snapStopLossPrice = min35;

                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                            {
                                                                                                                                                                snapStopLossPrice = min36;

                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                {
                                                                                                                                                                    snapStopLossPrice = min37;

                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                    {
                                                                                                                                                                        snapStopLossPrice = min38;

                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                        {
                                                                                                                                                                            snapStopLossPrice = min39;

                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                            {
                                                                                                                                                                                snapStopLossPrice = min40;

                                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                {
                                                                                                                                                                                    snapStopLossPrice = min41;

                                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                    {
                                                                                                                                                                                        snapStopLossPrice = min42;

                                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                        {
                                                                                                                                                                                            snapStopLossPrice = min43;

                                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                            {
                                                                                                                                                                                                snapStopLossPrice = min44;

                                                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                                {
                                                                                                                                                                                                    snapStopLossPrice = min45;

                                                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                                    {
                                                                                                                                                                                                        snapStopLossPrice = min46;

                                                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                                        {
                                                                                                                                                                                                            snapStopLossPrice = min47;

                                                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                                            {
                                                                                                                                                                                                                snapStopLossPrice = min48;
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double snapPBLevel50 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel50);
                double snapPBLevel40 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel40);
                double snapPBLevel30 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel30);
                double snapPBLevel20 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel20);
                double snapPBLevel10 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel10);
                double snapPBLevel = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel);
                double snapSpeedLine = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapSpeedLine);
                double snapRushLine = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapRushLine);
                double snapZipLine1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine1);
                double snapZipLine2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine2);
                double snapZipLine3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine3);
                double snapZipLine4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine4);
                double snapDriftLine1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine1);
                double snapDriftLine2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine2);
                double snapDriftLine3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine3);
                double snapDriftLine4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine4);
                double snapKineticLine1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapKineticLine1);
                double snapKineticLine2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapKineticLine2);
                double snapKeltnerInnerRing = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapKeltnerInnerRing);
                double snapRiver1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapRiver1);
                double snapRiver5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapRiver5);
                double snapCreek1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapCreek1);
                double snapCreek5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapCreek5);
                double snapStingRayLevel1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel1);
                double snapStingRayLevel2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel2);
                double snapStingRayLevel3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel3);
                double snapStingRayLevel4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel4);
                double snapStingRayLevel5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel5);
                double snap20 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap20Bar);
                double snap19 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap19Bar);
                double snap18 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap18Bar);
                double snap17 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap17Bar);
                double snap16 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap16Bar);
                double snap15 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap15Bar);
                double snap14 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap14Bar);
                double snap13 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap13Bar);
                double snap12 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap12Bar);
                double snap11 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap11Bar);
                double snap10 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap10Bar);
                double snap9 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap9Bar);
                double snap8 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap8Bar);
                double snap7 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap7Bar);
                double snap6 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap6Bar);
                double snap5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap5Bar);
                double snap4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap4Bar);
                double snap3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap3Bar);
                double snap2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap2Bar);
                double snap1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap1Bar);


                double max1 = 0;
                double max2 = 0;
                double max3 = 0;
                double max4 = 0;
                double max5 = 0;
                double max6 = 0;
                double max7 = 0;
                double max8 = 0;
                double max9 = 0;
                double max10 = 0;
                double max11 = 0;
                double max12 = 0;
                double max13 = 0;
                double max14 = 0;
                double max15 = 0;
                double max16 = 0;
                double max17 = 0;
                double max18 = 0;
                double max19 = 0;
                double max20 = 0;
                double max21 = 0;
                double max22 = 0;
                double max23 = 0;
                double max24 = 0;
                double max25 = 0;
                double max26 = 0;
                double max27 = 0;
                double max28 = 0;
                double max29 = 0;
                double max30 = 0;
                double max31 = 0;
                double max32 = 0;
                double max33 = 0;
                double max34 = 0;
                double max35 = 0;
                double max36 = 0;
                double max37 = 0;
                double max38 = 0;
                double max39 = 0;
                double max40 = 0;
                double max41 = 0;
                double max42 = 0;
                double max43 = 0;
                double max44 = 0;
                double max45 = 0;
                double max46 = 0;
                double max47 = 0;
                double max48 = 0;

                List<double> maxList = new List<double>();
                maxList.Add(snapPBLevel50);
                maxList.Add(snapPBLevel40);
                maxList.Add(snapPBLevel30);
                maxList.Add(snapPBLevel20);
                maxList.Add(snapPBLevel10);
                maxList.Add(snapPBLevel);
                maxList.Add(snapStingRayLevel5);
                maxList.Add(snapStingRayLevel4);
                maxList.Add(snapStingRayLevel3);
                maxList.Add(snapStingRayLevel2);
                maxList.Add(snapStingRayLevel1);
                maxList.Add(snapKeltnerInnerRing);
                maxList.Add(snapRiver5);
                maxList.Add(snapRiver1);
                maxList.Add(snapCreek5);
                maxList.Add(snapCreek1);
                maxList.Add(snapZipLine4);
                maxList.Add(snapZipLine3);
                maxList.Add(snapZipLine2);
                maxList.Add(snapZipLine1);
                maxList.Add(snapKineticLine1);
                maxList.Add(snapKineticLine2);
                maxList.Add(snapDriftLine4);
                maxList.Add(snapDriftLine3);
                maxList.Add(snapDriftLine2);
                maxList.Add(snapDriftLine1);
                maxList.Add(snapSpeedLine);
                maxList.Add(snapRushLine);
                maxList.Add(snap20);
                maxList.Add(snap19);
                maxList.Add(snap18);
                maxList.Add(snap17);
                maxList.Add(snap16);
                maxList.Add(snap15);
                maxList.Add(snap14);
                maxList.Add(snap13);
                maxList.Add(snap12);
                maxList.Add(snap11);
                maxList.Add(snap10);
                maxList.Add(snap9);
                maxList.Add(snap8);
                maxList.Add(snap7);
                maxList.Add(snap6);
                maxList.Add(snap5);
                maxList.Add(snap4);
                maxList.Add(snap3);
                maxList.Add(snap2);
                maxList.Add(snap1);
                maxList.Sort();
                maxList.Reverse();

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in maxList)
                {
                    index++;

                    if (index == 1)
                    {
                        max1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        max2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        max3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        max4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        max5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 6)
                    {
                        max6 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max6 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 7)
                    {
                        max7 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max7 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 8)
                    {
                        max8 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max8 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 9)
                    {
                        max9 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max9 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 10)
                    {
                        max10 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max10 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 11)
                    {
                        max11 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max11 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 12)
                    {
                        max12 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max12 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 13)
                    {
                        max13 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max13 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 14)
                    {
                        max14 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max14 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 15)
                    {
                        max15 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max15 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 16)
                    {
                        max16 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max16 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 17)
                    {
                        max17 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max17 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 18)
                    {
                        max18 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max18 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 19)
                    {
                        max19 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max19 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 20)
                    {
                        max20 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max20 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 21)
                    {
                        max21 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max21 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 22)
                    {
                        max22 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max22 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 23)
                    {
                        max23 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max23 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 24)
                    {
                        max24 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max24 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 25)
                    {
                        max25 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max25 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 26)
                    {
                        max26 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max26 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 27)
                    {
                        max27 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max27 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 28)
                    {
                        max28 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max28 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 29)
                    {
                        max29 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max29 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 30)
                    {
                        max30 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max30 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 31)
                    {
                        max31 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max31 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 32)
                    {
                        max32 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max32 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 33)
                    {
                        max33 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max33 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 34)
                    {
                        max34 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max34 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 35)
                    {
                        max35 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max35 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 36)
                    {
                        max36 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max36 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 37)
                    {
                        max37 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max37 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 38)
                    {
                        max38 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max38 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 39)
                    {
                        max39 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max39 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 40)
                    {
                        max40 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max40 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 41)
                    {
                        max41 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max41 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 42)
                    {
                        max42 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max42 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 43)
                    {
                        max43 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max43 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 44)
                    {
                        max44 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max44 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 45)
                    {
                        max45 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max45 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 46)
                    {
                        max46 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max46 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 47)
                    {
                        max47 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max47 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 48)
                    {
                        max48 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max48 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after max1=" + max1);
                RealLogger.PrintOutput("*** DEBUG after max2=" + max2);
                RealLogger.PrintOutput("*** DEBUG after max3=" + max3);
                RealLogger.PrintOutput("*** DEBUG after max4=" + max4);
                RealLogger.PrintOutput("*** DEBUG after max5=" + max5);
                RealLogger.PrintOutput("*** DEBUG after max6=" + max6);
                RealLogger.PrintOutput("*** DEBUG after max7=" + max7);
                RealLogger.PrintOutput("*** DEBUG after max8=" + max8);
                RealLogger.PrintOutput("*** DEBUG after max9=" + max9);
                RealLogger.PrintOutput("*** DEBUG after max10=" + max10);
                RealLogger.PrintOutput("*** DEBUG after max11=" + max11);
                RealLogger.PrintOutput("*** DEBUG after max12=" + max12);
                RealLogger.PrintOutput("*** DEBUG after max13=" + max13);
                RealLogger.PrintOutput("*** DEBUG after max14=" + max14);
                RealLogger.PrintOutput("*** DEBUG after max15=" + max15);
                */

                snapStopLossPrice = max1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                {
                    snapStopLossPrice = max2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                    {
                        snapStopLossPrice = max3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                        {
                            snapStopLossPrice = max4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                            {
                                snapStopLossPrice = max5;

                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                {
                                    snapStopLossPrice = max6;

                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                    {
                                        snapStopLossPrice = max7;

                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                        {
                                            snapStopLossPrice = max8;

                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                            {
                                                snapStopLossPrice = max9;

                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                {
                                                    snapStopLossPrice = max10;

                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                    {
                                                        snapStopLossPrice = max11;

                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                        {
                                                            snapStopLossPrice = max12;

                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                            {
                                                                snapStopLossPrice = max13;

                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                {
                                                                    snapStopLossPrice = max14;

                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                    {
                                                                        snapStopLossPrice = max15;

                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                        {
                                                                            snapStopLossPrice = max16;

                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                            {
                                                                                snapStopLossPrice = max17;

                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                {
                                                                                    snapStopLossPrice = max18;

                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                    {
                                                                                        snapStopLossPrice = max19;

                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                        {
                                                                                            snapStopLossPrice = max20;

                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                            {
                                                                                                snapStopLossPrice = max21;

                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                {
                                                                                                    snapStopLossPrice = max22;

                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                    {
                                                                                                        snapStopLossPrice = max23;

                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                        {
                                                                                                            snapStopLossPrice = max24;

                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                            {
                                                                                                                snapStopLossPrice = max25;

                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                {
                                                                                                                    snapStopLossPrice = max26;

                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                    {
                                                                                                                        snapStopLossPrice = max27;

                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                        {
                                                                                                                            snapStopLossPrice = max28;

                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                            {
                                                                                                                                snapStopLossPrice = max29;

                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                {
                                                                                                                                    snapStopLossPrice = max30;

                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                    {
                                                                                                                                        snapStopLossPrice = max31;

                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                        {
                                                                                                                                            snapStopLossPrice = max32;

                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                            {
                                                                                                                                                snapStopLossPrice = max33;

                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                {
                                                                                                                                                    snapStopLossPrice = max34;

                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                    {
                                                                                                                                                        snapStopLossPrice = max35;

                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                        {
                                                                                                                                                            snapStopLossPrice = max36;

                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                            {
                                                                                                                                                                snapStopLossPrice = max37;

                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                {
                                                                                                                                                                    snapStopLossPrice = max38;

                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                    {
                                                                                                                                                                        snapStopLossPrice = max39;

                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                        {
                                                                                                                                                                            snapStopLossPrice = max40;

                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                            {
                                                                                                                                                                                snapStopLossPrice = max41;

                                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                {
                                                                                                                                                                                    snapStopLossPrice = max42;

                                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                    {
                                                                                                                                                                                        snapStopLossPrice = max43;

                                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                        {
                                                                                                                                                                                            snapStopLossPrice = max44;

                                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                            {
                                                                                                                                                                                                snapStopLossPrice = max45;

                                                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                                {
                                                                                                                                                                                                    snapStopLossPrice = max46;

                                                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                                    {
                                                                                                                                                                                                        snapStopLossPrice = max47;

                                                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                                        {
                                                                                                                                                                                                            snapStopLossPrice = max48;
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return snapStopLossPrice;
        }

        private double GetNextTrailBossPrice(MarketPosition marketPosition, double oldStopLossPrice, bool returnSamePriceWhenPriceIsSame = false)
        {
            double snapStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                double snap5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine3);
                double snap4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine2);
                double snap3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine1);
                double snap2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapSpeedLine);
                double snap1 = snap2;
                bool lastTwoCandlesForward = previous1CandleBullish && previous2CandleBullish;
                bool lastTwoCandlesBackForwardPlusHigher = previous1CandleBullish && !previous2CandleBullish && previous1HighPrice >= previous2HighPrice;

                if (lastTwoCandlesForward || lastTwoCandlesBackForwardPlusHigher)
                {
                    snap1 = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
                }

                double min1 = 0;
                double min2 = 0;
                double min3 = 0;
                double min4 = 0;
                double min5 = 0;

                List<double> minList = new List<double>();
                minList.Add(snap5);
                minList.Add(snap4);
                minList.Add(snap3);
                minList.Add(snap2);
                minList.Add(snap1);
                minList.Sort();

                /*
                RealLogger.PrintOutput("*** DEBUG before snapPBLevel=" + snapPBLevel);
                RealLogger.PrintOutput("*** DEBUG before snapRiver5=" + snapRiver5);
                RealLogger.PrintOutput("*** DEBUG before snapRiver1=" + snapRiver1);
                RealLogger.PrintOutput("*** DEBUG before snap8=" + snap8);
                RealLogger.PrintOutput("*** DEBUG before snap5=" + snap5);
                RealLogger.PrintOutput("*** DEBUG before snap2=" + snap2);
                RealLogger.PrintOutput("*** DEBUG before min1=" + min1);
                */

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in minList)
                {
                    index++;

                    if (index == 1)
                    {
                        min1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        min2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        min3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        min4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        min5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after min8=" + min8);
                RealLogger.PrintOutput("*** DEBUG after min7=" + min7);
                RealLogger.PrintOutput("*** DEBUG after min6=" + min6);
                RealLogger.PrintOutput("*** DEBUG after min5=" + min5);
                RealLogger.PrintOutput("*** DEBUG after min4=" + min4);
                RealLogger.PrintOutput("*** DEBUG after min3=" + min3);
                RealLogger.PrintOutput("*** DEBUG after min2=" + min2);
                RealLogger.PrintOutput("*** DEBUG after min1=" + min1);
                */

                snapStopLossPrice = min1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                {
                    snapStopLossPrice = min2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                    {
                        snapStopLossPrice = min3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                        {
                            snapStopLossPrice = min4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                            {
                                snapStopLossPrice = min5;
                            }
                        }
                    }
                }
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double snap5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine3);
                double snap4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine2);
                double snap3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine1);
                double snap2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapSpeedLine);
                double snap1 = snap2;
                bool lastTwoCandlesForward = !previous1CandleBullish && !previous2CandleBullish;
                bool lastTwoCandlesBackForwardPlusLower = !previous1CandleBullish && previous2CandleBullish && previous1LowPrice <= previous2LowPrice;

                if (lastTwoCandlesForward || lastTwoCandlesBackForwardPlusLower)
                {
                    snap1 = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
                }


                double max1 = 0;
                double max2 = 0;
                double max3 = 0;
                double max4 = 0;
                double max5 = 0;

                List<double> maxList = new List<double>();
                maxList.Add(snap5);
                maxList.Add(snap4);
                maxList.Add(snap3);
                maxList.Add(snap2);
                maxList.Add(snap1);
                maxList.Sort();
                maxList.Reverse();

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in maxList)
                {
                    index++;

                    if (index == 1)
                    {
                        max1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        max2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        max3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        max4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        max5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after max1=" + max1);
                RealLogger.PrintOutput("*** DEBUG after max2=" + max2);
                RealLogger.PrintOutput("*** DEBUG after max3=" + max3);
                RealLogger.PrintOutput("*** DEBUG after max4=" + max4);
                RealLogger.PrintOutput("*** DEBUG after max5=" + max5);
                RealLogger.PrintOutput("*** DEBUG after max6=" + max6);
                RealLogger.PrintOutput("*** DEBUG after max7=" + max7);
                RealLogger.PrintOutput("*** DEBUG after max8=" + max8);
                */

                snapStopLossPrice = max1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                {
                    snapStopLossPrice = max2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                    {
                        snapStopLossPrice = max3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                        {
                            snapStopLossPrice = max4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                            {
                                snapStopLossPrice = max5;
                            }
                        }
                    }
                }
            }

            return snapStopLossPrice;
        }

        private double GetNextDriftLinePrice(MarketPosition marketPosition, double oldStopLossPrice, bool returnSamePriceWhenPriceIsSame = false)
        {
            double snapStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                double snapPBLevel50 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel50);
                double snapPBLevel40 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel40);
                double snapPBLevel30 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel30);
                double snapPBLevel20 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel20);
                double snapPBLevel10 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel10);
                double snapPBLevel = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel);
                double snapRushLine = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapRushLine);
                double snapDriftLine1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine1);
                double snapDriftLine2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine2);
                double snapDriftLine3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine3);
                double snapDriftLine4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine4);
                double snap7 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap7Bar);
                double snap6 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap6Bar);
                double snap5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap5Bar);
                double snap4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap4Bar);
                double snap3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap3Bar);
                double snap2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap2Bar);
                double snap1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap1Bar);

                double min1 = 0;
                double min2 = 0;
                double min3 = 0;
                double min4 = 0;
                double min5 = 0;
                double min6 = 0;
                double min7 = 0;
                double min8 = 0;
                double min9 = 0;
                double min10 = 0;
                double min11 = 0;
                double min12 = 0;
                double min13 = 0;
                double min14 = 0;
                double min15 = 0;
                double min16 = 0;
                double min17 = 0;
                double min18 = 0;

                List<double> minList = new List<double>();
                minList.Add(snapPBLevel50);
                minList.Add(snapPBLevel40);
                minList.Add(snapPBLevel30);
                minList.Add(snapPBLevel20);
                minList.Add(snapPBLevel10);
                minList.Add(snapPBLevel);
                minList.Add(snapDriftLine4);
                minList.Add(snapDriftLine3);
                minList.Add(snapDriftLine2);
                minList.Add(snapDriftLine1);
                minList.Add(snapRushLine);
                minList.Add(snap7);
                minList.Add(snap6);
                minList.Add(snap5);
                minList.Add(snap4);
                minList.Add(snap3);
                minList.Add(snap2);
                minList.Add(snap1);
                minList.Sort();

                /*
                RealLogger.PrintOutput("*** DEBUG before snapPBLevel=" + snapPBLevel);
                RealLogger.PrintOutput("*** DEBUG before snapRiver5=" + snapRiver5);
                RealLogger.PrintOutput("*** DEBUG before snapRiver1=" + snapRiver1);
                RealLogger.PrintOutput("*** DEBUG before snap8=" + snap8);
                RealLogger.PrintOutput("*** DEBUG before snap5=" + snap5);
                RealLogger.PrintOutput("*** DEBUG before snap2=" + snap2);
                RealLogger.PrintOutput("*** DEBUG before min1=" + min1);
                */

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in minList)
                {
                    index++;

                    if (index == 1)
                    {
                        min1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        min2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        min3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        min4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        min5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 6)
                    {
                        min6 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min6 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 7)
                    {
                        min7 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min7 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 8)
                    {
                        min8 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min8 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 9)
                    {
                        min9 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min9 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 10)
                    {
                        min10 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min10 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 11)
                    {
                        min11 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min11 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 12)
                    {
                        min12 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min12 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 13)
                    {
                        min13 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min13 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 14)
                    {
                        min14 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min14 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 15)
                    {
                        min15 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min15 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 16)
                    {
                        min16 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min16 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 17)
                    {
                        min17 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min17 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 18)
                    {
                        min18 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min18 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after min8=" + min8);
                RealLogger.PrintOutput("*** DEBUG after min7=" + min7);
                RealLogger.PrintOutput("*** DEBUG after min6=" + min6);
                RealLogger.PrintOutput("*** DEBUG after min5=" + min5);
                RealLogger.PrintOutput("*** DEBUG after min4=" + min4);
                RealLogger.PrintOutput("*** DEBUG after min3=" + min3);
                RealLogger.PrintOutput("*** DEBUG after min2=" + min2);
                RealLogger.PrintOutput("*** DEBUG after min1=" + min1);
                */

                snapStopLossPrice = min1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                {
                    snapStopLossPrice = min2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                    {
                        snapStopLossPrice = min3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                        {
                            snapStopLossPrice = min4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                            {
                                snapStopLossPrice = min5;

                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                {
                                    snapStopLossPrice = min6;

                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                    {
                                        snapStopLossPrice = min7;

                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                        {
                                            snapStopLossPrice = min8;

                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                            {
                                                snapStopLossPrice = min9;

                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                {
                                                    snapStopLossPrice = min10;

                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                    {
                                                        snapStopLossPrice = min11;

                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                        {
                                                            snapStopLossPrice = min12;

                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                            {
                                                                snapStopLossPrice = min13;

                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                {
                                                                    snapStopLossPrice = min14;

                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                    {
                                                                        snapStopLossPrice = min15;

                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                        {
                                                                            snapStopLossPrice = min16;

                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                            {
                                                                                snapStopLossPrice = min17;

                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                {
                                                                                    snapStopLossPrice = min18;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double snapPBLevel50 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel50);
                double snapPBLevel40 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel40);
                double snapPBLevel30 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel30);
                double snapPBLevel20 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel20);
                double snapPBLevel10 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel10);
                double snapPBLevel = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel);
                double snapRushLine = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapRushLine);
                double snapDriftLine1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine1);
                double snapDriftLine2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine2);
                double snapDriftLine3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine3);
                double snapDriftLine4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine4);
                double snap7 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap7Bar);
                double snap6 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap6Bar);
                double snap5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap5Bar);
                double snap4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap4Bar);
                double snap3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap3Bar);
                double snap2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap2Bar);
                double snap1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap1Bar);

                double max1 = 0;
                double max2 = 0;
                double max3 = 0;
                double max4 = 0;
                double max5 = 0;
                double max6 = 0;
                double max7 = 0;
                double max8 = 0;
                double max9 = 0;
                double max10 = 0;
                double max11 = 0;
                double max12 = 0;
                double max13 = 0;
                double max14 = 0;
                double max15 = 0;
                double max16 = 0;
                double max17 = 0;
                double max18 = 0;

                List<double> maxList = new List<double>();
                maxList.Add(snapPBLevel50);
                maxList.Add(snapPBLevel40);
                maxList.Add(snapPBLevel30);
                maxList.Add(snapPBLevel20);
                maxList.Add(snapPBLevel10);
                maxList.Add(snapPBLevel);
                maxList.Add(snapDriftLine4);
                maxList.Add(snapDriftLine3);
                maxList.Add(snapDriftLine2);
                maxList.Add(snapDriftLine1);
                maxList.Add(snapRushLine);
                maxList.Add(snap7);
                maxList.Add(snap6);
                maxList.Add(snap5);
                maxList.Add(snap4);
                maxList.Add(snap3);
                maxList.Add(snap2);
                maxList.Add(snap1);
                maxList.Sort();
                maxList.Reverse();

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in maxList)
                {
                    index++;

                    if (index == 1)
                    {
                        max1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        max2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        max3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        max4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        max5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 6)
                    {
                        max6 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max6 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 7)
                    {
                        max7 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max7 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 8)
                    {
                        max8 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max8 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 9)
                    {
                        max9 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max9 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 10)
                    {
                        max10 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max10 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 11)
                    {
                        max11 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max11 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 12)
                    {
                        max12 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max12 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 13)
                    {
                        max13 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max13 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 14)
                    {
                        max14 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max14 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 15)
                    {
                        max15 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max15 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 16)
                    {
                        max16 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max16 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 17)
                    {
                        max17 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max17 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 18)
                    {
                        max18 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max18 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after max1=" + max1);
                RealLogger.PrintOutput("*** DEBUG after max2=" + max2);
                RealLogger.PrintOutput("*** DEBUG after max3=" + max3);
                RealLogger.PrintOutput("*** DEBUG after max4=" + max4);
                RealLogger.PrintOutput("*** DEBUG after max5=" + max5);
                RealLogger.PrintOutput("*** DEBUG after max6=" + max6);
                RealLogger.PrintOutput("*** DEBUG after max7=" + max7);
                RealLogger.PrintOutput("*** DEBUG after max8=" + max8);
                */

                snapStopLossPrice = max1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                {
                    snapStopLossPrice = max2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                    {
                        snapStopLossPrice = max3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                        {
                            snapStopLossPrice = max4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                            {
                                snapStopLossPrice = max5;

                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                {
                                    snapStopLossPrice = max6;

                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                    {
                                        snapStopLossPrice = max7;

                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                        {
                                            snapStopLossPrice = max8;

                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                            {
                                                snapStopLossPrice = max9;

                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                {
                                                    snapStopLossPrice = max10;

                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                    {
                                                        snapStopLossPrice = max11;

                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                        {
                                                            snapStopLossPrice = max12;

                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                            {
                                                                snapStopLossPrice = max13;

                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                {
                                                                    snapStopLossPrice = max14;

                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                    {
                                                                        snapStopLossPrice = max15;

                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                        {
                                                                            snapStopLossPrice = max16;

                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                            {
                                                                                snapStopLossPrice = max17;

                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                {
                                                                                    snapStopLossPrice = max18;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return snapStopLossPrice;
        }


        private bool HandleTPSLRefresh(string signalName, bool isInitialLoad = false)
        {
            // Don't make any TPSL changes if TickHunter is not activated
            if (!IsTickHunterActivated())
            {
                return false;
            }
            
            // Performance optimization #2: Check position count before lock
            int positionCount = RealPositionService.PositionCount;
            if (positionCount == 0)
            {
                return false; // Early exit - no positions to manage
            }
            
            // Performance optimization #1: Check if account is flat before lock
            if (IsAccountFlat(attachedInstrument) && 
                (!IsBlendedInstrumentEnabled() || IsAccountFlat(blendedInstrument)))
            {
                return false; // Early exit - account is flat
            }
            
            // Performance optimization #4: Time-based throttling (skip if called too recently)
            // Performance optimization #6: Cache GetDateTimeNow() result
            DateTime currentTime = GetDateTimeNow();
            if (!isInitialLoad)
            {
                if ((currentTime - lastTPSLRefreshTime).TotalMilliseconds < TPSL_REFRESH_THROTTLE_MS)
                {
                    return false; // Throttled - skip if called too recently
                }
                lastTPSLRefreshTime = currentTime;
            }
            
            double oldStopLossPrice = 0;
            double oldTakeProfitPrice = 0;
            int oldOrderQuantity = 0;
            double newStopLossPrice = 0;
            double newTakeProfitPrice = 0;
            double triggerStopLossPrice = 0;
            bool hasPosition = false;
            bool hasStopLoss = false;
            bool hasTakeProfit = false;
            bool hasProfitLocked = false;
            bool hasHitPriceTrigger = false;
            bool hasTakeProfitPriceMismatch = false;
            bool hasStopLossPriceMismatch = false;
            bool hasValidNewTakeProfitPrice = false;
            bool hasValidNewStopLossPrice = false;
            int stopLossOrderCount = 0;
            int takeProfitOrderCount = 0;
            int tempQuantity = 0;
            OrderType orderType = OrderType.Unknown;
            bool hasStopLossQuantityMismatch = false;
            bool hasTakeProfitQuantityMismatch = false;

            var lockTimeout = TimeSpan.FromMilliseconds(250);
            bool lockTaken = false;

            try
            {

                Monitor.TryEnter(RefreshTPSLLock, lockTimeout, ref lockTaken);

                if (lockTaken)
                {
                    // Performance optimization #1: Cache AreAllOrderUpdateCyclesComplete() result
                    bool areAllOrderCyclesComplete = RealOrderService.AreAllOrderUpdateCyclesComplete();
                    
                    // Performance optimization #4: Cache IsAccountFlat() results inside lock
                    bool isAttachedAccountFlat = IsAccountFlat(attachedInstrument);
                    bool isBlendedAccountFlat = IsBlendedInstrumentEnabled() ? IsAccountFlat(blendedInstrument) : true;
                    
                    // Performance optimization #5: Cache feature flag checks
                    bool isBlendedEnabled = IsBlendedInstrumentEnabled();
                    bool isDayOverMaxLossEnabled = IsDayOverMaxLossEnabled();
                    bool isAutoStopLossEnabled = IsAutoPositionStopLossEnabled();
                    bool isAutoTakeProfitEnabled = IsAutoPositionTakeProfitEnabled();
                    bool isHODLEnabled = IsHODLEnabled();
                    bool isECATPEnabled = IsECATPEnabled();
                    bool isBogeyTargetEnabled = IsBogeyTargetEnabled();
                    
                    if ((!isAttachedAccountFlat || (isBlendedEnabled && !isBlendedAccountFlat))
                        && areAllOrderCyclesComplete
                        )
                    {
                        double multiPositionAveragePrice = 0;
                        // Position count already retrieved above, reuse it

                        for (int index = 0; index < positionCount; index++)
                        {
                            RealPosition position = null;
                            if (RealPositionService.TryGetByIndex(index, out position))
                            {
                                if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                                {
                                    position.StoreState();
                                    tempQuantity = position.Quantity;

                                    hasPosition = true;
                                    multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                                    MarketPosition reversedMarketPosition = MarketPosition.Flat;

                                    if (position.MarketPosition == MarketPosition.Long)
                                        reversedMarketPosition = MarketPosition.Short;
                                    else
                                        reversedMarketPosition = MarketPosition.Long;

                                    if (CancelPositionTPSLOrders("TPSLRefresh-Rev", attachedInstrument, ConvertMarketPositionToSLOrderAction(reversedMarketPosition))) return hasPosition; //exit very early

                                    hasProfitLocked = false;
                                    hasHitPriceTrigger = false;
                                    triggerStopLossPrice = 0;
                                    newStopLossPrice = 0;
                                    stopLossOrderCount = 0;
                                    oldOrderQuantity = 0;

                                    // Performance optimization #2: Cache ConvertMarketPositionToSLOrderAction() result
                                    OrderAction slOrderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                    // Performance optimization #3: Cache GetLastPrice() result per instrument
                                    double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                    
                                    oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, slOrderAction, out orderType, out oldOrderQuantity, out stopLossOrderCount);

                                    hasStopLoss = (oldStopLossPrice > 0);
                                    hasStopLossQuantityMismatch = oldOrderQuantity != tempQuantity;

                                    if (this.StopLossRefreshManagementEnabled)
                                    {
                                        if (hasStopLoss && !hasStopLossQuantityMismatch) validateAttachedPositionStopLossQuantity = false;

                                        if (!hasStopLoss && isAutoStopLossEnabled)
                                        {
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("refresh SL price=" + oldStopLossPrice.ToString() + " auto=" + (IsAutoPositionStopLossEnabled()).ToString() + " oldquan=" + oldOrderQuantity.ToString() + " orderType=" + orderType + " via " + signalName);
                                            newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                                            if (blendedInstrumentHasPosition && blendedInstrumentPositionStopLossPrice > 0)
                                                newStopLossPrice = blendedInstrumentPositionStopLossPrice;

                                            if (isDayOverMaxLossEnabled)
                                            {
                                                if (lastDayOverMaxLossLinePrice > 0)
                                                {
                                                    newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);
                                                }
                                                else
                                                {
                                                    newStopLossPrice = 0;
                                                }
                                            }

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat() && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached slOrderAction and lastPrice
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, slOrderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    // Check if delayed stop loss creation is enabled (but not on initial load)
                                                    if (!isInitialLoad && StopLossAddOnDelaySeconds > 0)
                                                        {
                                                            // Schedule delayed stop loss creation to batch position changes
                                                        // ScheduleDelayedStopLoss will update existing scheduled SL if it hasn't expired
                                                        ScheduleDelayedStopLoss(signalName, position.Instrument, slOrderAction, tempQuantity, newStopLossPrice);
                                                    }
                                                    else
                                                    {
                                                        // Immediate creation (initial load or no delay configured)
                                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                                        CreatePositionStopLoss(signalName, position.Instrument, slOrderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                    }
                                                }

                                                if (hasStopLossQuantityMismatch)
                                                {
                                                    validateAttachedPositionStopLossQuantity = false;
                                                }
                                            }
                                        }
                                        else if (hasStopLoss && hasStopLossQuantityMismatch && validateAttachedPositionStopLossQuantity)
                                        {
                                            if (DebugLogLevel > 0) RealLogger.PrintOutput("SLQuanMismatch Current SL price=" + oldStopLossPrice.ToString() + " oldSLQuantity=" + oldOrderQuantity.ToString() + " PosQuantity=" + tempQuantity.ToString() + " SLOrderCount=" + stopLossOrderCount.ToString() + " attachedIn=" + attachedInstrument.FullName + " barPeriod=" + BarsPeriod.ToString() + " via " + signalName);
                                            if (this.StopLossRefreshOnVolumeChange)
                                            {
                                                newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity, oldStopLossPrice);
                                            }
                                            else
                                            {
                                                newStopLossPrice = oldStopLossPrice;
                                            }


                                            if (blendedInstrumentHasPosition && blendedInstrumentPositionStopLossPrice > 0)
                                                newStopLossPrice = blendedInstrumentPositionStopLossPrice;

                                            if (isDayOverMaxLossEnabled && lastDayOverMaxLossLinePrice > 0)
                                            {
                                                newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);
                                            }

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasValidNewStopLossPrice
                                                && hasStopLossQuantityMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached slOrderAction and lastPrice
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, slOrderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    // Check if quantity is increasing (add-on) or decreasing
                                                    bool quantityIncreasing = tempQuantity > oldOrderQuantity;
                                                    
                                                    bool hasMultipleStopLossOrders = (stopLossOrderCount > 1);

                                                    if (hasMultipleStopLossOrders)
                                                    {
                                                        ConsolidatePositionTPSLOrders("HandleTPSLRefresh", position.Instrument);
                                                    }

                                                    // Only apply delay when quantity is INCREASING (add-on scenario)
                                                    // When decreasing, update immediately
                                                    if (!isInitialLoad && quantityIncreasing && StopLossAddOnDelaySeconds > 0)
                                                    {
                                                        // Schedule delayed stop loss update to batch position increases
                                                        // ScheduleDelayedStopLoss will update existing scheduled SL if it hasn't expired
                                                        ScheduleDelayedStopLoss(signalName, position.Instrument, slOrderAction, tempQuantity, newStopLossPrice);
                                                    }
                                                    else
                                                    {
                                                        // Immediate update (initial load, quantity decreasing, or no delay configured)
                                                        UpdatePositionStopLoss(signalName, position.Instrument, slOrderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                    }

                                                    if (hasStopLossQuantityMismatch)
                                                    {
                                                        validateAttachedPositionStopLossQuantity = false;
                                                    }
                                                }
                                            }
                                        }
                                        else if (hasStopLoss && isDayOverMaxLossEnabled && lastDayOverMaxLossLinePrice > 0 && !validateAttachedPositionStopLossQuantity)
                                        {
                                            newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, oldStopLossPrice);

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                                            if (hasStopLossPriceMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached slOrderAction and lastPrice
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, slOrderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionStopLoss(signalName, position.Instrument, slOrderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                }
                                            }
                                        }
                                    }

                                    /*
                                    if ((BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                                        && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled)
                                    */
                                    if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled && !isHODLEnabled)
                                    {
                                        signalName = "AutoBreakEven";
                                        if (hasStopLoss)
                                        {
                                            if (position.MarketPosition == MarketPosition.Long)
                                            {
                                                if (oldStopLossPrice > multiPositionAveragePrice)
                                                {
                                                    hasProfitLocked = true;
                                                }

                                                if (BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0)
                                                {
                                                    triggerStopLossPrice = GetTriggerBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                                                    double bidPrice = RealInstrumentService.GetBidPrice(position.Instrument);
                                                    if (triggerStopLossPrice <= bidPrice)
                                                    {
                                                        hasHitPriceTrigger = true;
                                                    }
                                                }
                                            }
                                            else if (position.MarketPosition == MarketPosition.Short)
                                            {
                                                if (oldStopLossPrice < multiPositionAveragePrice)
                                                {
                                                    hasProfitLocked = true;
                                                }

                                                if (BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0)
                                                {
                                                    triggerStopLossPrice = GetTriggerBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                                                    double askPrice = RealInstrumentService.GetAskPrice(position.Instrument);
                                                    if (triggerStopLossPrice >= askPrice)
                                                    {
                                                        hasHitPriceTrigger = true;
                                                    }
                                                }
                                            }
                                        }

                                        if (hasPosition
                                            && hasStopLoss
                                            && !position.HasStateChanged()
                                            && !position.IsFlat()
                                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                        {
                                            TickHunterBreakEvenAutoTrailNowTypes localBreakEvenAutoTrailNowFlag = breakEvenAutoTrailNowFlag;

                                            bool waitForBreakEvenAutoTrailNowAfterPushFlag = WaitBreakEvenAutoTrailNowAfterProfit(position.Instrument,
                                                position.MarketPosition,
                                                position.AveragePrice);

                                            if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit && waitForBreakEvenAutoTrailNowAfterPushFlag)
                                            {
                                                localBreakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.Disabled;
                                            }

                                            if (!hasProfitLocked && hasHitPriceTrigger
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperFlipTrail
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                                            {
                                                if (DebugLogLevel > 0) RealLogger.PrintOutput("Auto BE hit trigger price of " + triggerStopLossPrice.ToString("N2") + " via " + signalName, PrintTo.OutputTab1, false);
                                                HandleBreakEvenPlus(signalName);
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ProfilePeppy)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                {
                                                    AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                    double newProfileStopLossPrice = 0;

                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        newProfileStopLossPrice = FilterSurgePriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging)
                                                            newProfileStopLossPrice = FilterGush1PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1)
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1)
                                                            newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                            newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                            newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (newProfileStopLossPrice > 0 && newProfileStopLossPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, newProfileStopLossPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        newProfileStopLossPrice = FilterSurgePriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging)
                                                            newProfileStopLossPrice = FilterGush1PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1)
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1)
                                                            newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                            newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                            newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (newProfileStopLossPrice > 0 && newProfileStopLossPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, newProfileStopLossPrice);
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ProfileSleepy)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                //if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();
                                                        /*
                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        */
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailStingRay)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            bool recentNewHigh = stingRayRecentHigherHighValue == StingRayHigherHighCode;
                                                            bool buyCreeperContinuation = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;

                                                            if (recentNewHigh && buyCreeperContinuation)
                                                            {
                                                                double entryPrice = GetStingRayLevel1Price(position.MarketPosition, AutoCloseAndTrailOffsetTicks);

                                                                if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                                {
                                                                    HandleStopLossPlus(signalName, entryPrice);
                                                                }
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            bool recentNewLow = stingRayRecentLowerLowValue == StingRayLowerLowCode;
                                                            bool sellCreeperContinuation = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                                                            if (recentNewLow && sellCreeperContinuation)
                                                            {
                                                                double entryPrice = GetStingRayLevel1Price(position.MarketPosition, AutoCloseAndTrailOffsetTicks);

                                                                if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                                {
                                                                    HandleStopLossPlus(signalName, entryPrice);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMonster)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = GetNextDriftLinePrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = GetNextDriftLinePrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailBoss)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = GetNextTrailBossPrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = GetNextTrailBossPrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                                || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        double entryPrice = CalculateTrailLowPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Enabled)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                        if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    newTakeProfitPrice = 0;
                                    takeProfitOrderCount = 0;
                                    oldOrderQuantity = 0;
                                    // Performance optimization #2: Cache ConvertMarketPositionToTPOrderAction() result
                                    OrderAction tpOrderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                    
                                    oldTakeProfitPrice = RealOrderService.GetTakeProfitInfo(position.Account, position.Instrument, tpOrderAction, out orderType, out oldOrderQuantity, out takeProfitOrderCount);

                                    hasTakeProfit = (oldTakeProfitPrice > 0);
                                    hasTakeProfitQuantityMismatch = oldOrderQuantity != tempQuantity;

                                    if (TakeProfitRefreshManagementEnabled)
                                    {
                                        if (hasTakeProfit && !hasTakeProfitQuantityMismatch) validateAttachedPositionTakeProfitQuantity = false;

                                        if (!hasTakeProfit && isAutoTakeProfitEnabled)
                                        {
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Refresh tp price=" + oldTakeProfitPrice.ToString() + " auto=" + (IsAutoPositionTakeProfitEnabled()).ToString() + " oldquan=" + oldOrderQuantity.ToString() + " via " + signalName);
                                            newTakeProfitPrice = GetInitialTakeProfitPrice(position.MarketPosition, multiPositionAveragePrice);

                                            if (blendedInstrumentHasPosition && blendedInstrumentPositionTakeProfitPrice > 0)
                                                newTakeProfitPrice = blendedInstrumentPositionTakeProfitPrice;

                                            if (!isHODLEnabled)
                                            {
                                                if (isECATPEnabled)
                                                {
                                                    if (lastECATakeProfitLinePrice > 0)
                                                    {
                                                        newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                        newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);
                                                    }
                                                    else
                                                    {
                                                        newTakeProfitPrice = 0;
                                                    }
                                                }
                                                else
                                                {
                                                    if (isBogeyTargetEnabled)
                                                    {
                                                        if (lastBogeyTargetLinePrice > 0)
                                                        {
                                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);
                                                        }
                                                        else
                                                        {
                                                            newTakeProfitPrice = 0;
                                                        }
                                                    }
                                                }
                                            }

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                                            if (hasValidNewTakeProfitPrice
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && areAllOrderCyclesComplete)
                                            {
                                                bool isNextCreateTakeProfitCycleReady = lastTakeProfitThrottleChangeTime <= currentTime;

                                                if (isNextCreateTakeProfitCycleReady)
                                                {
                                                    nextTakeProfitThrottleSeconds += DefaultTakeProfitThrottleIncrementSeconds;
                                                    lastTakeProfitThrottleChangeTime = currentTime.AddSeconds(nextTakeProfitThrottleSeconds);

                                                    // Reuse cached tpOrderAction and lastPrice
                                                    bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, tpOrderAction, newTakeProfitPrice, lastPrice);

                                                    if (isPriceValid)
                                                    {
                                                        // When no order exists, always create immediately (bypass delay)
                                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("New TP price=" + newTakeProfitPrice.ToString() + " via " + signalName);
                                                        CreatePositionTakeProfit(signalName, position.Instrument, tpOrderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                    }

                                                    if (hasTakeProfitQuantityMismatch)
                                                    {
                                                        validateAttachedPositionTakeProfitQuantity = false;
                                                    }
                                                }
                                                else
                                                {
                                                    if (lastTakeProfitLogThrottleSeconds != nextTakeProfitThrottleSeconds)
                                                    {
                                                        lastTakeProfitLogThrottleSeconds = nextTakeProfitThrottleSeconds;
                                                        RealLogger.PrintOutput("WARNING: Detecting take-profit creation issue.  Retrying take-profit creation in " + nextTakeProfitThrottleSeconds.ToString() + " seconds via " + signalName);
                                                    }
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit && hasTakeProfitQuantityMismatch && validateAttachedPositionTakeProfitQuantity)
                                        {
                                            if (DebugLogLevel > 0) RealLogger.PrintOutput("TPQuanMismatch Current TP price=" + oldTakeProfitPrice.ToString() + " oldTPQuantity=" + oldOrderQuantity.ToString() + " PosQuantity=" + tempQuantity.ToString() + " TPOrderCount=" + takeProfitOrderCount.ToString() + " attachedIn=" + attachedInstrument.FullName + " barPeriod=" + BarsPeriod.ToString() + " via " + signalName);
                                            //RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString());

                                            newTakeProfitPrice = oldTakeProfitPrice;

                                            if (blendedInstrumentHasPosition && blendedInstrumentPositionTakeProfitPrice > 0)
                                                newTakeProfitPrice = blendedInstrumentPositionTakeProfitPrice;

                                            if (!IsHODLEnabled())
                                            {
                                                if (IsECATPEnabled())
                                                {
                                                    if (lastECATakeProfitLinePrice > 0)
                                                    {
                                                        newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                        newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);
                                                    }
                                                }
                                                else
                                                {
                                                    if (IsBogeyTargetEnabled())
                                                    {
                                                        if (lastBogeyTargetLinePrice > 0)
                                                        {
                                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);
                                                        }
                                                    }
                                                }
                                            }

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasValidNewTakeProfitPrice
                                                && hasTakeProfitQuantityMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                // Reuse cached tpOrderAction and lastPrice
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, tpOrderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    bool hasNewMismatchContracts = lastTakeProfitMismatchContracts != tempQuantity;

                                                    if (hasNewMismatchContracts)
                                                    {
                                                        lastTakeProfitMismatchContracts = tempQuantity;
                                                    }

                                                    bool isNextUpdateTakeProfitCycleReady = (hasNewMismatchContracts || lastTakeProfitThrottleChangeTime <= currentTime);

                                                    if (isNextUpdateTakeProfitCycleReady)
                                                    {
                                                        if (!hasNewMismatchContracts)
                                                        {
                                                            nextTakeProfitThrottleSeconds += DefaultTakeProfitThrottleIncrementSeconds;
                                                            lastTakeProfitThrottleChangeTime = currentTime.AddSeconds(nextTakeProfitThrottleSeconds);
                                                        }

                                                        bool hasMultipleTakeProfitOrders = (takeProfitOrderCount > 1);

                                                        if (hasMultipleTakeProfitOrders)
                                                        {
                                                            ConsolidatePositionTPSLOrders("HandleTPSLRefresh", position.Instrument);
                                                        }

                                                        // Check if quantity is increasing (add-on) or decreasing
                                                        bool quantityIncreasing = tempQuantity > oldOrderQuantity;
                                                        
                                                        // Only apply delay when quantity is INCREASING (add-on scenario)
                                                        // When decreasing, update immediately
                                                        if (!isInitialLoad && quantityIncreasing && TakeProfitAddOnDelaySeconds > 0)
                                                        {
                                                            // Schedule delayed take profit update to batch position increases
                                                            // ScheduleDelayedTakeProfit will update existing scheduled TP if it hasn't expired
                                                            ScheduleDelayedTakeProfit(signalName, position.Instrument, tpOrderAction, tempQuantity, newTakeProfitPrice);
                                                        }
                                                        else
                                                        {
                                                            // Immediate update (initial load, quantity decreasing, or no delay configured)
                                                            UpdatePositionTakeProfit(signalName, position.Instrument, tpOrderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                        }

                                                        if (hasTakeProfitQuantityMismatch)
                                                        {
                                                            validateAttachedPositionTakeProfitQuantity = false;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        if (lastTakeProfitLogThrottleSeconds != nextTakeProfitThrottleSeconds)
                                                        {
                                                            lastTakeProfitLogThrottleSeconds = nextTakeProfitThrottleSeconds;
                                                            RealLogger.PrintOutput("WARNING: Detecting take-profit update quantity issue.  Retrying take-profit update quantity in " + nextTakeProfitThrottleSeconds.ToString() + " seconds via " + signalName);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit
                                            && IsBogeyTargetEnabled()
                                            && lastBogeyTargetLinePrice > 0
                                            && !isECATPEnabled
                                            && !validateAttachedPositionTakeProfitQuantity
                                            && !isHODLEnabled)
                                        {
                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached tpOrderAction and lastPrice
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, tpOrderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionTakeProfit(signalName, position.Instrument, tpOrderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit
                                            && isECATPEnabled
                                            && lastECATakeProfitLinePrice > 0
                                            && !validateAttachedPositionTakeProfitQuantity
                                            && !isHODLEnabled)
                                        {
                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached tpOrderAction and lastPrice
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, tpOrderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionTakeProfit(signalName, position.Instrument, tpOrderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }
                                            }
                                        }
                                    }

                                    //attachedInstrumentHasPosition = true;
                                    //attachedInstrumentMarketPosition = position.MarketPosition;
                                    //attachedInstrumentPositionQuantity = tempQuantity;
                                    //attachedInstrumentPositionPrice = position.AveragePrice;
                                    attachedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                                    attachedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                                    attachedInstrumentHasChanged = true;
                                    attachedInstrumentPositionPnL = GetPositionProfit(position);

                                    //riskInfoMarketPosition = position.MarketPosition;
                                    //riskInfoQuantity = tempQuantity;
                                    //riskInfoPositionPrice = position.AveragePrice;
                                    riskInfoHasChanged = true;

                                    //dayOverMaxLossMarketPosition = position.MarketPosition;
                                    //dayOverMaxLossPositionQuantity = tempQuantity;
                                    //dayOverMaxLossPositionPrice = position.AveragePrice;
                                    dayOverMaxLossHasChanged = true;

                                    //bogeyTargetMarketPosition = position.MarketPosition;
                                    //bogeyTargetPositionQuantity = tempQuantity;
                                    //bogeyTargetPositionPrice = position.AveragePrice;
                                    bogeyTargetHasChanged = true;

                                    hordeTradeCopierHasChanged = true;

                                    //dayOverAccountBalanceFloorMarketPosition = position.MarketPosition;
                                    //dayOverAccountBalanceFloorPositionQuantity = tempQuantity;
                                    //dayOverAccountBalanceFloorPositionPrice = position.AveragePrice;
                                    dayOverAccountBalanceFloorHasChanged = true;

                                    //ecaTakeProfitMarketPosition = position.MarketPosition;
                                    //ecaTakeProfitPositionQuantity = tempQuantity;
                                    //ecaTakeProfitPositionPrice = position.AveragePrice;
                                    ecaTakeProfitHasChanged = true;

                                    //averagePriceMarketPosition = position.MarketPosition;
                                    //averagePricePositionQuantity = tempQuantity;
                                    //averagePricePositionPrice = position.AveragePrice;
                                    averagePriceHasChanged = true;

                                    //break; //only one postion per instrument so exit early
                                }
                                else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                                {
                                    position.StoreState();
                                    tempQuantity = position.Quantity;

                                    hasPosition = true;
                                    multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                                    MarketPosition reversedMarketPosition = MarketPosition.Flat;

                                    if (position.MarketPosition == MarketPosition.Long)
                                        reversedMarketPosition = MarketPosition.Short;
                                    else
                                        reversedMarketPosition = MarketPosition.Long;

                                    if (CancelPositionTPSLOrders("TPSLRefresh-Rev", blendedInstrument, ConvertMarketPositionToSLOrderAction(reversedMarketPosition))) return hasPosition; //exit very early

                                    hasProfitLocked = false;
                                    hasHitPriceTrigger = false;
                                    triggerStopLossPrice = 0;
                                    newStopLossPrice = 0;
                                    stopLossOrderCount = 0;
                                    oldOrderQuantity = 0;

                                    // Performance optimization #2: Cache ConvertMarketPositionToSLOrderAction() result for blended instrument
                                    OrderAction blendedSlOrderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                    // Performance optimization #3: Cache GetLastPrice() result per instrument for blended instrument
                                    double blendedLastPrice = RealInstrumentService.GetLastPrice(position.Instrument);

                                    oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, blendedSlOrderAction, out orderType, out oldOrderQuantity, out stopLossOrderCount);

                                    hasStopLoss = (oldStopLossPrice > 0);
                                    hasStopLossQuantityMismatch = oldOrderQuantity != tempQuantity;

                                    if (this.StopLossRefreshManagementEnabled)
                                    {
                                        if (hasStopLoss && !hasStopLossQuantityMismatch) validateBlendedPositionStopLossQuantity = false;

                                        if (!hasStopLoss && IsAutoPositionStopLossEnabled())
                                        {
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Refresh SL price=" + oldStopLossPrice.ToString() + " auto=" + (IsAutoPositionStopLossEnabled()).ToString() + " oldquan=" + oldOrderQuantity.ToString() + " orderType=" + orderType + " via " + signalName);
                                            newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, position.AveragePrice, position.Quantity);

                                            if (attachedInstrumentHasPosition && attachedInstrumentPositionStopLossPrice > 0)
                                                newStopLossPrice = attachedInstrumentPositionStopLossPrice;

                                            if (isDayOverMaxLossEnabled)
                                            {
                                                if (lastDayOverMaxLossLinePrice > 0)
                                                {
                                                    newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);
                                                }
                                                else
                                                {
                                                    newStopLossPrice = 0;
                                                }
                                            }

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat() && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached blendedSlOrderAction and blendedLastPrice
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, blendedSlOrderAction, newStopLossPrice, blendedLastPrice);

                                                if (isPriceValid)
                                                {
                                                    // Check if delayed stop loss creation is enabled (but not on initial load)
                                                    if (!isInitialLoad && StopLossAddOnDelaySeconds > 0)
                                                        {
                                                            // Schedule delayed stop loss creation to batch position changes
                                                        // ScheduleDelayedStopLoss will update existing scheduled SL if it hasn't expired
                                                        ScheduleDelayedStopLoss(signalName, position.Instrument, blendedSlOrderAction, tempQuantity, newStopLossPrice);
                                                    }
                                                    else
                                                    {
                                                        // Immediate creation (initial load or no delay configured)
                                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                                        CreatePositionStopLoss(signalName, position.Instrument, blendedSlOrderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                    }
                                                }

                                                if (hasStopLossQuantityMismatch)
                                                {
                                                    validateBlendedPositionStopLossQuantity = false;
                                                }
                                            }

                                        }
                                        else if (hasStopLoss && hasStopLossQuantityMismatch && validateBlendedPositionStopLossQuantity)
                                        {
                                            if (DebugLogLevel > 0) RealLogger.PrintOutput("SLQuanMismatch Current SL price=" + oldStopLossPrice.ToString() + " oldSLQuantity=" + oldOrderQuantity.ToString() + " PosQuantity=" + tempQuantity.ToString() + " SLOrderCount=" + stopLossOrderCount.ToString() + " attachedIn=" + attachedInstrument.FullName + " barPeriod=" + BarsPeriod.ToString() + " via " + signalName);
                                            if (this.StopLossRefreshOnVolumeChange)
                                            {
                                                newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, position.AveragePrice, position.Quantity, oldStopLossPrice);
                                            }
                                            else
                                            {
                                                newStopLossPrice = oldStopLossPrice;
                                            }

                                            if (isDayOverMaxLossEnabled && lastDayOverMaxLossLinePrice > 0)
                                            {
                                                newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);
                                            }

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasValidNewStopLossPrice
                                                && hasStopLossQuantityMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached blendedSlOrderAction and blendedLastPrice
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, blendedSlOrderAction, newStopLossPrice, blendedLastPrice);

                                                if (isPriceValid)
                                                {
                                                    // Check if quantity is increasing (add-on) or decreasing
                                                    bool quantityIncreasing = tempQuantity > oldOrderQuantity;
                                                    
                                                    bool hasMultipleStopLossOrders = (stopLossOrderCount > 1);

                                                    if (hasMultipleStopLossOrders)
                                                    {
                                                        ConsolidatePositionTPSLOrders("HandleTPSLRefresh", position.Instrument);
                                                    }

                                                    // Only apply delay when quantity is INCREASING (add-on scenario)
                                                    // When decreasing, update immediately
                                                    if (!isInitialLoad && quantityIncreasing && StopLossAddOnDelaySeconds > 0)
                                                    {
                                                        // Schedule delayed stop loss update to batch position increases
                                                        // ScheduleDelayedStopLoss will update existing scheduled SL if it hasn't expired
                                                        ScheduleDelayedStopLoss(signalName, position.Instrument, blendedSlOrderAction, tempQuantity, newStopLossPrice);
                                                    }
                                                    else
                                                    {
                                                        // Immediate update (initial load, quantity decreasing, or no delay configured)
                                                        UpdatePositionStopLoss(signalName, position.Instrument, blendedSlOrderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                    }

                                                    if (hasStopLossQuantityMismatch)
                                                    {
                                                        validateBlendedPositionStopLossQuantity = false;
                                                    }
                                                }
                                            }
                                        }
                                        else if (hasStopLoss && isDayOverMaxLossEnabled && lastDayOverMaxLossLinePrice > 0 && !validateBlendedPositionStopLossQuantity)
                                        {
                                            newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached blendedSlOrderAction and blendedLastPrice
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, blendedSlOrderAction, newStopLossPrice, blendedLastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionStopLoss(signalName, position.Instrument, blendedSlOrderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                }
                                            }

                                        }
                                    }

                                    /*
                                    if ((BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                                        && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled)
                                        */
                                    if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled
                                        && !isHODLEnabled)
                                    {
                                        if (hasStopLoss)
                                        {
                                            if (position.MarketPosition == MarketPosition.Long)
                                            {
                                                if (oldStopLossPrice > position.AveragePrice)
                                                {
                                                    hasProfitLocked = true;
                                                }

                                                if (BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0)
                                                {
                                                    triggerStopLossPrice = GetTriggerBreakEvenStopLossPrice(position.MarketPosition, position.AveragePrice);

                                                    double bidPrice = RealInstrumentService.GetBidPrice(position.Instrument);
                                                    if (triggerStopLossPrice <= bidPrice)
                                                    {
                                                        hasHitPriceTrigger = true;
                                                    }
                                                }
                                            }
                                            else if (position.MarketPosition == MarketPosition.Short)
                                            {
                                                if (oldStopLossPrice < position.AveragePrice)
                                                {
                                                    hasProfitLocked = true;
                                                }

                                                if (BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0)
                                                {
                                                    triggerStopLossPrice = GetTriggerBreakEvenStopLossPrice(position.MarketPosition, position.AveragePrice);

                                                    double askPrice = RealInstrumentService.GetAskPrice(position.Instrument);
                                                    if (triggerStopLossPrice >= askPrice)
                                                    {
                                                        hasHitPriceTrigger = true;
                                                    }
                                                }
                                            }
                                        }

                                        if (hasPosition
                                            && hasStopLoss
                                            && !position.HasStateChanged()
                                            && !position.IsFlat()
                                            && areAllOrderCyclesComplete)
                                        {
                                            TickHunterBreakEvenAutoTrailNowTypes localBreakEvenAutoTrailNowFlag = breakEvenAutoTrailNowFlag;

                                            bool waitForBreakEvenAutoTrailAfterProfitFlag = WaitBreakEvenAutoTrailNowAfterProfit(position.Instrument,
                                                position.MarketPosition,
                                                position.AveragePrice);

                                            if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit
                                                && waitForBreakEvenAutoTrailAfterProfitFlag)
                                            {
                                                localBreakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.Disabled;
                                            }

                                            if (!hasProfitLocked && hasHitPriceTrigger
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperFlipTrail
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                                            {
                                                if (DebugLogLevel > 0) RealLogger.PrintOutput("Auto BE hit trigger price of " + triggerStopLossPrice.ToString("N2") + " via " + signalName, PrintTo.OutputTab1, false);
                                                HandleBreakEvenPlus(signalName);
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                                || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        double entryPrice = CalculateTrailLowPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Enabled)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                        if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    newTakeProfitPrice = 0;
                                    takeProfitOrderCount = 0;
                                    oldOrderQuantity = 0;
                                    // Performance optimization #2: Cache ConvertMarketPositionToTPOrderAction() result for blended instrument
                                    OrderAction blendedTpOrderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                    // Performance optimization #3: Reuse cached blendedLastPrice from stop loss section
                                    
                                    oldTakeProfitPrice = RealOrderService.GetTakeProfitInfo(position.Account, position.Instrument, blendedTpOrderAction, out orderType, out oldOrderQuantity, out takeProfitOrderCount);

                                    hasTakeProfit = (oldTakeProfitPrice > 0);
                                    hasTakeProfitQuantityMismatch = oldOrderQuantity != tempQuantity;

                                    if (TakeProfitRefreshManagementEnabled)
                                    {
                                        if (hasTakeProfit && !hasTakeProfitQuantityMismatch) validateBlendedPositionTakeProfitQuantity = false;

                                        if (!hasTakeProfit && isAutoTakeProfitEnabled)
                                        {
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Refresh tp price=" + oldTakeProfitPrice.ToString() + " auto=" + (IsAutoPositionTakeProfitEnabled()).ToString() + " oldquan=" + oldOrderQuantity.ToString() + " via " + signalName);
                                            newTakeProfitPrice = GetInitialTakeProfitPrice(position.MarketPosition, position.AveragePrice);

                                            if (attachedInstrumentHasPosition && attachedInstrumentPositionTakeProfitPrice > 0)
                                                newTakeProfitPrice = attachedInstrumentPositionTakeProfitPrice;

                                            if (!isHODLEnabled)
                                            {
                                                if (isECATPEnabled)
                                                {
                                                    if (lastECATakeProfitLinePrice > 0)
                                                    {
                                                        newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                        newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);
                                                    }
                                                    else
                                                    {
                                                        newTakeProfitPrice = 0;
                                                    }
                                                }
                                                else
                                                {
                                                    if (isBogeyTargetEnabled)
                                                    {
                                                        if (lastBogeyTargetLinePrice > 0)
                                                        {
                                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);
                                                        }
                                                        else
                                                        {
                                                            newTakeProfitPrice = 0;
                                                        }
                                                    }
                                                }
                                            }

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                                            if (hasValidNewTakeProfitPrice
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && areAllOrderCyclesComplete)
                                            {
                                                bool isNextCreateTakeProfitBlendCycleReady = lastTakeProfitBlendThrottleChangeTime <= currentTime;

                                                if (isNextCreateTakeProfitBlendCycleReady)
                                                {
                                                    nextTakeProfitBlendThrottleSeconds += DefaultTakeProfitBlendThrottleIncrementSeconds;
                                                    lastTakeProfitBlendThrottleChangeTime = currentTime.AddSeconds(nextTakeProfitBlendThrottleSeconds);
                                                    
                                                    // Reuse cached blendedTpOrderAction and blendedLastPrice
                                                    bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, blendedTpOrderAction, newTakeProfitPrice, blendedLastPrice);

                                                    if (isPriceValid)
                                                    {
                                                        // Check if delayed take profit creation is enabled (but not on initial load)
                                                        if (!isInitialLoad && TakeProfitAddOnDelaySeconds > 0)
                                                            {
                                                                // Schedule delayed take profit creation to batch position changes
                                                            // ScheduleDelayedTakeProfit will update existing scheduled TP if it hasn't expired
                                                            ScheduleDelayedTakeProfit(signalName, position.Instrument, blendedTpOrderAction, tempQuantity, newTakeProfitPrice);
                                                        }
                                                        else
                                                        {
                                                            // Immediate creation (initial load or no delay configured)
                                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("New TP price=" + newTakeProfitPrice.ToString() + " via " + signalName);
                                                            CreatePositionTakeProfit(signalName, position.Instrument, blendedTpOrderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                        }
                                                    }

                                                    if (hasTakeProfitQuantityMismatch)
                                                    {
                                                        validateBlendedPositionTakeProfitQuantity = false;
                                                    }
                                                }
                                                else
                                                {
                                                    if (lastTakeProfitBlendLogThrottleSeconds != nextTakeProfitBlendThrottleSeconds)
                                                    {
                                                        lastTakeProfitBlendLogThrottleSeconds = nextTakeProfitBlendThrottleSeconds;
                                                        RealLogger.PrintOutput("WARNING: Detecting take-profit blend creation issue.  Retrying take-profit blend creation in " + nextTakeProfitBlendThrottleSeconds.ToString() + " seconds via " + signalName);
                                                    }
                                                }
                                            }
                                            
                                        }
                                        else if (hasTakeProfit && hasTakeProfitQuantityMismatch && validateBlendedPositionTakeProfitQuantity)
                                        {
                                            if (DebugLogLevel > 0) RealLogger.PrintOutput("TPQuanMismatch Current TP price=" + oldTakeProfitPrice.ToString() + " oldTPQuantity=" + oldOrderQuantity.ToString() + " PosQuantity=" + tempQuantity.ToString() + " TPOrderCount=" + takeProfitOrderCount.ToString() + " attachedIn=" + attachedInstrument.FullName + " barPeriod=" + BarsPeriod.ToString() + " via " + signalName);
                                            //RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString());

                                            newTakeProfitPrice = oldTakeProfitPrice;

                                            if (!IsHODLEnabled())
                                            {
                                                if (IsECATPEnabled())
                                                {
                                                    if (lastECATakeProfitLinePrice > 0)
                                                    {
                                                        newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                        newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);
                                                    }
                                                }
                                                else
                                                {
                                                    if (IsBogeyTargetEnabled())
                                                    {
                                                        if (lastBogeyTargetLinePrice > 0)
                                                        {
                                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);
                                                        }
                                                    }
                                                }
                                            }

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasValidNewTakeProfitPrice
                                                && hasTakeProfitQuantityMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached blendedTpOrderAction and blendedLastPrice
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, blendedTpOrderAction, newTakeProfitPrice, blendedLastPrice);

                                                if (isPriceValid)
                                                {
                                                    bool hasNewBlendMismatchContracts = lastTakeProfitBlendMismatchContracts != tempQuantity;

                                                    if (hasNewBlendMismatchContracts)
                                                    {
                                                        lastTakeProfitBlendMismatchContracts = tempQuantity;
                                                    }

                                                    bool isNextUpdateTakeProfitBlendCycleReady = (hasNewBlendMismatchContracts || lastTakeProfitBlendThrottleChangeTime <= currentTime);

                                                    if (isNextUpdateTakeProfitBlendCycleReady)
                                                    {
                                                        if (!hasNewBlendMismatchContracts)
                                                        {
                                                            nextTakeProfitBlendThrottleSeconds += DefaultTakeProfitBlendThrottleIncrementSeconds;
                                                            lastTakeProfitBlendThrottleChangeTime = currentTime.AddSeconds(nextTakeProfitBlendThrottleSeconds);
                                                        }

                                                        bool hasMultipleTakeProfitOrders = (takeProfitOrderCount > 1);

                                                        if (hasMultipleTakeProfitOrders)
                                                        {
                                                            ConsolidatePositionTPSLOrders("HandleTPSLRefresh", position.Instrument);
                                                        }

                                                        // Check if quantity is increasing (add-on) or decreasing
                                                        bool quantityIncreasing = tempQuantity > oldOrderQuantity;
                                                        
                                                        // Only apply delay when quantity is INCREASING (add-on scenario)
                                                        // When decreasing, update immediately
                                                        if (!isInitialLoad && quantityIncreasing && TakeProfitAddOnDelaySeconds > 0)
                                                        {
                                                            // Schedule delayed take profit update to batch position increases
                                                            // ScheduleDelayedTakeProfit will update existing scheduled TP if it hasn't expired
                                                            ScheduleDelayedTakeProfit(signalName, position.Instrument, blendedTpOrderAction, tempQuantity, newTakeProfitPrice);
                                                        }
                                                        else
                                                        {
                                                            // Immediate update (initial load, quantity decreasing, or no delay configured)
                                                            UpdatePositionTakeProfit(signalName, position.Instrument, blendedTpOrderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                        }

                                                        if (hasTakeProfitQuantityMismatch)
                                                        {
                                                            validateBlendedPositionTakeProfitQuantity = false;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        if (lastTakeProfitBlendLogThrottleSeconds != nextTakeProfitBlendThrottleSeconds)
                                                        {
                                                            lastTakeProfitBlendLogThrottleSeconds = nextTakeProfitBlendThrottleSeconds;
                                                            RealLogger.PrintOutput("WARNING: Detecting take-profit update quantity issue.  Retrying take-profit update quantity in " + nextTakeProfitBlendThrottleSeconds.ToString() + " seconds via " + signalName);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit
                                            && isBogeyTargetEnabled
                                            && lastBogeyTargetLinePrice > 0
                                            && !isECATPEnabled
                                            && !validateBlendedPositionTakeProfitQuantity
                                            && !isHODLEnabled)
                                        {
                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached blendedTpOrderAction and blendedLastPrice
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, blendedTpOrderAction, newTakeProfitPrice, blendedLastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionTakeProfit(signalName, position.Instrument, blendedTpOrderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit
                                            && isECATPEnabled
                                            && lastECATakeProfitLinePrice > 0
                                            && !validateBlendedPositionTakeProfitQuantity
                                            && !isHODLEnabled)
                                        {
                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && areAllOrderCyclesComplete)
                                            {
                                                // Reuse cached blendedTpOrderAction and blendedLastPrice
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, blendedTpOrderAction, newTakeProfitPrice, blendedLastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionTakeProfit(signalName, position.Instrument, blendedTpOrderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }
                                            }
                                        }
                                    }

                                    //blendedInstrumentHasPosition = true;
                                    //blendedInstrumentMarketPosition = position.MarketPosition;
                                    //blendedInstrumentPositionQuantity = position.Quantity;
                                    //blendedInstrumentPositionPrice = position.AveragePrice;
                                    blendedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                                    blendedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                                    blendedInstrumentHasChanged = true;
                                }


                            }
                        }
                    }


                    if (IsAccountFlat(attachedInstrument) && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        PositionCloseCleanUp(attachedInstrument);

                        /*
                        CancelPositionTPSLOrders("TPSLRefresh-All", attachedInstrument);
                        */
                    }


                    if ((IsBlendedInstrumentEnabled() && IsAccountFlat(blendedInstrument)) && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        PositionCloseCleanUp(blendedInstrument);

                        /*
                        CancelPositionTPSLOrders("TPSLRefresh-All", blendedInstrument);

                        
                        ExitCloseAlertWindows();

                        blendedInstrumentHasPosition = false;
                        blendedInstrumentPositionCreeperCycleCount = 0;
                        blendedInstrumentPositionCreeperSurging = false;
                        blendedInstrumentMarketPosition = MarketPosition.Flat;
                        blendedInstrumentPositionPrice = 0;
                        blendedInstrumentPositionQuantity = 0;
                        blendedInstrumentPositionStopLossPrice = 0;
                        blendedInstrumentPositionTakeProfitPrice = 0;
                        blendedInstrumentHasChanged = true;

                        bogeyTargetHasChanged = true;

                        hordeTradeCopierHasChanged = true;

                        ecaTakeProfitHasChanged = true;

                        averagePriceHasChanged = true;
                        */
                    }
                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling HandleTPSLRefresh:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                throw;
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(RefreshTPSLLock);
            }


            return hasPosition;
        }

        private bool WaitBreakEvenAutoTrailNowAfterProfit(Instrument instrument, MarketPosition marketPosition, double positionAveragePrice)
        {
            bool waitBeforeTrailFlag = false;

            if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit)
            {
                if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1
                    || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2
                    || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                {
                    int offsetTicks = 0;
                    double maDL1Price = GetDriftLine1Price(marketPosition, offsetTicks);
                    double maDL2Price = GetDriftLine2Price(marketPosition, offsetTicks);
                    double maDL3Price = GetDriftLine3Price(marketPosition, offsetTicks);
                    double maBigPrice = Math.Max(Math.Max(maDL1Price, maDL2Price), maDL3Price);
                    double maLilPrice = Math.Min(Math.Min(maDL1Price, maDL2Price), maDL3Price);
                    const double MAMinATRMultiplier = 1.0;
                    double atrMinTicks = CalculateATRTicks(atrValue, MAMinATRMultiplier, attachedInstrumentTicksPerPoint);
                    bool maStackWideEnough = (maBigPrice - maLilPrice) > (atrMinTicks * attachedInstrumentTickSize);

                    if (marketPosition == MarketPosition.Long)
                    {
                        bool maStacked = maDL1Price > maDL2Price && maDL2Price > maDL3Price;
                        double maPrice = CalculateTrailMAPrice(marketPosition, offsetTicks);
                        double maPriceWithBETicks = maPrice + (BreakEvenInitialTicks * attachedInstrumentTickSize);
                        double positionAveragePriceWithBETicks = positionAveragePrice + (BreakEvenInitialTicks * attachedInstrumentTickSize);

                        if (maPrice > 0)
                        {
                            double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                            if (maStacked && maStackWideEnough && previous1CandleBullish && maPrice > positionAveragePriceWithBETicks && maPriceWithBETicks < previous1LowPrice && maPriceWithBETicks < bidPrice)
                            {
                                waitBeforeTrailFlag = false;
                            }
                            else
                            {
                                waitBeforeTrailFlag = true;
                            }
                        }
                        else
                        {
                            waitBeforeTrailFlag = true;
                        }
                    }
                    else if (marketPosition == MarketPosition.Short)
                    {
                        bool maStacked = maDL1Price < maDL2Price && maDL2Price < maDL3Price;
                        double maPrice = CalculateTrailMAPrice(marketPosition, offsetTicks);
                        double maPriceWithBETicks = maPrice - (BreakEvenInitialTicks * attachedInstrumentTickSize);
                        double positionAveragePriceWithBETicks = positionAveragePrice - (BreakEvenInitialTicks * attachedInstrumentTickSize);

                        if (maPrice > 0)
                        {
                            double askPrice = RealInstrumentService.GetAskPrice(instrument);

                            if (maStacked && maStackWideEnough && !previous1CandleBullish && maPrice < positionAveragePriceWithBETicks && maPriceWithBETicks > previous1HighPrice && maPriceWithBETicks > askPrice)
                            {
                                waitBeforeTrailFlag = false;
                            }
                            else
                            {
                                waitBeforeTrailFlag = true;
                            }
                        }
                        else
                        {
                            waitBeforeTrailFlag = true;
                        }
                    }
                }
                else
                {
                    int offsetTicks = 0;

                    if (marketPosition == MarketPosition.Long)
                    {
                        double maPrice = CalculateTrailLowPrice(marketPosition);
                        double maPriceWithBETicks = maPrice + (BreakEvenInitialTicks * attachedInstrumentTickSize);
                        double positionAveragePriceWithBETicks = positionAveragePrice + (BreakEvenInitialTicks * attachedInstrumentTickSize);

                        if (maPrice > 0)
                        {
                            double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                            if (maPrice > positionAveragePriceWithBETicks && maPriceWithBETicks < bidPrice)
                            {
                                waitBeforeTrailFlag = false;
                            }
                            else
                            {
                                waitBeforeTrailFlag = true;
                            }
                        }
                        else
                        {
                            waitBeforeTrailFlag = true;
                        }
                    }
                    else if (marketPosition == MarketPosition.Short)
                    {
                        double maPrice = CalculateTrailHighPrice(marketPosition);
                        double maPriceWithBETicks = maPrice - (BreakEvenInitialTicks * attachedInstrumentTickSize);
                        double positionAveragePriceWithBETicks = positionAveragePrice - (BreakEvenInitialTicks * attachedInstrumentTickSize);

                        if (maPrice > 0)
                        {
                            double askPrice = RealInstrumentService.GetAskPrice(instrument);

                            if (maPrice < positionAveragePriceWithBETicks && maPriceWithBETicks > askPrice)
                            {
                                waitBeforeTrailFlag = false;
                            }
                            else
                            {
                                waitBeforeTrailFlag = true;
                            }
                        }
                        else
                        {
                            waitBeforeTrailFlag = true;
                        }
                    }
                }
            }

            return waitBeforeTrailFlag;
        }

        private bool HandlePositionInfoRefresh(string signalName)
        {
            bool hasPosition = false;

            var lockTimeout = TimeSpan.FromMilliseconds(250);
            bool lockTaken = false;

            try
            {
                Monitor.TryEnter(RefreshPositionInfoLock, lockTimeout, ref lockTaken);

                if (lockTaken)
                {
                    if ((!IsAccountFlat(attachedInstrument) || (IsBlendedInstrumentEnabled() && !IsAccountFlat(blendedInstrument)))
                        && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        double multiPositionAveragePrice = 0;
                        int positionCount = RealPositionService.PositionCount;

                        for (int index = 0; index < positionCount; index++)
                        {
                            RealPosition position = null;
                            if (RealPositionService.TryGetByIndex(index, out position))
                            {
                                if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                                {
                                    hasPosition = true;
                                    multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                                    attachedInstrumentHasPosition = true;

                                    if (attachedInstrumentPositionCreeperCycleCount == 0) attachedInstrumentPositionCreeperCycleCount = stingRayCreeperCycleCountValue;
                                    if (attachedInstrumentPositionBarCount == 0) attachedInstrumentPositionBarCount = currentBarCount;
                                    attachedInstrumentMarketPosition = position.MarketPosition;
                                    attachedInstrumentPositionQuantity = position.Quantity;
                                    attachedInstrumentPositionPrice = position.AveragePrice;
                                    //attachedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                                    //attachedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                                    attachedInstrumentHasChanged = true;

                                    riskInfoMarketPosition = position.MarketPosition;
                                    riskInfoQuantity = position.Quantity;
                                    riskInfoPositionPrice = position.AveragePrice;
                                    riskInfoHasChanged = true;

                                    profitInfoMarketPosition = position.MarketPosition;
                                    profitInfoQuantity = position.Quantity;
                                    profitInfoPositionPrice = position.AveragePrice;
                                    profitInfoHasChanged = true;

                                    dayOverMaxLossMarketPosition = position.MarketPosition;
                                    dayOverMaxLossPositionQuantity = position.Quantity;
                                    dayOverMaxLossPositionPrice = position.AveragePrice;
                                    dayOverMaxLossHasChanged = true;

                                    bogeyTargetMarketPosition = position.MarketPosition;
                                    bogeyTargetPositionQuantity = position.Quantity;
                                    bogeyTargetPositionPrice = position.AveragePrice;
                                    bogeyTargetHasChanged = true;

                                    hordeTradeCopierHasChanged = true;

                                    dayOverAccountBalanceFloorMarketPosition = position.MarketPosition;
                                    dayOverAccountBalanceFloorPositionQuantity = position.Quantity;
                                    dayOverAccountBalanceFloorPositionPrice = position.AveragePrice;
                                    dayOverAccountBalanceFloorHasChanged = true;

                                    ecaTakeProfitMarketPosition = position.MarketPosition;
                                    ecaTakeProfitPositionQuantity = position.Quantity;
                                    ecaTakeProfitPositionPrice = position.AveragePrice;
                                    ecaTakeProfitHasChanged = true;

                                    averagePriceMarketPosition = position.MarketPosition;
                                    averagePricePositionQuantity = position.Quantity;
                                    averagePricePositionPrice = position.AveragePrice;
                                    averagePriceHasChanged = true;

                                    //break; //only one postion per instrument so exit early
                                }
                                else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                                {
                                    hasPosition = true;
                                    multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                                    blendedInstrumentHasPosition = true;
                                    if (blendedInstrumentPositionCreeperCycleCount == 0) blendedInstrumentPositionCreeperCycleCount = stingRayCreeperCycleCountValue;
                                    blendedInstrumentMarketPosition = position.MarketPosition;
                                    blendedInstrumentPositionQuantity = position.Quantity;
                                    blendedInstrumentPositionPrice = position.AveragePrice;
                                    //blendedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                                    //blendedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                                    blendedInstrumentHasChanged = true;
                                }
                            }
                        }
                    }

                    if (IsBlendedInstrumentEnabled())
                    {
                        if (attachedInstrumentHasChanged || blendedInstrumentHasChanged)
                        {
                            MarketPosition mixedInstrumentMarketPosition = (attachedInstrumentHasPosition) ? attachedInstrumentMarketPosition : blendedInstrumentMarketPosition;

                            double newWeightedAveragePrice = (attachedInstrumentHasPosition) ? attachedInstrumentPositionPrice : blendedInstrumentPositionPrice;
                            int mixedInstrumentQuantitySum = (attachedInstrumentHasPosition) ? attachedInstrumentPositionQuantity : blendedInstrumentPositionQuantity;

                            if (attachedInstrumentHasPosition && blendedInstrumentHasPosition)
                            {
                                int eminiQuantity = 0;
                                double eminiAveragePrice = 0;
                                int microQuantity = 0;
                                double microAveragePrice = 0;

                                if (attachedInstrumentIsEmini)
                                {
                                    microQuantity = blendedInstrumentPositionQuantity;
                                    microAveragePrice = blendedInstrumentPositionPrice;

                                    eminiQuantity = attachedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                    eminiAveragePrice = attachedInstrumentPositionPrice;
                                }
                                else
                                {
                                    microQuantity = attachedInstrumentPositionQuantity;
                                    microAveragePrice = attachedInstrumentPositionPrice;

                                    eminiQuantity = blendedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                    eminiAveragePrice = blendedInstrumentPositionPrice;
                                }

                                mixedInstrumentQuantitySum = microQuantity + eminiQuantity;
                                newWeightedAveragePrice = ((microAveragePrice * microQuantity) + (eminiAveragePrice * eminiQuantity)) / mixedInstrumentQuantitySum;
                            }
                            else if (attachedInstrumentHasPosition && !blendedInstrumentHasPosition)
                            {
                                if (attachedInstrumentIsEmini)
                                {
                                    mixedInstrumentQuantitySum = attachedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                }
                            }
                            else if (!attachedInstrumentHasPosition && blendedInstrumentHasPosition)
                            {
                                if (!attachedInstrumentIsEmini)
                                {
                                    mixedInstrumentQuantitySum = blendedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                }
                            }

                            riskInfoMarketPosition = mixedInstrumentMarketPosition;
                            riskInfoQuantity = mixedInstrumentQuantitySum;
                            riskInfoPositionPrice = newWeightedAveragePrice;
                            riskInfoHasChanged = true;

                            profitInfoMarketPosition = mixedInstrumentMarketPosition;
                            profitInfoQuantity = mixedInstrumentQuantitySum;
                            profitInfoPositionPrice = newWeightedAveragePrice;
                            profitInfoHasChanged = true;

                            dayOverMaxLossMarketPosition = mixedInstrumentMarketPosition;
                            dayOverMaxLossPositionQuantity = mixedInstrumentQuantitySum;
                            dayOverMaxLossPositionPrice = newWeightedAveragePrice;
                            dayOverMaxLossHasChanged = true;

                            hordeTradeCopierHasChanged = true;

                            dayOverAccountBalanceFloorMarketPosition = mixedInstrumentMarketPosition;
                            dayOverAccountBalanceFloorPositionQuantity = mixedInstrumentQuantitySum;
                            dayOverAccountBalanceFloorPositionPrice = newWeightedAveragePrice;
                            dayOverAccountBalanceFloorHasChanged = true;

                            bogeyTargetMarketPosition = mixedInstrumentMarketPosition;
                            bogeyTargetPositionQuantity = mixedInstrumentQuantitySum;
                            bogeyTargetPositionPrice = newWeightedAveragePrice;
                            bogeyTargetHasChanged = true;

                            hordeTradeCopierHasChanged = true;

                            averagePriceMarketPosition = mixedInstrumentMarketPosition;
                            averagePricePositionQuantity = mixedInstrumentQuantitySum;
                            averagePricePositionPrice = newWeightedAveragePrice;
                            averagePriceHasChanged = true;

                            ecaTakeProfitMarketPosition = mixedInstrumentMarketPosition;
                            ecaTakeProfitPositionQuantity = mixedInstrumentQuantitySum;
                            ecaTakeProfitPositionPrice = newWeightedAveragePrice;
                            ecaTakeProfitHasChanged = true;
                        }
                    }


                    if (IsAccountFlat(attachedInstrument) && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        PositionCloseCleanUp(attachedInstrument);

                        /*
                        ExitCloseAlertWindows();

                        attachedInstrumentHasPosition = false;
                        attachedInstrumentPositionBarCount = 0;
                        attachedInstrumentPositionCreeperCycleCount = 0;
                        attachedInstrumentPositionCreeperSurging = false;
                        attachedInstrumentPositionCreeperGushing1 = false;
                        attachedInstrumentPositionFlowing1 = false;
                        attachedInstrumentPositionFlowing2 = false;
                        attachedInstrumentPositionFlowing3 = false;
                        attachedInstrumentPositionFlowing4 = false;
                        attachedInstrumentMarketPosition = MarketPosition.Flat;
                        attachedInstrumentPositionPrice = 0;
                        attachedInstrumentPositionQuantity = 0;
                        attachedInstrumentPositionStopLossPrice = 0;
                        attachedInstrumentPositionTakeProfitPrice = 0;
                        attachedInstrumentHasChanged = true;

                        riskInfoHasChanged = true;

                        profitInfoHasChanged = true;

                        dayOverMaxLossHasChanged = true;

                        bogeyTargetHasChanged = true;

                        hordeTradeCopierHasChanged = true;

                        dayOverAccountBalanceFloorHasChanged = true;

                        ecaTakeProfitHasChanged = true;

                        averagePriceHasChanged = true;
                        */
                    }

                    if ((IsBlendedInstrumentEnabled() && IsAccountFlat(blendedInstrument)) && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        PositionCloseCleanUp(blendedInstrument);

                        /*
                        ExitCloseAlertWindows();

                        blendedInstrumentHasPosition = false;
                        blendedInstrumentPositionCreeperCycleCount = 0;
                        blendedInstrumentPositionCreeperSurging = false;
                        blendedInstrumentMarketPosition = MarketPosition.Flat;
                        blendedInstrumentPositionPrice = 0;
                        blendedInstrumentPositionQuantity = 0;
                        blendedInstrumentPositionStopLossPrice = 0;
                        blendedInstrumentPositionTakeProfitPrice = 0;
                        blendedInstrumentHasChanged = true;

                        bogeyTargetHasChanged = true;

                        hordeTradeCopierHasChanged = true;

                        ecaTakeProfitHasChanged = true;

                        averagePriceHasChanged = true;
                        */
                    }

                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling HandlePositionInfoRefresh:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                throw;
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(RefreshPositionInfoLock);
            }


            return hasPosition;
        }
        //------

        private double FilterStopLossByPriceMax(MarketPosition marketPosition, double filterPrice, double newStopLossPrice)
        {
            if (filterPrice != 0)
            {
                if (marketPosition == MarketPosition.Long)
                {
                    if (newStopLossPrice != 0 && newStopLossPrice < filterPrice)
                    {
                        newStopLossPrice = filterPrice;
                    }
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    if (newStopLossPrice != 0 && newStopLossPrice > filterPrice)
                    {
                        newStopLossPrice = filterPrice;
                    }
                }
            }

            return newStopLossPrice;
        }

        private double FilterStopLossByMarketPrice(Instrument instrument, MarketPosition marketPosition, double newStopLossPrice)
        {
            if (newStopLossPrice != 0)
            {
                if (marketPosition == MarketPosition.Long)
                {
                    double bidPrice = RealInstrumentService.GetBidPrice(instrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(instrument);
                    if (newStopLossPrice >= (Math.Min(bidPrice, lastPrice) - (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
                    {
                        newStopLossPrice = 0;
                    }
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    double askPrice = RealInstrumentService.GetAskPrice(instrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(instrument);
                    if (newStopLossPrice <= (Math.Max(askPrice, lastPrice) + (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
                    {
                        newStopLossPrice = 0;
                    }
                }
            }

            return newStopLossPrice;
        }

        private double FilterTakeProfitByPriceMax(MarketPosition marketPosition, double filterPrice, double oldTakeProfitPrice, double newTakeProfitPrice)
        {
            if (filterPrice != 0)
            {
                if (marketPosition == MarketPosition.Long)
                {
                    if ((oldTakeProfitPrice != 0 && oldTakeProfitPrice > filterPrice)
                        || (newTakeProfitPrice != 0 && newTakeProfitPrice > filterPrice))
                    {
                        newTakeProfitPrice = filterPrice;
                    }
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    if ((oldTakeProfitPrice != 0 && oldTakeProfitPrice < filterPrice)
                        || (newTakeProfitPrice != 0 && newTakeProfitPrice < filterPrice))
                    {
                        newTakeProfitPrice = filterPrice;
                    }
                }
            }

            return newTakeProfitPrice;
        }
        private double FilterTakeProfitByMarketPrice(Instrument instrument, MarketPosition marketPosition, double newTakeProfitPrice)
        {
            if (newTakeProfitPrice != 0)
            {
                if (marketPosition == MarketPosition.Long)
                {
                    double askPrice = RealInstrumentService.GetAskPrice(instrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(instrument);
                    if (newTakeProfitPrice <= (Math.Max(askPrice, lastPrice) + (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
                    {
                        newTakeProfitPrice = 0;
                    }
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    double bidPrice = RealInstrumentService.GetBidPrice(instrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(instrument);
                    if (newTakeProfitPrice >= (Math.Min(bidPrice, lastPrice) - (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
                    {
                        newTakeProfitPrice = 0;
                    }
                }
            }

            return newTakeProfitPrice;
        }

        private double FilterTakeProfitByForceSync(bool applyForceSync, double forcePrice, double newTakeProfitPrice)
        {
            if (applyForceSync)
            {
                newTakeProfitPrice = forcePrice;
            }

            return newTakeProfitPrice;
        }

        private bool HandleTakeProfitPlus(string signalName, double overrideTakeProfitPrice = 0)
        {
            double oldTakeProfitPrice = 0;
            int oldOrderQuantity = 0;
            double newTakeProfitPrice = 0;
            bool positionFound = false;
            bool hasTakeProfit = false;
            bool hasValidNewTakeProfitPrice = false;
            bool hasTakeProfitPriceMismatch = false;
            int takeProfitOrderCount = 0;
            OrderType orderType = OrderType.Unknown;
            int tempQuantity = 0;
            bool isCtrlKeyDown = false;
            MarketPosition positionFoundMarketPosition = MarketPosition.Flat;
            double multiPositionAveragePrice = 0;
            bool attachedHasBeenProcessed = false;
            bool blendedHasBeenProcessed = false;
            double tempAttachedInstrumentPositionTakeProfitPrice = 0;
            double tempBlendedInstrumentPositionTakeProfitPrice = 0;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;
                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    //if (position.Instrument == attachedInstrument)
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newTakeProfitPrice = 0;
                        takeProfitOrderCount = 0;
                        positionFoundMarketPosition = position.MarketPosition;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                        isCtrlKeyDown = KeyboardManager.IsCtrlKeyDown();

                        if (isCtrlKeyDown && overrideTakeProfitPrice == 0) break;

                        oldTakeProfitPrice = RealOrderService.GetTakeProfitInfo(position.Account, position.Instrument, ConvertMarketPositionToTPOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out takeProfitOrderCount);
                        hasTakeProfit = oldTakeProfitPrice == 0;

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current TP price=" + oldTakeProfitPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " position quantity=" + tempQuantity.ToString() + " via " + signalName);

                        if (hasTakeProfit)
                        {
                            newTakeProfitPrice = (overrideTakeProfitPrice != 0) ? overrideTakeProfitPrice : GetInitialTakeProfitPrice(position.MarketPosition, multiPositionAveragePrice);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionTakeProfitPrice > 0)
                                newTakeProfitPrice = tempBlendedInstrumentPositionTakeProfitPrice;

                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                            if (hasValidNewTakeProfitPrice && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                            {
                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    // Check if delayed take profit creation is enabled (manual functions use delay, not initial load)
                                    if (TakeProfitAddOnDelaySeconds > 0)
                                        {
                                            // Schedule delayed take profit creation to batch position changes
                                        // ScheduleDelayedTakeProfit will update existing scheduled TP if it hasn't expired
                                            ScheduleDelayedTakeProfit(signalName, position.Instrument, orderAction, tempQuantity, newTakeProfitPrice);
                                    }
                                    else
                                    {
                                        // Immediate creation (no delay configured)
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("New TP price=" + newTakeProfitPrice.ToString() + " via " + signalName);
                                        CreatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                    }
                                }
                            }
                        }
                        else
                        {
                            newTakeProfitPrice = (overrideTakeProfitPrice != 0) ? overrideTakeProfitPrice : GetTakeProfitPriceFromJumpTicks(position.MarketPosition, oldTakeProfitPrice, this.TakeProfitJumpTicks);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionTakeProfitPrice > 0 && blendedHasBeenProcessed)
                                newTakeProfitPrice = tempBlendedInstrumentPositionTakeProfitPrice;

                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                if (isPriceValid)
                                {

                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated TP price=" + newTakeProfitPrice.ToString() + " old=" + oldTakeProfitPrice.ToString() + " via " + signalName);
                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newTakeProfitPrice);
                                }
                            }
                        }

                        attachedHasBeenProcessed = true;
                        tempAttachedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                        //break; //only one postion per instrument so exit early
                    }
                    else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newTakeProfitPrice = 0;
                        takeProfitOrderCount = 0;
                        positionFoundMarketPosition = position.MarketPosition;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                        isCtrlKeyDown = KeyboardManager.IsCtrlKeyDown();

                        if (isCtrlKeyDown && overrideTakeProfitPrice == 0) break;

                        oldTakeProfitPrice = RealOrderService.GetTakeProfitInfo(position.Account, position.Instrument, ConvertMarketPositionToTPOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out takeProfitOrderCount);
                        hasTakeProfit = oldTakeProfitPrice == 0;

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current TP price=" + oldTakeProfitPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " position quantity=" + tempQuantity.ToString() + " via " + signalName);

                        if (hasTakeProfit)
                        {
                            newTakeProfitPrice = (overrideTakeProfitPrice != 0) ? overrideTakeProfitPrice : GetInitialTakeProfitPrice(position.MarketPosition, multiPositionAveragePrice);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionTakeProfitPrice > 0)
                                newTakeProfitPrice = tempAttachedInstrumentPositionTakeProfitPrice;

                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                            if (hasValidNewTakeProfitPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    // Button click: bypass delay and create immediately when take profit doesn't exist
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New TP price=" + newTakeProfitPrice.ToString() + " via " + signalName);
                                    CreatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                }
                            }
                        }
                        else
                        {
                            newTakeProfitPrice = (overrideTakeProfitPrice != 0) ? overrideTakeProfitPrice : GetTakeProfitPriceFromJumpTicks(position.MarketPosition, oldTakeProfitPrice, this.TakeProfitJumpTicks);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionTakeProfitPrice > 0 && attachedHasBeenProcessed)
                                newTakeProfitPrice = tempAttachedInstrumentPositionTakeProfitPrice;

                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                if (isPriceValid)
                                {

                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated TP price=" + newTakeProfitPrice.ToString() + " old=" + oldTakeProfitPrice.ToString() + " via " + signalName);
                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newTakeProfitPrice);
                                }
                            }
                        }

                        blendedHasBeenProcessed = true;
                        tempBlendedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                        //break; //only one postion per instrument so exit early
                    }
                }
            }

            if (positionFound && isCtrlKeyDown && overrideTakeProfitPrice == 0)
            {
                if (positionFoundMarketPosition == MarketPosition.Long)
                {
                    HandleSellSnap("HandleTakeProfitPlus");
                }
                else if (positionFoundMarketPosition == MarketPosition.Short)
                {
                    HandleBuySnap("HandleTakeProfitPlus");
                }
            }

            return positionFound;
        }

        private bool HandleSellSnap(string signalName)
        {
            double newSellSnapPrice = 0;
            bool positionFound = false;
            bool isShortPosition = false;
            bool orderFound = false;
            double oldStopLossPrice = 0;
            double takeProfitPrice = 0;
            int stopLossOrderCount = 0;
            OrderType orderType = OrderType.Unknown;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;
                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    //if (position.Instrument == attachedInstrument)
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        isShortPosition = (position.MarketPosition == MarketPosition.Short);
                        positionFound = true;

                        int oldOrderQuantity = 0;
                        stopLossOrderCount = 0;

                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        int stopLossTicks = CalculateStopLossTicks(position.MarketPosition, position.AveragePrice, oldStopLossPrice, attachedInstrumentTickSize);
                        int stopLossMultipliedTicks = (int)(stopLossTicks * TakeProfitCtrlSLMultiplier);
                        takeProfitPrice = CalculateTakeProfitPrice(position.MarketPosition, position.AveragePrice, stopLossMultipliedTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

                        break;
                    }
                }
            }

            if (!isShortPosition && positionFound && CheckSnapPositionTPSL())
            {
                if (takeProfitPrice > 0)
                {
                    HandleTakeProfitPlus("SellSnap", takeProfitPrice);
                }
                positionFound = false;
            }
            else if (isShortPosition && positionFound && CheckSnapPositionTPSL())
            {
                TrailSellPositionStopLoss("SellSnap", true);
            }
            else if (!positionFound || !CheckSnapPositionTPSL())
            {
                orderFound = CancelPopDropOrders("SellSnap");

                if (!orderFound)
                {
                    newSellSnapPrice = CalculateTrailLowPrice(MarketPosition.Short, true);

                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                    if (newSellSnapPrice >= bidPrice)
                    {
                        newSellSnapPrice = 0;
                    }


                    if (newSellSnapPrice != 0)
                    {
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("New Snap- price=" + newSellSnapPrice.ToString() + " via " + signalName);
                        int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                        CreateSellStop(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, autoEntryVolume, newSellSnapPrice);
                    }
                }

            }

            return positionFound;
        }

        private void TrailSellPositionStopLoss(string signalName, bool force1Bar = false)
        {
            double newEntryPrice = CalculateTrailHighPrice(MarketPosition.Short, force1Bar);

            double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
            double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);

            if (newEntryPrice <= (Math.Max(askPrice, lastPrice) + (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
            {
                newEntryPrice = 0;
            }

            if (newEntryPrice != 0)
            {
                //if (DebugLogLevel > 2) RealLogger.PrintOutput("New Snap- price=" + newSellSnapPrice.ToString());

                HandleStopLossPlus(signalName, newEntryPrice);
            }
        }

        private void TrailBuyPositionStopLoss(string signalName, bool force1Bar = false)
        {
            double newEntryPrice = CalculateTrailLowPrice(MarketPosition.Long, force1Bar);

            double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
            double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);

            if (newEntryPrice >= (Math.Min(bidPrice, lastPrice) - (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
            {
                newEntryPrice = 0;
            }

            if (newEntryPrice != 0)
            {
                //if (DebugLogLevel > 2) RealLogger.PrintOutput("New trail price=" + newEntryPrice.ToString());

                HandleStopLossPlus(signalName, newEntryPrice);
            }
        }

        private double CalculateTrailMAPrice(MarketPosition positionType, int offsetTicks)
        {
            double maPrice = 0;

            if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                maPrice = GetSpeedLineFilterPrice(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                maPrice = GetRushLinePrice(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                maPrice = GetMovingAverage1Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                maPrice = GetMovingAverage2Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                maPrice = GetMovingAverage3Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                maPrice = GetMovingAverage4Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                maPrice = GetDriftLine1Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                maPrice = GetDriftLine2Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                maPrice = GetDriftLine3Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                maPrice = GetDriftLine4Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                maPrice = GetRiver1EdgePrice(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                maPrice = GetRiver5EdgePrice(positionType, offsetTicks);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, maPrice);

            return normalizedPrice;
        }

        private double CalculateTrailLowPrice(MarketPosition positionType, bool force1Bar = false)
        {
            double entryPrice = 0;

            if (force1Bar || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
                entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
                entryPrice = Math.Min(previous1LowPrice, previous2LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
                entryPrice = Math.Min(Math.Min(previous1LowPrice, previous2LowPrice), previous3LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(previous1LowPrice, previous2LowPrice), previous3LowPrice), previous4LowPrice), previous5LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMix)
            {
                bool lastTwoCandlesForward = previous1CandleBullish && previous2CandleBullish;
                bool lastTwoCandlesBackForwardPlusHigher = previous1CandleBullish && !previous2CandleBullish && previous1HighPrice >= previous2HighPrice;

                if (lastTwoCandlesForward || lastTwoCandlesBackForwardPlusHigher)
                {
                    entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = 0;
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                entryPrice = GetSpeedLineFilterPrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                entryPrice = GetRushLinePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                entryPrice = GetMovingAverage1Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                entryPrice = GetMovingAverage2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                entryPrice = GetMovingAverage3Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                entryPrice = GetMovingAverage4Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                entryPrice = GetRiver1EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                entryPrice = GetRiver5EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                entryPrice = GetCreek1EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                entryPrice = GetCreek5EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
                entryPrice = GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
            {
                entryPrice = Math.Min(GetZipLine1Price(positionType, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
            {
                if (autoPilotSetupZombieBuyContinuation1 && autoPilotSetupZombie2BuyContinuation1)
                {
                    entryPrice = Math.Min(GetKineticLine1Price(positionType, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
            {
                if (autoPilotSetupZombieBuyContinuation1 && autoPilotSetupZombie2BuyContinuation1)
                {
                    entryPrice = Math.Min(Math.Min(Math.Min(GetKineticLine1Price(positionType, AutoCloseAndTrailOffsetTicks),
                        GetKineticLine2Price(positionType, AutoCloseAndTrailOffsetTicks)),
                        GetZipLine1Price(positionType, AutoCloseAndTrailOffsetTicks)),
                        GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                entryPrice = GetRushLinePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                entryPrice = GetDriftLine1Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                entryPrice = GetDriftLine2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                entryPrice = GetDriftLine3Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                entryPrice = GetDriftLine4Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZombieFlip)
            {
                /*
                double zipLine1Price = GetZipLine1Price(positionType, 0);
                double zipLine1Value2Price = GetZipLine1Value2Price(positionType, 0);

                double zipLine2Price = GetZipLine2Price(positionType, 0);
                double zipLine2Value2Price = GetZipLine2Value2Price(positionType, 0);

                double zipLineDualPrice = Math.Min(zipLine1Price, zipLine2Price);
                double zipLineDualValue2Price = Math.Min(zipLine1Value2Price, zipLine2Value2Price);

                bool zipLineFlip = false;

                if (zipLineDualPrice == zipLine1Price)
                {
                    zipLineFlip = zipLine1Value2Price <= previous2ClosePrice && zipLine1Price > previous1ClosePrice;
                }
                else
                {
                    zipLineFlip = zipLine2Value2Price <= previous2ClosePrice && zipLine2Price > previous1ClosePrice;
                }
                */

                bool zombieSetupFlip = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                
                if (zombieSetupFlip)
                {
                    entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
            {
                bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                if (buyZombieSetup)
                {
                    entryPrice = CalculateSnapBarLowPrice(BreakEvenAutoZombieFlipResumeSnapType);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
            {
                bool sellZombieSetupContinuation = autoPilotSetupZombieValue == ZombieSetupSellCode;
                bool sellCreeperSetupContinuation = (autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2);
                if (sellZombieSetupContinuation && sellCreeperSetupContinuation)
                {
                    entryPrice = CalculateSnapBarLowPrice(BreakEvenAutoCreeperFlipSnapType);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
            {
                bool sellCreeperSetupContinuation = (autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2);
                if (sellCreeperSetupContinuation)
                {
                    entryPrice = CalculateSnapBarLowPrice(BreakEvenAutoCreeperFlipSnapType);
                }
            }


            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, entryPrice);

            return normalizedPrice;
        }

        private double CalculateTrailHighPrice(MarketPosition positionType, bool force1Bar = false)
        {
            double entryPrice = 0;

            if (force1Bar || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
                entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
                entryPrice = Math.Max(previous1HighPrice, previous2HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
                entryPrice = Math.Max(Math.Max(previous1HighPrice, previous2HighPrice), previous3HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(previous1HighPrice, previous2HighPrice), previous3HighPrice), previous4HighPrice), previous5HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMix)
            {
                bool lastTwoCandlesForward = !previous1CandleBullish && !previous2CandleBullish;
                bool lastTwoCandlesBackForwardPlusLower = !previous1CandleBullish && previous2CandleBullish && previous1LowPrice <= previous2LowPrice;

                if (lastTwoCandlesForward || lastTwoCandlesBackForwardPlusLower)
                {
                    entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = 0;
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                entryPrice = GetSpeedLineFilterPrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                entryPrice = GetRushLinePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                entryPrice = GetMovingAverage1Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                entryPrice = GetMovingAverage2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                entryPrice = GetMovingAverage3Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                entryPrice = GetMovingAverage4Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                entryPrice = GetRiver1EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                entryPrice = GetRiver5EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                entryPrice = GetCreek1EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                entryPrice = GetCreek5EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
                entryPrice = GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
            {
                entryPrice = Math.Max(GetZipLine1Price(positionType, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
            {
                if (autoPilotSetupZombieSellContinuation1 && autoPilotSetupZombie2SellContinuation1)
                    entryPrice = Math.Max(GetKineticLine1Price(positionType, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
            {
                if (autoPilotSetupZombieSellContinuation1 && autoPilotSetupZombie2SellContinuation1)
                    entryPrice = Math.Max(Math.Max(Math.Max(GetKineticLine1Price(positionType, AutoCloseAndTrailOffsetTicks),
                        GetKineticLine2Price(positionType, AutoCloseAndTrailOffsetTicks)),
                        GetZipLine1Price(positionType, AutoCloseAndTrailOffsetTicks)),
                        GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                entryPrice = GetRushLinePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                entryPrice = GetDriftLine1Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                entryPrice = GetDriftLine2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                entryPrice = GetDriftLine3Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                entryPrice = GetDriftLine4Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZombieFlip)
            {
                /*
                double zipLine1Price = GetZipLine1Price(positionType, 0);
                double zipLine1Value2Price = GetZipLine1Value2Price(positionType, 0);

                double zipLine2Price = GetZipLine2Price(positionType, 0);
                double zipLine2Value2Price = GetZipLine2Value2Price(positionType, 0);

                double zipLineDualPrice = Math.Max(zipLine1Price, zipLine2Price);
                double zipLineDualValue2Price = Math.Max(zipLine1Value2Price, zipLine2Value2Price);

                bool zipLineFlip = false;

                if (zipLineDualPrice == zipLine1Price)
                {
                    zipLineFlip = zipLine1Value2Price >= previous2ClosePrice && zipLine1Price < previous1ClosePrice;
                }
                else
                {
                    zipLineFlip = zipLine2Value2Price >= previous2ClosePrice && zipLine2Price < previous1ClosePrice;
                }
                */

                bool zombieSetupFlip = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                
                if (zombieSetupFlip)
                {
                    entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
            {
                bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                if (sellZombieSetup)
                {
                    entryPrice = CalculateSnapBarHighPrice(BreakEvenAutoZombieFlipResumeSnapType);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
            {
                bool buyZombieSetupContinuation = autoPilotSetupZombieValue == ZombieSetupBuyCode;
                bool buyCreeperSetupContinuation = (autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2);
                if (buyZombieSetupContinuation && buyCreeperSetupContinuation)
                {
                    entryPrice = CalculateSnapBarHighPrice(BreakEvenAutoCreeperFlipSnapType);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
            {
                bool buyCreeperSetupContinuation = (autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2);
                if (buyCreeperSetupContinuation)
                {
                    entryPrice = CalculateSnapBarHighPrice(BreakEvenAutoCreeperFlipSnapType);
                }
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, entryPrice);

            return normalizedPrice;
        }

        private double CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes stopLossSnapType)
        {
            double entryPrice = 0;

            if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap1Bar)
                entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap2Bar)
                entryPrice = Math.Min(previous1LowPrice, previous2LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap3Bar)
                entryPrice = Math.Min(Math.Min(previous1LowPrice, previous2LowPrice), previous3LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap4Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap5Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap6Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap7Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap8Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap9Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap10Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap11Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap12Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap13Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap14Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap15Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap16Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap17Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice),
                    previous17LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap18Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice),
                    previous17LowPrice),
                    previous18LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap19Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice),
                    previous17LowPrice),
                    previous18LowPrice),
                    previous19LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap20Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice),
                    previous17LowPrice),
                    previous18LowPrice),
                    previous19LowPrice),
                    previous20LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapSpeedLine)
                entryPrice = GetSpeedLineFilterPrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRushLine)
                entryPrice = GetRushLinePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel10)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue10 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel20)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue20 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel30)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue30 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel40)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue40 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel50)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue50 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKeltnerInnerRing)
                entryPrice = GetKeltnerInnerRingPrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRiver1)
                entryPrice = GetRiver1EdgePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRiver5)
                entryPrice = GetRiver5EdgePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapCreek1)
                entryPrice = GetCreek1EdgePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapCreek5)
                entryPrice = GetCreek5EdgePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine1)
                entryPrice = GetZipLine1Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine2)
                entryPrice = GetZipLine2Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine3)
                entryPrice = GetZipLine3Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine4)
                entryPrice = GetZipLine4Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine1)
                entryPrice = GetDriftLine1Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine2)
                entryPrice = GetDriftLine2Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine3)
                entryPrice = GetDriftLine3Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine4)
                entryPrice = GetDriftLine4Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKineticLine1)
                entryPrice = GetKineticLine1Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKineticLine2)
                entryPrice = GetKineticLine2Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel1)
                entryPrice = GetStingRayLevel1Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel2)
                entryPrice = GetStingRayLevel2Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel3)
                entryPrice = GetStingRayLevel3Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel4)
                entryPrice = GetStingRayLevel4Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel5)
                entryPrice = GetStingRayLevel5Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayXLevel)
            {
                const int InitialStopLossOffsetTicks = 5;
                double stingRayLevel1Price = GetStingRayLevel1Price(MarketPosition.Long, InitialStopLossOffsetTicks);
                double stingRayLevel2Price = GetStingRayLevel1Price(MarketPosition.Long, InitialStopLossOffsetTicks);
                double driftLine4Price = GetDriftLine4Price(MarketPosition.Long, InitialStopLossOffsetTicks);

                const double minATRMultiplier = 2.0;
                double atrMinTicks = CalculateATRTicks(atrValue, minATRMultiplier, attachedInstrumentTicksPerPoint);
                double lowestStopLossPrice = stingRayLevel1Price - (atrMinTicks * attachedInstrumentTickSize);

                const double bigATRMultiplier = 4.0;
                double atrBigTicks = CalculateATRTicks(atrValue, bigATRMultiplier, attachedInstrumentTicksPerPoint);
                double bigStopLossPrice = previous1ClosePrice - (atrBigTicks * attachedInstrumentTickSize);


                //Print("*** DEBUG atr1=" + CalculateATRTicks(atrValue, 1, attachedInstrumentTicksPerPoint) + " atr2=" + CalculateATRTicks(atrValue, 2, attachedInstrumentTicksPerPoint) + " atr3=" + CalculateATRTicks(atrValue, 3, attachedInstrumentTicksPerPoint) + " atr4=" + CalculateATRTicks(atrValue, 4, attachedInstrumentTicksPerPoint));

                if (stingRayLevel1Price <= bigStopLossPrice)
                {
                    entryPrice = Math.Max(stingRayLevel1Price, driftLine4Price);
                }
                else if (stingRayLevel1Price < driftLine4Price)
                {
                    //Print("*** DEBUG 1 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = stingRayLevel1Price;
                }
                else if (stingRayLevel2Price >= lowestStopLossPrice && driftLine4Price >= lowestStopLossPrice)
                {
                    //Print("*** DEBUG 2 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = Math.Min(stingRayLevel2Price, driftLine4Price);
                }
                else if (stingRayLevel2Price >= lowestStopLossPrice)
                {
                    //Print("*** DEBUG 3 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = stingRayLevel2Price;
                }
                else if (driftLine4Price >= lowestStopLossPrice)
                {
                    //Print("*** DEBUG 4 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = driftLine4Price;
                }
                else
                {
                    //Print("*** DEBUG 5 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = stingRayLevel1Price;
                }
            }
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapProfilePeppy)
            {
                if (recentZombieBuyLowPrice != 0 && recentCreeperBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(Math.Min(recentZombieBuyLowPrice, recentCreeperBuyLowPrice), previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else if (recentZombieBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(recentZombieBuyLowPrice, previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentCreeperBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(recentCreeperBuyLowPrice, previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapProfileSleepy)
            {
                if (recentZombieBuyLowPrice != 0 && recentCreeperBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(Math.Min(recentZombieBuyLowPrice, recentCreeperBuyLowPrice), previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else if (recentZombieBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(recentZombieBuyLowPrice, previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentCreeperBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(recentCreeperBuyLowPrice, previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, entryPrice);

            return normalizedPrice;
        }

        private double CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes stopLossSnapType)
        {
            double entryPrice = 0;

            if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap1Bar)
                entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap2Bar)
                entryPrice = Math.Max(previous1HighPrice, previous2HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap3Bar)
                entryPrice = Math.Max(Math.Max(previous1HighPrice, previous2HighPrice), previous3HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap4Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap5Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap6Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap7Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap8Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap9Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap10Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap11Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap12Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap13Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap14Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap15Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap16Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap17Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice),
                    previous17HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap18Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice),
                    previous17HighPrice),
                    previous18HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap19Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice),
                    previous17HighPrice),
                    previous18HighPrice),
                    previous19HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap20Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice),
                    previous17HighPrice),
                    previous18HighPrice),
                    previous19HighPrice),
                    previous20HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapSpeedLine)
                entryPrice = GetSpeedLineFilterPrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRushLine)
                entryPrice = GetRushLinePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel10)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue10 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel20)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue20 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel30)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue30 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel40)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue40 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel50)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue50 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKeltnerInnerRing)
                entryPrice = GetKeltnerInnerRingPrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRiver1)
                entryPrice = GetRiver1EdgePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRiver5)
                entryPrice = GetRiver5EdgePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapCreek1)
                entryPrice = GetCreek1EdgePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapCreek5)
                entryPrice = GetCreek5EdgePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine1)
                entryPrice = GetZipLine1Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine2)
                entryPrice = GetZipLine2Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine3)
                entryPrice = GetZipLine3Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine4)
                entryPrice = GetZipLine4Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine1)
                entryPrice = GetDriftLine1Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine2)
                entryPrice = GetDriftLine2Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine3)
                entryPrice = GetDriftLine3Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine4)
                entryPrice = GetDriftLine4Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKineticLine1)
                entryPrice = GetKineticLine1Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKineticLine2)
                entryPrice = GetKineticLine2Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel1)
                entryPrice = GetStingRayLevel1Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel2)
                entryPrice = GetStingRayLevel2Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel3)
                entryPrice = GetStingRayLevel3Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel4)
                entryPrice = GetStingRayLevel4Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel5)
                entryPrice = GetStingRayLevel5Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayXLevel)
            {
                const int InitialStopLossOffsetTicks = 5;
                double stingRayLevel1Price = GetStingRayLevel1Price(MarketPosition.Short, InitialStopLossOffsetTicks);
                double stingRayLevel2Price = GetStingRayLevel1Price(MarketPosition.Short, InitialStopLossOffsetTicks);
                double driftLine4Price = GetDriftLine4Price(MarketPosition.Short, InitialStopLossOffsetTicks);

                const double minATRMultiplier = 2.0;
                double atrMinTicks = CalculateATRTicks(atrValue, minATRMultiplier, attachedInstrumentTicksPerPoint);
                double lowestStopLossPrice = stingRayLevel1Price + (atrMinTicks * attachedInstrumentTickSize);

                const double bigATRMultiplier = 4.0;
                double atrBigTicks = CalculateATRTicks(atrValue, bigATRMultiplier, attachedInstrumentTicksPerPoint);
                double bigStopLossPrice = previous1ClosePrice + (atrBigTicks * attachedInstrumentTickSize);

                if (stingRayLevel1Price >= bigStopLossPrice)
                {
                    entryPrice = Math.Min(stingRayLevel1Price, driftLine4Price);
                }
                else if (stingRayLevel1Price > driftLine4Price)
                {
                    entryPrice = stingRayLevel1Price;
                }
                else if (stingRayLevel2Price <= lowestStopLossPrice && driftLine4Price <= lowestStopLossPrice)
                {
                    entryPrice = Math.Max(stingRayLevel2Price, driftLine4Price);
                }
                else if (stingRayLevel2Price <= lowestStopLossPrice)
                {
                    entryPrice = stingRayLevel2Price;
                }
                else if (driftLine4Price <= lowestStopLossPrice)
                {
                    entryPrice = driftLine4Price;
                }
                else
                {
                    entryPrice = stingRayLevel1Price;
                }
            }
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapProfilePeppy)
            {
                if (recentZombieSellHighPrice != 0 && recentCreeperSellHighPrice != 0)
                {
                    entryPrice = Math.Max(Math.Max(recentZombieSellHighPrice, recentCreeperSellHighPrice), previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentZombieSellHighPrice != 0)
                {
                    entryPrice = Math.Max(recentZombieSellHighPrice, previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentCreeperSellHighPrice != 0)
                {
                    entryPrice = Math.Max(recentCreeperSellHighPrice, previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapProfileSleepy)
            {
                if (recentZombieSellHighPrice != 0 && recentCreeperSellHighPrice != 0)
                {
                    entryPrice = Math.Max(Math.Max(recentZombieSellHighPrice, recentCreeperSellHighPrice), previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentZombieSellHighPrice != 0)
                {
                    entryPrice = Math.Max(recentZombieSellHighPrice, previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentCreeperSellHighPrice != 0)
                {
                    entryPrice = Math.Max(recentCreeperSellHighPrice, previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, entryPrice);

            return normalizedPrice;
        }

        private double GetZipLine1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetZipLine1Value2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL1Value2 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL1Value2 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetZipLine2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }
        private double GetZipLine2Value2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL2Value2 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL2Value2 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetZipLine3Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }
        private double GetZipLine3Value2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL3Value2 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL3Value2 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetZipLine4Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }
        private double GetZipLine4Value2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL4Value2 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL4Value2 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetStingRayLevel1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(stingRayLowLevel1Value, previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(stingRayHighLevel1Value, previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetStingRayLevel2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(Math.Min(stingRayLowLevel2Value, stingRayLowLevel1Value), previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(Math.Max(stingRayHighLevel2Value, stingRayHighLevel1Value), previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetStingRayLevel3Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(Math.Min(Math.Min(stingRayLowLevel3Value, stingRayLowLevel2Value), stingRayLowLevel1Value), previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(Math.Max(Math.Max(stingRayHighLevel3Value, stingRayHighLevel2Value), stingRayHighLevel1Value), previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetStingRayLevel4Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(Math.Min(Math.Min(Math.Min(stingRayLowLevel4Value, stingRayLowLevel3Value), stingRayLowLevel2Value), stingRayLowLevel1Value), previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(Math.Max(Math.Max(Math.Max(stingRayHighLevel4Value, stingRayHighLevel3Value), stingRayHighLevel2Value), stingRayHighLevel1Value), previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetStingRayLevel5Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(stingRayLowLevel5Value, stingRayLowLevel4Value), stingRayLowLevel3Value), stingRayLowLevel2Value), stingRayLowLevel1Value), previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(stingRayHighLevel5Value, stingRayHighLevel4Value), stingRayHighLevel3Value), stingRayHighLevel2Value), stingRayHighLevel1Value), previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetRushLinePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailRLValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailRLValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetDriftLine1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetDriftLine2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetDriftLine3Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetDriftLine4Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetKineticLine1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailKLine1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailKLine1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetKineticLine2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailKLine2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailKLine2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetSpeedLineFilterPrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoPilotSpeedLineFilterValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoPilotSpeedLineFilterValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetMovingAverage1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailMA1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailMA1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetMovingAverage2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailMA2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailMA2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetMovingAverage3Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailMA3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailMA3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetMovingAverage4Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailMA4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailMA4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetKeltnerInnerRingPrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(keltnerLowerInnerRingValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(keltnerUpperInnerRingValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetRiver1EdgePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailR1LValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailR1HValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetRiver5EdgePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailR5LValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailR5HValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetCreek1EdgePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL3LValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL3HValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetCreek5EdgePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL4LValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL4HValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }


        private bool CheckSnapPositionTPSL()
        {
            bool returnFlag = true; // UseSnapPositionTPSL;

            return returnFlag;
        }

        private int CalculateStopLossTicks(MarketPosition marketPosition, double averagePrice, double stopLossPrice, double tickSize)
        {
            int stopLossTicks = 0;

            if (averagePrice > 0 && stopLossPrice > 0)
            {
                bool isBuyPosition = (marketPosition == MarketPosition.Long);

                if (isBuyPosition)
                {
                    stopLossTicks = (int)Math.Floor((stopLossPrice - averagePrice) / tickSize);
                }
                else
                {
                    stopLossTicks = (int)Math.Ceiling((averagePrice - stopLossPrice) / tickSize);
                }

                if (stopLossTicks < 0)
                {
                    stopLossTicks *= -1;
                }
            }

            return stopLossTicks;

        }

        private bool GetPopDropOrderCount(out int buyCount, out int sellCount)
        {
            bool orderFound = false;
            buyCount = 0;
            sellCount = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                        || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                    {
                        if (!Order.IsTerminalState(order.OrderState))
                        {
                            if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy))
                            {
                                orderFound = true;
                                buyCount++;
                            }
                            else if (RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell))
                            {
                                orderFound = true;
                                sellCount++;
                            }

                        }
                    }
                }
            }


            return orderFound;
        }


        private void LoadNinjaTraderOrders()
        {
            if (!IsNinjaTraderOrdersAlreadyLoaded)
            {
                lock (account.Orders)
                {
                    if (!IsNinjaTraderOrdersAlreadyLoaded)
                    {
                        ninjaTraderOrders.Clear();

                        foreach (Order orderItem in account.Orders)
                        {
                            if (!Order.IsTerminalState(orderItem.OrderState))
                            {
                                ninjaTraderOrders.Add(orderItem.Id, orderItem);
                            }
                        }

                        IsNinjaTraderOrdersAlreadyLoaded = true;
                    }
                }
            }
        }

        private Order GetNinjaTraderOrder(RealOrder order)
        {
            LoadNinjaTraderOrders();

            Order foundOrder = null;

            ninjaTraderOrders.TryGetValue(order.OrderId, out foundOrder);

            return foundOrder;
        }

        private bool CancelPopDropOrders(string signalName)
        {
            bool orderFound = false;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                        || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                    {
                        orderFound = true;

                        if (!Order.IsTerminalState(order.OrderState))
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                            Order foundNTOrder = GetNinjaTraderOrder(order);

                            if (foundNTOrder != null)
                            {
                                try
                                {
                                    account.Cancel(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in " + signalName + ":" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                        }

                    }
                }
            }

            return orderFound;
        }

        private bool HandleBuySnap(string signalName)
        {
            double newBuySnapPrice = 0;
            bool positionFound = false;
            bool isLongPosition = false;
            bool orderFound = false;
            double oldStopLossPrice = 0;
            int stopLossOrderCount = 0;
            double takeProfitPrice = 0;
            OrderType orderType = OrderType.Unknown;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;
                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    //if (position.Instrument == attachedInstrument)
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        isLongPosition = (position.MarketPosition == MarketPosition.Long);
                        positionFound = true;

                        int oldOrderQuantity = 0;
                        stopLossOrderCount = 0;

                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        int stopLossTicks = CalculateStopLossTicks(position.MarketPosition, position.AveragePrice, oldStopLossPrice, attachedInstrumentTickSize);
                        int stopLossMultipliedTicks = (int)(stopLossTicks * TakeProfitCtrlSLMultiplier);
                        takeProfitPrice = CalculateTakeProfitPrice(position.MarketPosition, position.AveragePrice, stopLossMultipliedTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

                        break;
                    }
                }
            }

            if (!isLongPosition && positionFound && CheckSnapPositionTPSL())
            {
                if (takeProfitPrice > 0)
                {
                    HandleTakeProfitPlus("BuySnap", takeProfitPrice);
                }

                positionFound = false;
            }
            else if (isLongPosition && positionFound && CheckSnapPositionTPSL())
            {
                TrailBuyPositionStopLoss("BuySnap", true);
            }
            else if (!positionFound || !CheckSnapPositionTPSL())
            {
                orderFound = CancelPopDropOrders("BuySnap");

                if (!orderFound)
                {
                    newBuySnapPrice = CalculateTrailHighPrice(MarketPosition.Long, true);

                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                    if (newBuySnapPrice <= askPrice)
                    {
                        newBuySnapPrice = 0;
                    }


                    if (newBuySnapPrice != 0)
                    {
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("New Snap+ price=" + newBuySnapPrice.ToString() + " via " + signalName);
                        int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                        CreateBuyStop(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, autoEntryVolume, newBuySnapPrice);
                    }
                }

            }

            return positionFound;
        }

        private bool HandleBuyMarket(string signalName)
        {
            bool buyMarketSucceeded = false;

            if (HasRanOnceFirstCycle() && RealOrderService.AreAllOrderUpdateCyclesComplete())
            {
                const OrderAction orderAction = OrderAction.Buy;
                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);

                int autoEntryincrementVolumeSize = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);

                if (KeyboardManager.IsCtrlKeyDown() && KeyboardManager.IsShiftKeyDown() && limitTrancheVolumeToInProfitFlag) autoEntryincrementVolumeSize = maxInitialTrancheVolumeSize;

                int limitedIncrementVolumeSize = GetLimitedIncrementVolumeSize(autoEntryincrementVolumeSize, maxInitialTrancheVolumeSize, limitTrancheVolumeToInProfitFlag);

                int buyPositionVolumeSize = 0;
                double buyPositionPrice = 0;
                int sellPositionVolumeSize = 0;
                double sellPositionPrice = 0;
                DateTime positionModifyDate = DateTime.MinValue;

                bool hasPosition = GetPositionVolume(attachedInstrument, out buyPositionVolumeSize, out buyPositionPrice, out sellPositionVolumeSize, out sellPositionPrice, out positionModifyDate);
                bool hasBuyPosition = buyPositionVolumeSize > 0;
                double positionPrice = buyPositionPrice;
                bool isValidPositionMaxVolume = attachedInstrumentPositionMaxVolume > 0;

                bool passedLimitTrancheVolume = false;

                bool bypassEntryLimits = KeyboardManager.IsCtrlKeyDown();

                if (limitTrancheVolumePerBarFlag && !bypassEntryLimits)
                {
                    // When MaxInitialTrancheVolumeSize >= 1, only apply delay when position is a multiple of MaxInitialTrancheVolumeSize
                    bool shouldCheckDelay = false;
                    if (maxInitialTrancheVolumeSize >= 1 && MinTrancheVolumeDelaySeconds > 0)
                    {
                        // Check if current position size is greater than 0 and is a multiple of MaxInitialTrancheVolumeSize
                        if (buyPositionVolumeSize > 0 && buyPositionVolumeSize % maxInitialTrancheVolumeSize == 0)
                        {
                            shouldCheckDelay = true;
                        }
                    }
                    else
                    {
                        // Original behavior when MaxInitialTrancheVolumeSize < 1
                        shouldCheckDelay = true;
                    }

                    if (shouldCheckDelay)
                    {
                    bool pastTrancheVolumeDelay = positionModifyDate.AddSeconds(MinTrancheVolumeDelaySeconds) <= GetDateTimeNow();

                    if (pastTrancheVolumeDelay)
                    {
                            passedLimitTrancheVolume = true;
                        }
                    }
                    else
                    {
                        // No delay needed when position is not a multiple of MaxInitialTrancheVolumeSize
                        passedLimitTrancheVolume = true;
                    }
                }
                else
                {
                    passedLimitTrancheVolume = true;
                }

                bool isOverVolumePositionMax = limitedIncrementVolumeSize > attachedInstrumentPositionMaxVolume
                    || (limitedIncrementVolumeSize + buyPositionVolumeSize) > attachedInstrumentPositionMaxVolume;

                if ((!isOverVolumePositionMax && isValidPositionMaxVolume) || (isOverVolumePositionMax && !isValidPositionMaxVolume))
                {
                    bool passedMarginCheck = OrderMarginCheck(attachedInstrument, UseIntradayMarginCheck, orderAction, limitedIncrementVolumeSize, buyPositionVolumeSize, sellPositionVolumeSize);

                    if (passedMarginCheck)
                    {
                        bool isReducingPostion = (hasPosition && !hasBuyPosition);

                        if (passedLimitTrancheVolume || isReducingPostion)
                        {
                            if ((!limitTrancheVolumeToInProfitFlag && !LimitToVolumeMaxOption) || isReducingPostion)
                            {
                                RealLogger.PrintOutput("Send buy order at price (" + askPrice.ToString() + ")" + " via " + signalName);

                                ReducePositionTakeProfitVolume(signalName, sellPositionVolumeSize, autoEntryincrementVolumeSize);

                                SubmitMarketOrder(signalName, attachedInstrument, orderAction, OrderEntry.Manual, autoEntryincrementVolumeSize);
                                buyMarketSucceeded = true;
                            }
                            else
                            {
                                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);

                                bool positionInProfit = attachedInstrumentPositionPnL > 0;  //bidPrice >= positionPrice;
                                int newVolumeSize = DEFAULT_VOLUME_SIZE;

                                if (bypassEntryLimits) positionInProfit = true;

                                if (TryGetLimitTrancheVolumeSize(buyPositionVolumeSize, positionInProfit, autoEntryincrementVolumeSize, out newVolumeSize))
                                {
                                    RealLogger.PrintOutput("Send buy order at price (" + askPrice.ToString() + ")" + " via " + signalName);

                                    ReducePositionTakeProfitVolume(signalName, sellPositionVolumeSize, newVolumeSize);

                                    SubmitMarketOrder(signalName, attachedInstrument, orderAction, OrderEntry.Manual, newVolumeSize);
                                    buyMarketSucceeded = true;
                                }
                                else
                                {
                                    if (LimitToVolumeMaxOption)
                                    {
                                        RealLogger.PrintOutput("BLOCKED buy order due to LimitToVolumeMaxOption(" + limitedVolumeMaxSize.ToString("N0") + ") where position price at (" + positionPrice
                                            + ") must be less than market price at (" + askPrice + ")" + " via " + signalName);  
                                    }
                                    else
                                    {
                                        RealLogger.PrintOutput("BLOCKED buy order due to LimitTrancheVolumeToInProfit(" + maxInitialTrancheVolumeSize.ToString("N0") + ") where position price at (" + positionPrice
                                            + ") must be less than market price at (" + askPrice + ")" + " via " + signalName);
                                    }
                                }
                            }
                        }
                        else
                        {
                            RealLogger.PrintOutput("BLOCKED buy order due to LimitTrancheVolumePerBar(" + MinTrancheVolumeDelaySeconds.ToString("N0") + " sec) via " + signalName);
                        }
                    }
                    else
                    {
                        double intradayMargin = attachedInstrumentIntradayMarginDollars;
                        RealLogger.PrintOutput("BLOCKED: Buy volume attempt greater than margin allowed.  limitedIncrementVolumeSize=" + limitedIncrementVolumeSize.ToString("N0") + " intradayMargin=" + intradayMargin + " via " + signalName);
                    }
                }
                else
                {
                    RealLogger.PrintOutput("BLOCKED: Buy volume attempt greater than instrument position max volume.  attachedInstrumentPositionMaxVolume="
                        + attachedInstrumentPositionMaxVolume + " limitedIncrementVolumeSize=" + limitedIncrementVolumeSize.ToString("N0") + " via " + signalName);
                }
            }

            return buyMarketSucceeded;
        }

        private bool HandleSellMarket(string signalName)
        {
            bool sellMarketSucceeded = false;

            if (HasRanOnceFirstCycle() && RealOrderService.AreAllOrderUpdateCyclesComplete())
            {
                const OrderAction orderAction = OrderAction.Sell;
                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);

                int autoEntryincrementVolumeSize = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);

                if (KeyboardManager.IsCtrlKeyDown() && KeyboardManager.IsShiftKeyDown() && limitTrancheVolumeToInProfitFlag) autoEntryincrementVolumeSize = maxInitialTrancheVolumeSize;

                int limitedIncrementVolumeSize = GetLimitedIncrementVolumeSize(autoEntryincrementVolumeSize, maxInitialTrancheVolumeSize, limitTrancheVolumeToInProfitFlag);

                int buyPositionVolumeSize = 0;
                double buyPositionPrice = 0;
                int sellPositionVolumeSize = 0;
                double sellPositionPrice = 0;
                DateTime positionModifyDate = DateTime.MinValue;

                bool hasPosition = GetPositionVolume(attachedInstrument, out buyPositionVolumeSize, out buyPositionPrice, out sellPositionVolumeSize, out sellPositionPrice, out positionModifyDate);
                bool hasSellPosition = sellPositionVolumeSize > 0;
                double positionPrice = sellPositionPrice;
                bool isValidPositionMaxVolume = attachedInstrumentPositionMaxVolume > 0;

                bool passedLimitTrancheVolume = false;

                bool bypassEntryLimits = KeyboardManager.IsCtrlKeyDown();

                if (limitTrancheVolumePerBarFlag && !bypassEntryLimits)
                {
                    // When MaxInitialTrancheVolumeSize >= 1, only apply delay when position is a multiple of MaxInitialTrancheVolumeSize
                    bool shouldCheckDelay = false;
                    if (maxInitialTrancheVolumeSize >= 1 && MinTrancheVolumeDelaySeconds > 0)
                    {
                        // Check if current position size is greater than 0 and is a multiple of MaxInitialTrancheVolumeSize
                        if (sellPositionVolumeSize > 0 && sellPositionVolumeSize % maxInitialTrancheVolumeSize == 0)
                        {
                            shouldCheckDelay = true;
                        }
                    }
                    else
                    {
                        // Original behavior when MaxInitialTrancheVolumeSize < 1
                        shouldCheckDelay = true;
                    }

                    if (shouldCheckDelay)
                {
                    bool pastTrancheVolumeDelay = positionModifyDate.AddSeconds(MinTrancheVolumeDelaySeconds) <= GetDateTimeNow();

                    if (pastTrancheVolumeDelay)
                    {
                            passedLimitTrancheVolume = true;
                        }
                    }
                    else
                    {
                        // No delay needed when position is not a multiple of MaxInitialTrancheVolumeSize
                        passedLimitTrancheVolume = true;
                    }
                }
                else
                {
                    passedLimitTrancheVolume = true;
                }

                bool isOverVolumePositionMax = limitedIncrementVolumeSize > attachedInstrumentPositionMaxVolume
                    || (limitedIncrementVolumeSize + sellPositionVolumeSize) > attachedInstrumentPositionMaxVolume;

                if ((!isOverVolumePositionMax && isValidPositionMaxVolume) || (isOverVolumePositionMax && !isValidPositionMaxVolume))
                {
                    bool passedMarginCheck = OrderMarginCheck(attachedInstrument, UseIntradayMarginCheck, orderAction, limitedIncrementVolumeSize, buyPositionVolumeSize, sellPositionVolumeSize);

                    if (passedMarginCheck)
                    {
                        bool isReducingPostion = (hasPosition && !hasSellPosition);

                        if (passedLimitTrancheVolume || isReducingPostion)
                        {
                            if ((!limitTrancheVolumeToInProfitFlag && !LimitToVolumeMaxOption) || isReducingPostion)
                            {
                                RealLogger.PrintOutput("Send sell order at price (" + bidPrice.ToString() + ")" + " via " + signalName);

                                ReducePositionTakeProfitVolume(signalName, buyPositionVolumeSize, autoEntryincrementVolumeSize);

                                SubmitMarketOrder(signalName, attachedInstrument, orderAction, OrderEntry.Manual, autoEntryincrementVolumeSize);
                                sellMarketSucceeded = true;
                            }
                            else
                            {
                                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);

                                bool positionInProfit = attachedInstrumentPositionPnL > 0; //askPrice <= positionPrice;
                                int newVolumeSize = DEFAULT_VOLUME_SIZE;

                                if (bypassEntryLimits) positionInProfit = true;

                                if (TryGetLimitTrancheVolumeSize(sellPositionVolumeSize, positionInProfit, autoEntryincrementVolumeSize, out newVolumeSize))
                                {
                                    RealLogger.PrintOutput("Send sell order at price (" + bidPrice.ToString() + ")" + " via " + signalName);

                                    ReducePositionTakeProfitVolume(signalName, buyPositionVolumeSize, newVolumeSize);

                                    SubmitMarketOrder(signalName, attachedInstrument, orderAction, OrderEntry.Manual, newVolumeSize);
                                    sellMarketSucceeded = true;
                                }
                                else
                                {
                                    if (LimitToVolumeMaxOption)
                                    {
                                        RealLogger.PrintOutput("BLOCKED sell order due to LimitToVolumeMaxOption(" + limitedVolumeMaxSize.ToString("N0") + ") where position price at (" + positionPrice
                                            + ") must be greater than market price at (" + bidPrice + ")" + " via " + signalName);
                                    }
                                    else
                                    {
                                        RealLogger.PrintOutput("BLOCKED sell order due to LimitTrancheVolumeToInProfit(" + maxInitialTrancheVolumeSize.ToString("N0") + ") where position price at (" + positionPrice
                                            + ") must be greater than market price at (" + bidPrice + ")" + " via " + signalName);
                                    }
                                }
                            }
                        }
                        else
                        {
                            RealLogger.PrintOutput("BLOCKED sell order due to LimitTrancheVolumePerBar(" + MinTrancheVolumeDelaySeconds.ToString("N0") + " sec) via " + signalName);
                        }
                    }
                    else
                    {
                        double intradayMargin = attachedInstrumentIntradayMarginDollars;
                        RealLogger.PrintOutput("BLOCKED: Sell volume attempt greater than margin allowed.  limitedIncrementVolumeSize=" + limitedIncrementVolumeSize.ToString("N0") + " intradayMargin=" + intradayMargin + " via " + signalName);
                    }
                }
                else
                {
                    RealLogger.PrintOutput("BLOCKED: Sell volume attempt greater than instrument position max volume.  attachedInstrumentPositionMaxVolume="
                        + attachedInstrumentPositionMaxVolume + " limitedIncrementVolumeSize=" + limitedIncrementVolumeSize.ToString("N0") + " via " + signalName);
                }
            }

            return sellMarketSucceeded;
        }

        private void ReducePositionTakeProfitVolume(string signalName, int positionVolumeSize, int reduceVolumeSize)
        {
            if (TakeProfitRefreshManagementEnabled)
            {
                bool hasTakeProfit = attachedInstrumentPositionTakeProfitPrice > 0;
                bool isValidPositionMaxVolume = attachedInstrumentPositionMaxVolume > 0;

                if (hasTakeProfit && isValidPositionMaxVolume)
                {
                    int potentialNewVolumeSize = (reduceVolumeSize + positionVolumeSize);
                    bool isOverTotalVolumePositionMax = potentialNewVolumeSize > attachedInstrumentPositionMaxVolume;
                    int volumeOverMax = potentialNewVolumeSize - attachedInstrumentPositionMaxVolume;

                    if (isOverTotalVolumePositionMax)
                    {
                        int newVolumeSize = attachedInstrumentPositionMaxVolume - reduceVolumeSize;
                        bool isValidNewVolumeSize = newVolumeSize > 0;
                        OrderAction takeProfitOrderAction = ConvertMarketPositionToTPOrderAction(attachedInstrumentMarketPosition);
                        double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                        bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(attachedInstrument, takeProfitOrderAction, attachedInstrumentPositionTakeProfitPrice, lastPrice);

                        if (isPriceValid && isValidNewVolumeSize)
                        {
                            UpdatePositionTakeProfit(signalName, attachedInstrument, takeProfitOrderAction, OrderEntry.Manual, newVolumeSize, attachedInstrumentPositionTakeProfitPrice);
                        }
                    }
                }
            }
        }

        private bool HandleBuyPop(string signalName, bool onlyCancelSellPopOrder = false)
        {
            bool returnFlag = false;
            bool buyOrderFound = false;
            bool sellOrderFound = false;
            double oldPopPrice = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                        || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                    {
                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover))
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                buyOrderFound = true;
                                oldPopPrice = order.StopPrice;
                            }
                        }

                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.SellShort)
                            || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)
                            || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy))
                        {
                            sellOrderFound = true;
                        }

                        if (sellOrderFound)
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                                Order foundNTOrder = GetNinjaTraderOrder(order);

                                if (foundNTOrder != null)
                                {
                                    try
                                    {
                                        account.Cancel(new[] { foundNTOrder });
                                    }
                                    catch (Exception ex)
                                    {
                                        RealLogger.PrintOutput("Exception in HandleBuyPop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (onlyCancelSellPopOrder)
                returnFlag = sellOrderFound;
            else
                returnFlag = buyOrderFound;

            if (!onlyCancelSellPopOrder)
            {

                if (!buyOrderFound && !sellOrderFound)
                {
                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                    double highestPrice = askPrice;
                    if (UsePopAutoJumpToSnap)
                    {
                        double highPrice = CalculateTrailHighPrice(MarketPosition.Long, true);
                        highestPrice = Math.Max(askPrice, highPrice);
                    }

                    double newPopPrice = GetInitialPopPrice(MarketPosition.Long, highestPrice);

                    if (newPopPrice <= askPrice)
                    {
                        newPopPrice = 0;
                    }

                    if (newPopPrice != 0)
                    {
                        bool passedPullBackCheck = false;

                        if (popLimitToPullbackFlag)
                        {
                            bool isCTRLKeyDown = KeyboardManager.IsCtrlKeyDown();
                            bool popDelayedEntry = (!popCTRLDelayedEntryFlag && isCTRLKeyDown);
                            bool isValidPullback = IsInValidBuyPopPullBack();

                            if (isValidPullback || popDelayedEntry)
                            {
                                passedPullBackCheck = true;

                                if (!isValidPullback && popDelayedEntry)
                                    RealLogger.PrintOutput("BYPASSED UsePopLimitToPullback where previous candle must be bearish for buy pop order" + " via " + signalName);
                            }
                            else
                            {
                                RealLogger.PrintOutput("BLOCKED buy pop order due to UsePopLimitToPullback where previous candle must be bearish" + " via " + signalName);
                            }
                        }
                        else
                        {
                            passedPullBackCheck = true;
                        }

                        if (passedPullBackCheck)
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("New Pop+ price=" + newPopPrice.ToString() + " via " + signalName);
                            int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                            if (KeyboardManager.IsCtrlKeyDown() && KeyboardManager.IsShiftKeyDown()) autoEntryVolume = maxInitialTrancheVolumeSize;

                            CreateBuyStop(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                        }
                    }
                }
                else if (buyOrderFound && !sellOrderFound)
                {
                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                    double newPopPrice = GetPopPriceFromJumpTicks(MarketPosition.Long, oldPopPrice, this.PopJumpTicks);

                    if (newPopPrice <= bidPrice || newPopPrice <= lastPrice)
                    {
                        newPopPrice = 0;
                    }

                    if (newPopPrice != 0)
                    {
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update Pop+ price=" + newPopPrice.ToString() + " via " + signalName);
                        UpdateStopOrder(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, newPopPrice);
                    }
                }
            }

            return returnFlag;
        }

        private bool HandleSellPop(string signalName, bool onlyCancelBuyPopOrder = false)
        {
            bool returnFlag = false;
            bool buyOrderFound = false;
            bool sellOrderFound = false;
            double oldPopPrice = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                        || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                    {
                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.SellShort))
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                sellOrderFound = true;
                                oldPopPrice = order.StopPrice;
                            }
                        }

                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover)
                            || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy)
                            || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell))
                        {
                            buyOrderFound = true;
                        }

                        if (buyOrderFound)
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                                Order foundNTOrder = GetNinjaTraderOrder(order);

                                if (foundNTOrder != null)
                                {
                                    try
                                    {
                                        account.Cancel(new[] { foundNTOrder });
                                    }
                                    catch (Exception ex)
                                    {
                                        RealLogger.PrintOutput("Exception in HandleSellPop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (onlyCancelBuyPopOrder)
                returnFlag = buyOrderFound;
            else
                returnFlag = sellOrderFound;

            if (!onlyCancelBuyPopOrder)
            {

                if (!sellOrderFound && !buyOrderFound)
                {
                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                    double lowestPrice = bidPrice;
                    if (UsePopAutoJumpToSnap)
                    {
                        double lowPrice = CalculateTrailLowPrice(MarketPosition.Short, true);
                        lowestPrice = Math.Min(bidPrice, lowPrice);
                    }

                    double newPopPrice = GetInitialPopPrice(MarketPosition.Short, lowestPrice);

                    if (newPopPrice >= bidPrice)
                    {
                        newPopPrice = 0;
                    }


                    if (newPopPrice != 0)
                    {
                        bool passedPullBackCheck = false;

                        if (popLimitToPullbackFlag)
                        {
                            bool isCTRLKeyDown = KeyboardManager.IsCtrlKeyDown();
                            bool popDelayedEntry = (!popCTRLDelayedEntryFlag && isCTRLKeyDown);
                            bool isValidPullback = IsInValidSellPopPullBack();

                            if (isValidPullback || popDelayedEntry)
                            {
                                passedPullBackCheck = true;

                                if (!isValidPullback && popDelayedEntry)
                                    RealLogger.PrintOutput("BYPASSED UsePopLimitToPullback where previous candle must be bullish for sell pop order" + " via " + signalName);
                            }
                            else
                            {
                                RealLogger.PrintOutput("BLOCKED sell pop order due to UsePopLimitToPullback where previous candle must be bullish" + " via " + signalName);
                            }
                        }
                        else
                        {
                            passedPullBackCheck = true;
                        }

                        if (passedPullBackCheck)
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("New Pop- price=" + newPopPrice.ToString() + " via " + signalName);
                            int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                            if (KeyboardManager.IsCtrlKeyDown() && KeyboardManager.IsShiftKeyDown()) autoEntryVolume = maxInitialTrancheVolumeSize;
                            
                            CreateSellStop(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                        }
                    }
                }
                else if (sellOrderFound && !buyOrderFound)
                {
                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                    double newPopPrice = GetPopPriceFromJumpTicks(MarketPosition.Short, oldPopPrice, this.PopJumpTicks);

                    if (newPopPrice >= askPrice || newPopPrice >= lastPrice)
                    {
                        newPopPrice = 0;
                    }

                    if (newPopPrice != 0)
                    {
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update Pop- price=" + newPopPrice.ToString() + " via " + signalName);
                        UpdateStopOrder(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, newPopPrice);
                    }
                }
            }

            return returnFlag;
        }


        private bool IsInValidBuyPopPullBack()
        {
            bool passedPullBackCheck = false;

            //bool altBuyZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
            //bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;

            if (!previous1CandleBullish)// || altBuyZombieSetup1 || altBuyCreeperSetup1)
            {
                passedPullBackCheck = true;
            }

            return passedPullBackCheck;
        }

        private bool IsInValidSellPopPullBack()
        {
            bool passedPullBackCheck = false;

            //bool altSellZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
            //bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;

            if (previous1CandleBullish)// || altSellZombieSetup1 || altSellCreeperSetup1)
            {
                passedPullBackCheck = true;
            }

            return passedPullBackCheck;
        }


        private bool HandleBuyDrop(string signalName)
        {
            bool buyOrderFound = false;
            bool sellOrderFound = false;
            double oldDropPrice = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy)
                        || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)
                        || RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)))
                    {
                        if (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy))
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                buyOrderFound = true;
                                oldDropPrice = order.LimitPrice;
                            }
                        }

                        if (RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)
                            || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                            || RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover))
                        {
                            sellOrderFound = true;
                        }

                        if (sellOrderFound)
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                                Order foundNTOrder = GetNinjaTraderOrder(order);

                                if (foundNTOrder != null)
                                {

                                    try
                                    {
                                        account.Cancel(new[] { foundNTOrder });
                                    }
                                    catch (Exception ex)
                                    {
                                        RealLogger.PrintOutput("Exception in HandleBuyDrop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                    }
                                }
                            }
                        }
                    }
                }
            }


            if (!buyOrderFound && !sellOrderFound)
            {
                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                double lowestPrice = bidPrice;
                if (UseDropAutoJumpToSnap)
                {
                    double lowPrice = CalculateTrailLowPrice(MarketPosition.Long, true);
                    lowestPrice = Math.Min(bidPrice, lowPrice);
                }

                double newDropPrice = GetInitialDropPrice(MarketPosition.Long, lowestPrice);

                if (newDropPrice >= bidPrice)
                {
                    newDropPrice = 0;
                }


                if (newDropPrice != 0)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New Drop+ price=" + newDropPrice.ToString() + " via " + signalName);
                    int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                    CreateBuyLimit(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, autoEntryVolume, newDropPrice);
                }
            }
            else if (buyOrderFound && !sellOrderFound)
            {
                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                double newDropPrice = GetDropPriceFromJumpTicks(MarketPosition.Long, oldDropPrice, this.DropJumpTicks);

                if (newDropPrice >= askPrice || newDropPrice >= lastPrice)
                {
                    newDropPrice = 0;
                }

                if (newDropPrice != 0)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Update Drop+ price=" + newDropPrice.ToString() + " lastPrice=" + lastPrice.ToString() + " askPrice=" + askPrice.ToString() + " via " + signalName);
                    UpdateLimitOrder(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, newDropPrice);
                }

            }

            return buyOrderFound;
        }

        private bool HandleSellDrop(string signalName)
        {
            bool buyOrderFound = false;
            bool sellOrderFound = false;
            double oldDropPrice = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)
                        || RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)))
                    {
                        if (RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell))
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                sellOrderFound = true;
                                oldDropPrice = order.LimitPrice;
                            }
                        }

                        if (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy)
                            || RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover)
                            || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort))
                        {
                            buyOrderFound = true;
                        }

                        if (buyOrderFound)
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                                Order foundNTOrder = GetNinjaTraderOrder(order);

                                if (foundNTOrder != null)
                                {

                                    try
                                    {
                                        account.Cancel(new[] { foundNTOrder });
                                    }
                                    catch (Exception ex)
                                    {
                                        RealLogger.PrintOutput("Exception in HandleBuyDrop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!sellOrderFound && !buyOrderFound)
            {
                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                double highestPrice = askPrice;
                if (UseDropAutoJumpToSnap)
                {
                    double highPrice = CalculateTrailHighPrice(MarketPosition.Short, true);
                    highestPrice = Math.Max(askPrice, highPrice);
                }

                double newDropPrice = GetInitialDropPrice(MarketPosition.Short, highestPrice);

                if (newDropPrice <= askPrice)
                {
                    newDropPrice = 0;
                }

                if (newDropPrice != 0)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New Drop- price=" + newDropPrice.ToString() + " via " + signalName);
                    int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                    CreateSellLimit(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, autoEntryVolume, newDropPrice);
                }

            }
            else if (sellOrderFound && !buyOrderFound)
            {
                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                double newDropPrice = GetDropPriceFromJumpTicks(MarketPosition.Short, oldDropPrice, this.DropJumpTicks);

                if (newDropPrice <= bidPrice || newDropPrice <= lastPrice)
                {
                    newDropPrice = 0;
                }

                if (newDropPrice != 0)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Update Drop- price=" + newDropPrice.ToString() + " lastPrice=" + lastPrice.ToString() + " bidPrice=" + bidPrice.ToString() + " via " + signalName);
                    UpdateLimitOrder(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, newDropPrice);
                }
            }

            return sellOrderFound;
        }

        private void HandlePopAutoJumpToSnap(string signalName)
        {
            if (UsePopAutoJumpToSnap)
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(PopAutoJumpToSnapLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (RealOrderService.AreAllOrderUpdateCyclesComplete()
                            )
                        {
                            bool buyOrderFound = false;
                            bool sellOrderFound = false;
                            double oldBuyPopPrice = 0;
                            double oldSellPopPrice = 0;

                            int orderCount = RealOrderService.OrderCount;

                            for (int index = 0; index < orderCount; index++)
                            {
                                RealOrder order = null;

                                if (RealOrderService.TryGetByIndex(index, out order))
                                {
                                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)))
                                    {
                                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover))
                                        {
                                            if (!Order.IsTerminalState(order.OrderState))
                                            {
                                                oldBuyPopPrice = order.StopPrice;
                                                buyOrderFound = true;
                                            }
                                        }

                                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.SellShort))
                                        {
                                            if (!Order.IsTerminalState(order.OrderState))
                                            {
                                                oldSellPopPrice = order.StopPrice;
                                                sellOrderFound = true;
                                            }
                                        }
                                    }
                                }

                                if (buyOrderFound && !sellOrderFound)
                                {
                                    double newPopPrice = GetPopPriceFromJumpTicks(MarketPosition.Long, oldBuyPopPrice, this.PopJumpTicks);
                                    double snapPrice = CalculateTrailHighPrice(MarketPosition.Long, true);
                                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                                    //double realBidPrice = GetCurrentBid();

                                    if (oldBuyPopPrice <= snapPrice)
                                    {
                                        newPopPrice = 0;
                                    }
                                    else if (newPopPrice < snapPrice)
                                    {
                                        newPopPrice = snapPrice;
                                    }

                                    if (newPopPrice != 0 && (newPopPrice <= bidPrice || newPopPrice <= lastPrice))// || newPopPrice <= realBidPrice))
                                    {
                                        newPopPrice = 0;
                                    }


                                    //RealLogger.PrintOutput("Update PopAutoJumpToSnap newPopPrice=" + newPopPrice.ToString() + " bidPrice=" + bidPrice.ToString() + " lastPrice=" + lastPrice.ToString());

                                    if (newPopPrice != 0 && oldBuyPopPrice != newPopPrice)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update PopAutoJumpToSnap buy price=" + newPopPrice.ToString() + " via " + signalName);
                                        UpdateStopOrder(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, newPopPrice);
                                    }
                                }
                                else if (sellOrderFound && !buyOrderFound)
                                {
                                    double newPopPrice = GetPopPriceFromJumpTicks(MarketPosition.Short, oldSellPopPrice, this.PopJumpTicks);
                                    double snapPrice = CalculateTrailLowPrice(MarketPosition.Short, true);
                                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                                    //double realAskPrice = GetCurrentAsk();

                                    if (oldSellPopPrice >= snapPrice)
                                    {
                                        newPopPrice = 0;
                                    }
                                    else if (newPopPrice > snapPrice)
                                    {
                                        newPopPrice = snapPrice;
                                    }

                                    if (newPopPrice != 0 && (newPopPrice >= askPrice || newPopPrice >= lastPrice)) // || newPopPrice >= realAskPrice))
                                    {
                                        newPopPrice = 0;
                                    }

                                    //RealLogger.PrintOutput("Update PopAutoJumpToSnap newPopPrice=" + newPopPrice.ToString() + " askPrice=" + askPrice.ToString() + " lastPrice=" + lastPrice.ToString());

                                    if (newPopPrice != 0 && oldSellPopPrice != newPopPrice)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update PopAutoJumpToSnap sell price=" + newPopPrice.ToString() + " via " + signalName);
                                        UpdateStopOrder(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, newPopPrice);
                                    }
                                }

                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling HandlePopAutoJumptToSnap:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                    {
                        Monitor.Exit(PopAutoJumpToSnapLock);
                    }
                }
            }
        }

        private void HandleDropAutoJumpToSnap(string signalName)
        {
            if (UseDropAutoJumpToSnap)
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(DropAutoJumpToSnapLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (RealOrderService.AreAllOrderUpdateCyclesComplete()
                            )
                        {
                            bool buyOrderFound = false;
                            bool sellOrderFound = false;
                            double oldBuyDropPrice = 0;
                            double oldSellDropPrice = 0;

                            int orderCount = RealOrderService.OrderCount;

                            for (int index = 0; index < orderCount; index++)
                            {
                                RealOrder order = null;

                                if (RealOrderService.TryGetByIndex(index, out order))
                                {
                                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                                    {
                                        if (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy))
                                        {
                                            if (!Order.IsTerminalState(order.OrderState))
                                            {
                                                oldBuyDropPrice = order.LimitPrice;
                                                buyOrderFound = true;
                                            }
                                        }

                                        if (RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell))
                                        {
                                            if (!Order.IsTerminalState(order.OrderState))
                                            {
                                                oldSellDropPrice = order.LimitPrice;
                                                sellOrderFound = true;
                                            }
                                        }
                                    }
                                }

                                if (buyOrderFound && !sellOrderFound)
                                {
                                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                                    double newDropPrice = GetDropPriceFromJumpTicks(MarketPosition.Long, oldBuyDropPrice, this.DropJumpTicks);
                                    double snapPrice = CalculateTrailLowPrice(MarketPosition.Long, true);
                                    //double realAskPrice = GetCurrentAsk();

                                    if (oldBuyDropPrice >= snapPrice)
                                    {
                                        newDropPrice = 0;
                                    }
                                    else if (newDropPrice > snapPrice)
                                    {
                                        newDropPrice = snapPrice;
                                    }

                                    if (newDropPrice != 0 && (newDropPrice >= askPrice || newDropPrice >= lastPrice)) // || newDropPrice >= realAskPrice))
                                    {
                                        newDropPrice = 0;
                                    }

                                    if (newDropPrice != 0 && oldBuyDropPrice != newDropPrice)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update DropAutoJumpToSnap buy price=" + newDropPrice.ToString() + " via " + signalName);
                                        UpdateLimitOrder(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, newDropPrice);
                                    }
                                }
                                else if (sellOrderFound && !buyOrderFound)
                                {
                                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                                    double newDropPrice = GetDropPriceFromJumpTicks(MarketPosition.Short, oldSellDropPrice, this.DropJumpTicks);
                                    double snapPrice = CalculateTrailHighPrice(MarketPosition.Short, true);
                                    //double realBidPrice = GetCurrentBid();

                                    if (oldSellDropPrice <= snapPrice)
                                    {
                                        newDropPrice = 0;
                                    }
                                    else if (newDropPrice < snapPrice)
                                    {
                                        newDropPrice = snapPrice;
                                    }

                                    if (newDropPrice != 0 && (newDropPrice <= bidPrice || newDropPrice <= lastPrice)) // || newDropPrice <= realBidPrice))
                                    {
                                        newDropPrice = 0;
                                    }

                                    if (newDropPrice != 0 && oldSellDropPrice != newDropPrice)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update DropAutoJumpToSnap sell price=" + newDropPrice.ToString() + " via " + signalName);
                                        UpdateLimitOrder(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, newDropPrice);
                                    }
                                }

                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling HandleDropAutoJumptToSnap:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                    {
                        Monitor.Exit(DropAutoJumpToSnapLock);
                    }
                }
            }
        }

        private int CalculateATRTicks(double atrValue, double atrMultiplier, int ticksPerPoint)
        {
            int atrTicks = 0;

            if (atrMultiplier > 0)
            {
                atrTicks = (int)((atrValue * ticksPerPoint) * atrMultiplier);
            }

            return atrTicks;
        }

        private double GetInitialPopPrice(MarketPosition marketPosition, double askPrice)
        {
            int popTicks = this.PopInitialTicks;
            bool allowATROverride = (this.PopInitialATRMultiplier > 0);

            if (allowATROverride)
            {
                int newATRPopTicks = CalculateATRTicks(atrValue, this.PopInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                popTicks = Math.Max(newATRPopTicks, this.PopInitialTicks);
            }

            double newPopPrice = CalculatePopPrice(marketPosition, askPrice, popTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newPopPrice);

            return normalizedPrice;
        }

        private double GetPopPriceFromJumpTicks(MarketPosition marketPosition, double oldPopPrice, int jumpTicks)
        {
            double newPopPrice = 0;

            newPopPrice = CalculatePopPlusPrice(marketPosition, oldPopPrice, jumpTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newPopPrice);

            return normalizedPrice;
        }

        private double CalculatePopPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newPopPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newPopPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newPopPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newPopPrice);

            return normalizedPrice;
        }

        private double CalculatePopPlusPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newPopPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newPopPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newPopPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newPopPrice);

            return normalizedPrice;
        }

        private double GetInitialDropPrice(MarketPosition marketPosition, double askPrice)
        {
            int dropTicks = this.DropInitialTicks;
            bool allowATROverride = (this.DropInitialATRMultiplier > 0);

            if (allowATROverride)
            {
                int newATRDropTicks = CalculateATRTicks(atrValue, this.DropInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                dropTicks = Math.Max(newATRDropTicks, this.DropInitialTicks);
            }

            double newDropPrice = CalculateDropPrice(marketPosition, askPrice, dropTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newDropPrice);

            return normalizedPrice;
        }

        private double GetDropPriceFromJumpTicks(MarketPosition marketPosition, double oldDropPrice, int jumpTicks)
        {
            double newDropPrice = 0;

            newDropPrice = CalculateDropPlusPrice(marketPosition, oldDropPrice, jumpTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newDropPrice);

            return normalizedPrice;
        }

        private double CalculateDropPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newDropPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newDropPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newDropPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newDropPrice);

            return normalizedPrice;
        }

        private double CalculateDropPlusPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newDropPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newDropPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newDropPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newDropPrice);

            return normalizedPrice;
        }

        private double GetInitialStopLossPrice(Instrument instrument, MarketPosition marketPosition, double averagePrice, int quantity, double currentStopLossPrice = 0)
        {
            double newStopLossPrice = currentStopLossPrice;
            bool useStopLossTicks = (this.StopLossInitialTicks > 0);
            bool useStopLossDollars = (this.StopLossInitialDollars > 0);

            int stopLossTicks = this.StopLossInitialTicks;
            bool allowATROverride = (this.StopLossInitialATRMultiplier > 0);


            if (useStopLossDollars)
            {
                double commissionPerSide = GetInstrumentCommissionPerSide(instrument);
                bool includeCommissions = (commissionPerSide > 0);
                double netStopLossDollars = this.StopLossInitialDollars;

                double tickValue = RealInstrumentService.GetTickValue(attachedInstrument);
                double tickSize = attachedInstrumentTickSize;
                int ticksPerPoint = attachedInstrumentTicksPerPoint;

                if (StopLossInitialDollarsCombined && currentStopLossPrice == 0)
                {
                    if (allowATROverride)
                    {
                        int newATRStopLossTicks = CalculateATRTicks(atrValue, this.StopLossInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                        stopLossTicks = Math.Max(newATRStopLossTicks, this.StopLossInitialTicks);
                    }

                    newStopLossPrice = CalculateStopLossPrice(marketPosition, averagePrice, stopLossTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

                    if (currentStopLossInitialSnapStatus != TickHunterStopLossSnapTypes.Disabled)
                    {
                        if (marketPosition == MarketPosition.Long)
                        {
                            double newSnapStopLossPrice = CalculateSnapBarLowPrice(currentStopLossInitialSnapStatus); //CalculateTrailLowPrice(marketPosition, true);
                            if (newSnapStopLossPrice > attachedInstrumentTickSize)
                                newStopLossPrice = Math.Min(newStopLossPrice, newSnapStopLossPrice);
                        }
                        else if (marketPosition == MarketPosition.Short)
                        {
                            double newSnapStopLossPrice = CalculateSnapBarHighPrice(currentStopLossInitialSnapStatus); //CalculateTrailHighPrice(marketPosition, true);
                            if (newSnapStopLossPrice > attachedInstrumentTickSize)
                                newStopLossPrice = Math.Max(newStopLossPrice, newSnapStopLossPrice);


                        }
                    }
                }

                if (includeCommissions)
                {
                    netStopLossDollars = netStopLossDollars - (quantity * commissionPerSide * 2);
                }

                if (marketPosition == MarketPosition.Long)
                {
                    double newStopLossDollarPrice = (Math.Floor(averagePrice * ticksPerPoint) / ticksPerPoint) - (Math.Ceiling((netStopLossDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                    newStopLossPrice = (StopLossInitialDollarsCombined) ? Math.Max(newStopLossPrice, newStopLossDollarPrice) : newStopLossDollarPrice;
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    double newStopLossDollarPrice = (Math.Ceiling(averagePrice * ticksPerPoint) / ticksPerPoint) + (Math.Ceiling((netStopLossDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                    newStopLossPrice = (StopLossInitialDollarsCombined) ? Math.Min(newStopLossPrice, newStopLossDollarPrice) : newStopLossDollarPrice;
                }
            }
            else if (useStopLossTicks)
            {
                if (allowATROverride)
                {
                    int newATRStopLossTicks = CalculateATRTicks(atrValue, this.StopLossInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                    stopLossTicks = Math.Max(newATRStopLossTicks, this.StopLossInitialTicks);
                }

                newStopLossPrice = CalculateStopLossPrice(marketPosition, averagePrice, stopLossTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

                if (currentStopLossInitialSnapStatus != TickHunterStopLossSnapTypes.Disabled)
                {
                    if (marketPosition == MarketPosition.Long)
                    {
                        double newSnapStopLossPrice = CalculateSnapBarLowPrice(currentStopLossInitialSnapStatus); //CalculateTrailLowPrice(marketPosition, true);
                        if (newSnapStopLossPrice > attachedInstrumentTickSize)
                            newStopLossPrice = Math.Min(newStopLossPrice, newSnapStopLossPrice);
                    }
                    else if (marketPosition == MarketPosition.Short)
                    {
                        double newSnapStopLossPrice = CalculateSnapBarHighPrice(currentStopLossInitialSnapStatus); //CalculateTrailHighPrice(marketPosition, true);
                        if (newSnapStopLossPrice > attachedInstrumentTickSize)
                            newStopLossPrice = Math.Max(newStopLossPrice, newSnapStopLossPrice);
                    }
                }

                if (StopLossInitialMaxTicks > 0)
                {
                    if (marketPosition == MarketPosition.Long)
                    {
                        double tempMaxStopLossPrice = CalculateStopLossPrice(marketPosition, averagePrice, StopLossInitialMaxTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);
                        newStopLossPrice = Math.Max(newStopLossPrice, tempMaxStopLossPrice);
                    }
                    else if (marketPosition == MarketPosition.Short)
                    {
                        double tempMaxStopLossPrice = CalculateStopLossPrice(marketPosition, averagePrice, StopLossInitialMaxTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);
                        newStopLossPrice = Math.Min(newStopLossPrice, tempMaxStopLossPrice);
                    }
                }
            }

            bool isStopLossPriceInvalid = newStopLossPrice <= 0;

            if (isStopLossPriceInvalid)
            {
                newStopLossPrice = 0 + attachedInstrumentTickSize;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double GetBogeyTargetFromDollars(Instrument instrument, MarketPosition marketPosition, double averagePrice, int quantity, double bogeyTargetDollars)
        {
            double newBogeyTargetPrice = 0;

            double commissionPerSide = GetInstrumentCommissionPerSide(instrument);
            bool includeCommissions = (commissionPerSide > 0);
            double netBogeyTargetDollars = bogeyTargetDollars;

            double tickValue = RealInstrumentService.GetTickValue(attachedInstrument);
            double tickSize = attachedInstrumentTickSize;
            int ticksPerPoint = attachedInstrumentTicksPerPoint;

            if (includeCommissions)
            {
                netBogeyTargetDollars = netBogeyTargetDollars + (quantity * commissionPerSide);// * 2);
            }

            if (marketPosition == MarketPosition.Long)
            {
                double newBogeyTargetDollarPrice = (Math.Ceiling(averagePrice * ticksPerPoint) / ticksPerPoint) + (Math.Ceiling((netBogeyTargetDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newBogeyTargetPrice = newBogeyTargetDollarPrice;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double newBogeyTargetDollarPrice = (Math.Floor(averagePrice * ticksPerPoint) / ticksPerPoint) - (Math.Ceiling((netBogeyTargetDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newBogeyTargetPrice = newBogeyTargetDollarPrice;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newBogeyTargetPrice);

            return normalizedPrice;
        }

        private double GetDayOverMaxLossFromDollars(MarketPosition marketPosition, double averagePrice, int quantity, double dayOverDollars)
        {
            double newStopLossPrice = 0;

            double commissionPerSide = attachedInstrumentCommissionPerSide;
            bool includeCommissions = (commissionPerSide > 0);
            double netStopLossDollars = dayOverDollars;

            double tickValue = RealInstrumentService.GetTickValue(attachedInstrument);
            double tickSize = attachedInstrumentTickSize;
            int ticksPerPoint = attachedInstrumentTicksPerPoint;

            if (includeCommissions)
            {
                netStopLossDollars = netStopLossDollars - (quantity * commissionPerSide);// * 2);
            }

            if (marketPosition == MarketPosition.Long)
            {
                double newStopLossDollarPrice = (Math.Floor(averagePrice * ticksPerPoint) / ticksPerPoint) - (Math.Ceiling((netStopLossDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newStopLossPrice = newStopLossDollarPrice;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double newStopLossDollarPrice = (Math.Ceiling(averagePrice * ticksPerPoint) / ticksPerPoint) + (Math.Ceiling((netStopLossDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newStopLossPrice = newStopLossDollarPrice;
            }

            bool isStopLossPriceInvalid = newStopLossPrice <= 0;

            if (isStopLossPriceInvalid)
            {
                newStopLossPrice = 0 + attachedInstrumentTickSize;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }


        private double GetECATargetDollars(int totalVolume, int totalOtherVolume,
            int totalMYMVolume, int totalMESVolume, int totalM2KVolume, int totalMNQVolume,
            int totalYMVolume, int totalESVolume, int totalRTYVolume, int totalNQVolume)
        {
            double DEFAULT_ECAT_DOLLARS = 1;
            double newECATargetDollars = 0;

            bool hasTakeProfitDollars = ECATargetDollars > 0;

            if (hasTakeProfitDollars)
            {
                newECATargetDollars = ECATargetDollars;
            }
            else
            {
                bool hasProfitATRMultiplierPerVolume = ECATargetATRMultiplierPerVolume > 0;
                double targetDollarsPerVolume = 0;

                if (totalMYMVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerMYMVolume * totalMYMVolume);

                if (totalMESVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerMESVolume * totalMESVolume);

                if (totalM2KVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerM2KVolume * totalM2KVolume);

                if (totalMNQVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerMNQVolume * totalMNQVolume);

                if (totalYMVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerYMVolume * totalYMVolume);

                if (totalESVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerESVolume * totalESVolume);

                if (totalRTYVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerRTYVolume * totalRTYVolume);

                if (totalNQVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerNQVolume * totalNQVolume);

                if (totalOtherVolume > 0)
                    targetDollarsPerVolume += (ECATargetDollarsPerOtherVolume * totalOtherVolume);

                if (hasProfitATRMultiplierPerVolume)
                {
                    int atrTicks = CalculateATRTicks(atrValue, ECATargetATRMultiplierPerVolume, attachedInstrumentTicksPerPoint);
                    double atrExpectedProfit = 0;

                    atrExpectedProfit += RealInstrumentService.ConvertTicksToDollars(attachedInstrument, atrTicks, totalVolume);

                    if (atrExpectedProfit > targetDollarsPerVolume)
                    {
                        targetDollarsPerVolume = atrExpectedProfit;
                    }
                }

                newECATargetDollars = targetDollarsPerVolume;
            }

            if (newECATargetDollars <= 0) newECATargetDollars = DEFAULT_ECAT_DOLLARS;

            return newECATargetDollars;
        }


        private double GetECATakeProfitPriceFromDollars(MarketPosition marketPosition, double averagePrice, int quantity, double takeProfitDollars)
        {
            double newECATakeProfitPrice = 0;

            double commissionPerSide = attachedInstrumentCommissionPerSide;
            bool includeCommissions = (commissionPerSide > 0);
            double netECATakeProfitDollars = takeProfitDollars;

            double tickValue = RealInstrumentService.GetTickValue(attachedInstrument);
            double tickSize = attachedInstrumentTickSize;
            int ticksPerPoint = attachedInstrumentTicksPerPoint;

            if (includeCommissions)
            {
                netECATakeProfitDollars = netECATakeProfitDollars + (quantity * commissionPerSide * 2);
            }

            if (marketPosition == MarketPosition.Long)
            {
                double newECATakeProfitDollarPrice = (Math.Ceiling(averagePrice * ticksPerPoint) / ticksPerPoint) + (Math.Ceiling((netECATakeProfitDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newECATakeProfitPrice = newECATakeProfitDollarPrice;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double newECATakeProfitDollarPrice = (Math.Floor(averagePrice * ticksPerPoint) / ticksPerPoint) - (Math.Ceiling((netECATakeProfitDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newECATakeProfitPrice = newECATakeProfitDollarPrice;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newECATakeProfitPrice);

            return normalizedPrice;
        }

        private double GetStopLossPriceFromJumpTicks(MarketPosition marketPosition, double oldStopLossPrice, int jumpTicks)
        {
            double newStopLossPrice = 0;

            newStopLossPrice = CalculateStopLossPlusPrice(marketPosition, oldStopLossPrice, jumpTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double CalculateStopLossPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newStopLossPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newStopLossPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double CalculateStopLossPlusPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newStopLossPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newStopLossPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double GetInitialBreakEvenStopLossPrice(MarketPosition marketPosition, double averagePrice)
        {
            double newStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newStopLossPrice = (Math.Ceiling(averagePrice * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + ((double)this.BreakEvenInitialTicks * attachedInstrumentTickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newStopLossPrice = (Math.Floor(averagePrice * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - ((double)this.BreakEvenInitialTicks * attachedInstrumentTickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double GetTriggerBreakEvenStopLossPrice(MarketPosition marketPosition, double averagePrice)
        {
            double newStopLossPrice = 0;
            int breakEventriggerTicks = this.BreakEvenAutoTriggerTicks;

            if (this.BreakEvenAutoTriggerATRMultiplier > 0)
            {
                int newATRTriggerTicks = CalculateATRTicks(atrValue, this.BreakEvenAutoTriggerATRMultiplier, attachedInstrumentTicksPerPoint);

                breakEventriggerTicks = Math.Max(newATRTriggerTicks, this.BreakEvenAutoTriggerTicks);
            }

            if (marketPosition == MarketPosition.Long)
            {
                newStopLossPrice = (Math.Ceiling(averagePrice * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + ((double)breakEventriggerTicks * attachedInstrumentTickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newStopLossPrice = (Math.Floor(averagePrice * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - ((double)breakEventriggerTicks * attachedInstrumentTickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double GetInitialTakeProfitPrice(MarketPosition marketPosition, double averagePrice)
        {
            double newTakeProfitPrice = 0;
            int takeProfitTicks = this.TakeProfitInitialTicks;

            if (this.TakeProfitInitialATRMultiplier > 0)
            {
                int newATRTakeProfitTicks = CalculateATRTicks(atrValue, this.TakeProfitInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                takeProfitTicks = Math.Max(newATRTakeProfitTicks, this.TakeProfitInitialTicks);
            }

            newTakeProfitPrice = CalculateTakeProfitPrice(marketPosition, averagePrice, takeProfitTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            bool isTakeProfitPriceInvalid = newTakeProfitPrice <= 0;

            if (isTakeProfitPriceInvalid)
            {
                newTakeProfitPrice = 0 + attachedInstrumentTickSize;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newTakeProfitPrice);

            return normalizedPrice;
        }

        private double GetTakeProfitPriceFromJumpTicks(MarketPosition marketPosition, double oldTakeProfitPrice, int jumpTicks)
        {
            double newTakeProfitPrice = 0;

            newTakeProfitPrice = CalculateTakeProfitPrice(marketPosition, oldTakeProfitPrice, jumpTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            return newTakeProfitPrice;
        }

        double CalculateTakeProfitPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newTakeProfitPrice = 0;

            if (price > 0 && ticks > 0)
            {
                bool isBuyPosition = (marketPosition == MarketPosition.Long);

                if (marketPosition == MarketPosition.Long)
                {
                    newTakeProfitPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    newTakeProfitPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
                }
            }

            return newTakeProfitPrice;
        }


        private OrderAction ConvertMarketPositionToOrderAction(MarketPosition marketPosition)
        {
            OrderAction orderAction = OrderAction.BuyToCover;

            if (marketPosition == MarketPosition.Long)
            {
                orderAction = OrderAction.Buy;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                orderAction = OrderAction.Sell;
            }
            else
            {
                RealLogger.PrintOutput("Market position type  " + marketPosition.ToString() + " not supported.");
            }

            return orderAction;
        }

        private MarketPosition ConvertOrderActionToMarketPosition(OrderAction orderAction)
        {
            MarketPosition marketPosition = MarketPosition.Flat;

            if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
            {
                marketPosition = MarketPosition.Long;
            }
            else if (orderAction == OrderAction.Sell || orderAction == OrderAction.SellShort)
            {
                marketPosition = MarketPosition.Short;
            }
            else
            {
                RealLogger.PrintOutput("Order action type  " + orderAction.ToString() + " not supported.");
            }

            return marketPosition;
        }

        private OrderAction ConvertMarketPositionToRevOrderAction(MarketPosition marketPosition)
        {
            OrderAction orderAction = OrderAction.BuyToCover;

            if (marketPosition == MarketPosition.Long)
            {
                orderAction = OrderAction.Sell;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                orderAction = OrderAction.BuyToCover;
            }
            else
            {
                RealLogger.PrintOutput("Market position type  " + marketPosition.ToString() + " not supported.");
            }

            return orderAction;
        }

        private OrderAction ConvertMarketPositionToSLOrderAction(MarketPosition marketPosition)
        {
            OrderAction orderAction = OrderAction.BuyToCover;

            if (marketPosition == MarketPosition.Long)
            {
                orderAction = OrderAction.Sell;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                orderAction = OrderAction.BuyToCover;
            }
            else
            {
                RealLogger.PrintOutput("Market position type  " + marketPosition.ToString() + " not supported.");
            }

            return orderAction;
        }

        private OrderAction ConvertMarketPositionToTPOrderAction(MarketPosition marketPosition)
        {
            OrderAction orderAction = OrderAction.BuyToCover;

            if (marketPosition == MarketPosition.Long)
            {
                orderAction = OrderAction.Sell;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                orderAction = OrderAction.BuyToCover;
            }
            else
            {
                RealLogger.PrintOutput("Market position type  " + marketPosition.ToString() + " not supported.");
            }

            return orderAction;
        }

        private void IncrementBuyPopDelayedTradeCount()
        {
            if (currentBuyPopDelayedStatus != TickHunterPopDelayedTypes.TradeCount5)
            {
                if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;
                }
                else
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount5;
                }

                lastToggleBuyPopDelayedStatus = nextBuyPopDelayedStatus;
                currentBuyPopDelayedStatus = nextBuyPopDelayedStatus;
                lastBuyPopDelayedChangeTime = GetDateTimeNow(); // no delay
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();
            }
        }

        private void IncrementSellPopDelayedTradeCount()
        {
            if (currentSellPopDelayedStatus != TickHunterPopDelayedTypes.TradeCount5)
            {
                if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;
                }
                else
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount5;
                }

                lastToggleSellPopDelayedStatus = nextSellPopDelayedStatus;
                currentSellPopDelayedStatus = nextSellPopDelayedStatus;
                lastSellPopDelayedChangeTime = GetDateTimeNow(); // no delay
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();
            }
        }

        private void DecrementBuyPopDelayedTradeCount(string signalName)
        {
            if (currentBuyPopDelayedStatus != TickHunterPopDelayedTypes.Disabled)
            {
                if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount5)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount4)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
                }

                lastToggleBuyPopDelayedStatus = nextBuyPopDelayedStatus;
                currentBuyPopDelayedStatus = nextBuyPopDelayedStatus;
                lastBuyPopDelayedChangeTime = GetDateTimeNow(); // no delay
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();

                if (lastToggleBuyPopDelayedStatus != TickHunterPopDelayedTypes.Disabled)
                {
                    string buttonText = "";
                    string buttonToolTip = "";

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);

                    SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, lastToggleBuyPopDelayedStatus, PopActivateColorDelaySeconds, Brushes.HotPink);
                }
                else
                {
                    DeactivateBuyPopButton(signalName);
                }
            }
        }

        private void DecrementSellPopDelayedTradeCount(string signalName)
        {
            if (currentSellPopDelayedStatus != TickHunterPopDelayedTypes.Disabled)
            {
                if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount5)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount4)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
                }

                lastToggleSellPopDelayedStatus = nextSellPopDelayedStatus;
                currentSellPopDelayedStatus = nextSellPopDelayedStatus;
                lastSellPopDelayedChangeTime = GetDateTimeNow(); // no delay
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();

                if (lastToggleSellPopDelayedStatus != TickHunterPopDelayedTypes.Disabled)
                {
                    string buttonText = "";
                    string buttonToolTip = "";

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);

                    SetSellPopButton(SellPopButton, buttonText, buttonToolTip, lastToggleSellPopDelayedStatus, PopActivateColorDelaySeconds, Brushes.HotPink);
                }
                else
                {
                    DeactivateSellPopButton(signalName);
                }
            }
        }

        private void DecrementAutoPilotTradeCount()
        {
            if (currentAutoPilotStatus != TickHunterAutoPilotTypes.Disabled)
            {
                if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount20)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount19;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount19)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount18;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount18)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount17;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount17)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount16;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount16)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount15;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount15)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount14;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount14)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount13;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount13)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount12;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount12)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount11;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount11)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount10;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount10)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount9;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount9)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount8;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount8)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount7;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount7)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount6;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount6)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount5;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount5)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount4;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount4)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount3;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount3)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount2;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount2)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount1;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount1)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
                }

                lastToggleEntryAutoPilotStatus = nextAutoPilotStatus;
                currentAutoPilotStatus = nextAutoPilotStatus;
                lastAutoPilotChangeTime = GetDateTimeNow(); // no delay
            }
        }

        private bool AllowNewAutoPilotOrders(Instrument instrument)
        {
            bool allowNewAutoPilotEntries = false;

            //double netLiquidationBalance = GetNetLiquidationBalance();

            if (!activeDayOverMaxLossAutoClose) //!HasAccountHitEquityRemainingFloor(netLiquidationBalance))
            {
                allowNewAutoPilotEntries = true;
            }


            return allowNewAutoPilotEntries;
        }

        /*
        private int GetMaxPositionSize(Instrument instrument)
        {
            int maxPositionSize = 0;

            if (account != null && account.Risk != null && account.Risk.ByMasterInstrument.ContainsKey(instrument.MasterInstrument))
            {
                maxPositionSize = account.Risk.ByMasterInstrument[instrument.MasterInstrument].MaxPositionSize;
            }
            else
            {
                RealLogger.PrintOutput("ERROR: Missing max position size for instrument '" + instrument.FullName + "'");
            }

            return maxPositionSize;
        }
        */

        private double GetAccountIntradayExcessMargin()
        {
            double intradayExcessMargin = 0;

            if (account != null)
            {
                intradayExcessMargin = Math.Round(account.Get(AccountItem.ExcessIntradayMargin, Currency.UsDollar), 2);
            }

            return intradayExcessMargin;
        }

        private double GetInstrumentIntradayMarginDollars(Instrument instrument)
        {
            double intradayMarginDollars = OtherIntradayMarginDollars;

            if (instrument == mnqInstrument)
            {
                intradayMarginDollars = MNQIntradayMarginDollars;
            }
            else if (instrument == mesInstrument)
            {
                intradayMarginDollars = MESIntradayMarginDollars;
            }
            else if (instrument == mymInstrument)
            {
                intradayMarginDollars = MYMIntradayMarginDollars;
            }
            else if (instrument == m2kInstrument)
            {
                intradayMarginDollars = M2KIntradayMarginDollars;
            }
            else if (instrument == nqInstrument)
            {
                intradayMarginDollars = NQIntradayMarginDollars;
            }
            else if (instrument == esInstrument)
            {
                intradayMarginDollars = ESIntradayMarginDollars;
            }
            else if (instrument == ymInstrument)
            {
                intradayMarginDollars = YMIntradayMarginDollars;
            }
            else if (instrument == rtyInstrument)
            {
                intradayMarginDollars = RTYIntradayMarginDollars;
            }


            /*
			if (account != null && account.Risk != null && account.Risk.ByMasterInstrument.ContainsKey(instrument.MasterInstrument))
            {
                if (orderAction == OrderAction.Buy)
                {
                    intradayMargin = account.Risk.ByMasterInstrument[instrument.MasterInstrument].BuyIntradayMargin;
                }
                else if (orderAction == OrderAction.Sell)
                {
                    intradayMargin = account.Risk.ByMasterInstrument[instrument.MasterInstrument].SellIntradayMargin;
                }
                else
                {
                    RealLogger.PrintOutput("GetInstrumentIntradayMargin: Order action type  " + orderAction.ToString() + " not supported.");
                }
            }
            else
            {
                RealLogger.PrintOutput("ERROR: Missing intraday margin for instrument '" + instrument.FullName + "'");
            }
			*/

            return intradayMarginDollars;
        }

        private int GetInstrumentPositionMaxVolume(Instrument instrument)
        {
            int positionMaxVolume = OtherPositionMaxVolume;

            if (instrument == mnqInstrument)
            {
                positionMaxVolume = MNQPositionMaxVolume;
            }
            else if (instrument == mesInstrument)
            {
                positionMaxVolume = MESPositionMaxVolume;
            }
            else if (instrument == mymInstrument)
            {
                positionMaxVolume = MYMPositionMaxVolume;
            }
            else if (instrument == m2kInstrument)
            {
                positionMaxVolume = M2KPositionMaxVolume;
            }
            else if (instrument == nqInstrument)
            {
                positionMaxVolume = NQPositionMaxVolume;
            }
            else if (instrument == esInstrument)
            {
                positionMaxVolume = ESPositionMaxVolume;
            }
            else if (instrument == ymInstrument)
            {
                positionMaxVolume = YMPositionMaxVolume;
            }
            else if (instrument == rtyInstrument)
            {
                positionMaxVolume = RTYPositionMaxVolume;
            }

            return positionMaxVolume;
        }

        private bool OrderMarginCheck(Instrument instrument, bool requireMarginCheck, OrderAction orderAction, int volume, int buyPositionVolume, int sellPositionVolume)
        {
            bool marginCheckSucceeded = false;

            if (HasRanOnceFirstCycle())
            {
                if (!requireMarginCheck)
                {
                    marginCheckSucceeded = true;
                    return marginCheckSucceeded;
                }

                double intradayMargin = GetInstrumentIntradayMarginDollars(instrument);

                bool hasValidRiskTemplate = intradayMargin > 0;

                if (hasValidRiskTemplate)
                {
                    double excessInitialMargin = account.Get(AccountItem.ExcessIntradayMargin, Currency.UsDollar);
                    double totalRequiredIntradayMargin = volume * intradayMargin;
                    double remainingExcessIntradayMargin = 0;

                    bool addingToExistingPosition = (orderAction == OrderAction.Buy && buyPositionVolume > 0)
                        || (orderAction == OrderAction.Sell && sellPositionVolume > 0);

                    bool adddingToNoPosition = (buyPositionVolume == 0 && sellPositionVolume == 0);

                    bool reducingAnExistingPosition = (orderAction == OrderAction.Buy && sellPositionVolume > 0) ||
                        (orderAction == OrderAction.Sell && buyPositionVolume > 0);

                    if (addingToExistingPosition || adddingToNoPosition)
                    {
                        remainingExcessIntradayMargin = excessInitialMargin - totalRequiredIntradayMargin;
                    }
                    else if (reducingAnExistingPosition)
                    {
                        remainingExcessIntradayMargin = excessInitialMargin + totalRequiredIntradayMargin;
                    }

                    marginCheckSucceeded = remainingExcessIntradayMargin > (ExcessIntradayMarginMinDollars + MIN_EXCESS_MARGIN);
                }
                else
                {
                    RealLogger.PrintOutput("Missing valid risk template attached to account with IntradayMargin and IntradayMarginDollars equals zero.");

                    marginCheckSucceeded = true;
                }
            }

            return marginCheckSucceeded;
        }

        private bool GetPositionVolume(Instrument instrument, out int buyVolume, out int sellVolume)
        {
            bool positionFound = false;
            buyVolume = 0;
            sellVolume = 0;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;

                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    if (position.Instrument == instrument)
                    {
                        positionFound = true;

                        if (position.MarketPosition == MarketPosition.Long)
                        {
                            buyVolume += position.Quantity;
                        }
                        else if (position.MarketPosition == MarketPosition.Short)
                        {
                            sellVolume += position.Quantity;
                        }
                    }
                }
            }

            return positionFound;
        }

        private bool GetPositionVolume(Instrument instrument, out int buyVolume, out double buyPositionPrice, out int sellVolume, out double sellPositionPrice, out DateTime positionModifyDate)
        {
            bool positionFound = false;
            buyVolume = 0;
            sellVolume = 0;
            buyPositionPrice = 0;
            sellPositionPrice = 0;
            positionModifyDate = DateTime.MinValue;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;

                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    if (position.Instrument == instrument)
                    {
                        positionFound = true;
                        positionModifyDate = position.ModifyDate;

                        if (position.MarketPosition == MarketPosition.Long)
                        {
                            buyPositionPrice = position.AveragePrice;
                            buyVolume += position.Quantity;
                        }
                        else if (position.MarketPosition == MarketPosition.Short)
                        {
                            sellPositionPrice = position.AveragePrice;
                            sellVolume += position.Quantity;
                        }
                    }
                }
            }

            return positionFound;
        }



        private void AttemptToEngageAutoAddOn()
        {
            string signalName = "EngageAutoAddOn";
            if (currentAutoAddOnStatus == TickHunterAutoAddOnTypes.Enabled
                && RealOrderService.AreAllOrderUpdateCyclesComplete())
            {
                if (!IsAccountFlat(attachedInstrument)
                    && autoAddOnMaxDollars > 0
                    && attachedInstrumentPositionMaxVolume > 0)
                {
                    bool fullyEnabled = lastAddOnMaxCycleChangeTime <= GetDateTimeNow();

                    if (fullyEnabled)
                    {
                        lastAddOnMaxCycleChangeTime = (GetDateTimeNow()).AddSeconds(AutoAddOnMaxCycleDelaySeconds);

                        int positionCount = RealPositionService.PositionCount;

                        int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                        int newAddOnVolume = autoEntryVolume;

                        double unrealizedProfitLoss = 0;
                        int buyPositionVolumeSize = 0;
                        int sellPositionVolumeSize = 0;
                        bool passedInProfitCheck = false;
                        bool passedPositionMaxVolumeCheck = false;
                        bool passedIntradayMarginCheck = false;
                        OrderAction addOnOrderAction = OrderAction.Buy;
                        DateTime addOnReadyTime = DateTime.MinValue;

                        double autoAddOnMaxDollarsFlipped = autoAddOnMaxDollars * -1;

                        for (int index = 0; index < positionCount; index++)
                        {
                            RealPosition position = null;

                            if (RealPositionService.TryGetByIndex(index, out position))
                            {
                                if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                                {
                                    position.StoreState();

                                    bool addOnPastDelay = position.CreateDate.AddSeconds(AutoAddOnInnerWindowDelaySeconds) <= GetDateTimeNow();

                                    if (addOnPastDelay)
                                    {
                                        if (position.MarketPosition == MarketPosition.Long)
                                        {
                                            addOnOrderAction = OrderAction.Buy;
                                        }
                                        else if (position.MarketPosition == MarketPosition.Short)
                                        {
                                            addOnOrderAction = OrderAction.Sell;
                                        }

                                        buyPositionVolumeSize = (addOnOrderAction == OrderAction.Buy) ? (position.Quantity) : 0;
                                        sellPositionVolumeSize = (addOnOrderAction == OrderAction.Sell) ? (position.Quantity) : 0;

                                        bool passedNextAddOnCheck = false;
                                        bool passedNextAddOn1Check = false;

                                        double riskInfoTotalDollars = 0;
                                        double riskInfoBlendedDollars = 0;


                                        if (IsBlendedInstrumentEnabled() && blendedInstrumentHasPosition)
                                        {
                                            riskInfoBlendedDollars = Math.Round(GetPositionProfitWithStoLoss(blendedInstrument, blendedInstrumentMarketPosition, blendedInstrumentPositionQuantity, blendedInstrumentPositionPrice, blendedInstrumentPositionStopLossPrice), 2);
                                            riskInfoTotalDollars += riskInfoBlendedDollars;
                                        }

                                        bool stillPassedPositionMaxVolumeCheck = false;
                                        bool stillPassedIntradayMarginCheck = false;

                                        bool hasAttachedStopLoss = attachedInstrumentPositionStopLossPrice > 0;
                                        bool hasBlendedStopLoss = blendedInstrumentPositionStopLossPrice > 0;

                                        if (hasAttachedStopLoss && (!blendedInstrumentHasPosition
                                            || (blendedInstrumentHasPosition && hasBlendedStopLoss)))
                                        {
                                            int nextAddOnCount = 1;

                                            double nextPositionPrice = attachedInstrumentPositionPrice;

                                            if (attachedInstrumentMarketPosition == MarketPosition.Long)
                                            {
                                                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                                nextPositionPrice = Math.Max(attachedInstrumentPositionPrice, askPrice);
                                            }
                                            else if (attachedInstrumentMarketPosition == MarketPosition.Short)
                                            {
                                                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                                nextPositionPrice = Math.Min(attachedInstrumentPositionPrice, bidPrice);
                                            }


                                            double nextAddOnDollars = Math.Round(GetPositionProfitWithStoLoss(attachedInstrument, attachedInstrumentMarketPosition, attachedInstrumentPositionQuantity + nextAddOnCount, nextPositionPrice, attachedInstrumentPositionStopLossPrice), 2);
                                            double nextAddOnTotalDollars = (nextAddOnDollars + riskInfoBlendedDollars);

                                            //RealLogger.PrintOutput("*** DEBUG nextAddOnDollars=" + nextAddOnDollars + " buyPositionVolumeSize=" + buyPositionVolumeSize + " sellPositionVolumeSize=" + sellPositionVolumeSize + " attachedInstrumentPositionStopLossPrice=" + attachedInstrumentPositionStopLossPrice);

                                            //RealLogger.PrintOutput("*** DEBUG autoAddOnMaxDollarsFlipped=" + autoAddOnMaxDollarsFlipped + " nextAddOn1TotalDollars=" + nextAddOn1TotalDollars);

                                            bool riskDollarsInverted = nextAddOnTotalDollars > 0;


                                            if (nextAddOnTotalDollars < 0 || riskDollarsInverted)
                                            {
                                                if (autoAddOnMaxDollarsFlipped <= nextAddOnTotalDollars || riskDollarsInverted)
                                                {
                                                    passedNextAddOnCheck = true;
                                                    passedNextAddOn1Check = true;
                                                    newAddOnVolume = 1;

                                                    passedPositionMaxVolumeCheck = attachedInstrumentPositionMaxVolume > 0 && (position.Quantity + newAddOnVolume) <= attachedInstrumentPositionMaxVolume;
                                                    passedIntradayMarginCheck = OrderMarginCheck(attachedInstrument, true, addOnOrderAction, newAddOnVolume, buyPositionVolumeSize, sellPositionVolumeSize);

                                                    for (var i = 2; i <= attachedInstrumentPositionMaxVolume; i++)
                                                    {
                                                        nextAddOnCount = i;
                                                        nextAddOnDollars = Math.Round(GetPositionProfitWithStoLoss(attachedInstrument, attachedInstrumentMarketPosition, attachedInstrumentPositionQuantity + nextAddOnCount, nextPositionPrice, attachedInstrumentPositionStopLossPrice), 2);
                                                        nextAddOnTotalDollars = (nextAddOnDollars + riskInfoBlendedDollars);
                                                        stillPassedPositionMaxVolumeCheck = attachedInstrumentPositionMaxVolume > 0 && (position.Quantity + nextAddOnCount) <= attachedInstrumentPositionMaxVolume;
                                                        stillPassedIntradayMarginCheck = OrderMarginCheck(attachedInstrument, true, addOnOrderAction, nextAddOnCount, buyPositionVolumeSize, sellPositionVolumeSize);

                                                        /*
                                                        Print(" i=" + i + " stillPassedPositionMaxVolumeCheck=" + stillPassedPositionMaxVolumeCheck
                                                            + " stillPassedIntradayMarginCheck=" + stillPassedIntradayMarginCheck
                                                            + " stillPassedIntradayMarginCheck=" + stillPassedIntradayMarginCheck
                                                            + " read=" + (autoAddOnMaxDollarsFlipped <= nextAddOnTotalDollars)
                                                            + " nextAddOnTotalDollars=" + nextAddOnTotalDollars
                                                            + " newAddOnVolume=" + newAddOnVolume);
                                                        */

                                                        if (stillPassedPositionMaxVolumeCheck
                                                            && stillPassedIntradayMarginCheck
                                                            && autoAddOnMaxDollarsFlipped <= nextAddOnTotalDollars)
                                                        {
                                                            newAddOnVolume = i;
                                                        }
                                                        else
                                                        {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        /*
                                        RealLogger.PrintOutput(" passedPositionMaxVolumeCheck=" + passedPositionMaxVolumeCheck
                                            + " passedIntradayMarginCheck=" + passedIntradayMarginCheck
                                            + " passedNextAddOnCheck =" + passedNextAddOnCheck
                                            + " newAddOnVolume =" + newAddOnVolume
                                            );
                                        */


                                        if (!passedNextAddOnCheck)
                                        {
                                            RealLogger.PrintOutput("Auto AddOn detected current stop-loss risk dollars too high to add more volume" + " via " + signalName);
                                        }
                                        else if (!passedIntradayMarginCheck)
                                        {
                                            RealLogger.PrintOutput("Auto AddOn detected excess intraday margin too low to add more volume" + " via " + signalName);
                                        }

                                        DisableAutoAddOnButton(0);

                                        if (passedPositionMaxVolumeCheck
                                            && passedIntradayMarginCheck
                                            && passedNextAddOnCheck)
                                        {
                                            if (!position.HasStateChanged()
                                            && !position.IsFlat()
                                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                RealLogger.PrintOutput("AutoAddOn event triggered and now opening market " + addOnOrderAction.ToString().ToLower() + " order with volume " + newAddOnVolume + " via " + signalName);

                                                SubmitMarketOrder(signalName, attachedInstrument, addOnOrderAction, OrderEntry.Automated, newAddOnVolume);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    bool fullyEnabled = lastAddOnMaxCycleChangeTime <= GetDateTimeNow();

                    if (fullyEnabled)
                    {
                        lastAddOnMaxCycleChangeTime = (GetDateTimeNow()).AddSeconds(AutoAddOnMaxCycleDelaySeconds);

                        if (IsAccountFlat(attachedInstrument))
                            RealLogger.PrintOutput("ERROR: Auto AddOn requires a position.  No position found for instrument '" + attachedInstrument.FullName + "'" + " via " + signalName);

                        DisableAutoAddOnButton(0);
                    }
                }
            }
        }

        private void AttemptToEngagePopDelayedEntry()
        {
            string signalName = "PopDelayedEntry";

            if ((useBuyPopActivateFlag || useSellPopActivateFlag)
                && RealOrderService.AreAllOrderUpdateCyclesComplete()
                && PopDelayedEntryRunOncePerBar.IsFirstRunThisBar)
            {
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();

                bool allowNewAutoPilotEntries = AllowNewAutoPilotOrders(attachedInstrument);

                if (!allowNewAutoPilotEntries)
                {
                    RealLogger.PrintOutput("ERROR: Blocking new Pop Delayed Entry orders as stop-loss equity remaining floor hit." + " via " + signalName);
                }
                else
                {
                    if (useBuyPopActivateFlag)
                    {
                        bool isAutoPilotProfilePeppy = currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy;
                        bool isAutoPilotProfileSleepy = currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Sleepy;
                        bool isAboveRushLine = previous1ClosePrice >= autoCloseAndTrailRLValue;
                        bool isBelowRushLine = previous1ClosePrice <= autoCloseAndTrailRLValue;
                        bool buyCreeperContinuation = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;
                        bool sellCreeperContinuation = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                        bool passedLimitToPullbackCheck = (!popLimitToPullbackFlag) || (popLimitToPullbackFlag && IsInValidBuyPopPullBack());

                        bool passedLimitPopAlignedCreeper = (!isAutoPilotProfilePeppy || !UsePeppyLimitPopAlignedCreeper)
                            || (isAutoPilotProfilePeppy && UsePeppyLimitPopAlignedCreeper && buyCreeperContinuation);
                        bool passedLimitPopCounterCreeper = (!isAutoPilotProfileSleepy || !UseSleepyLimitPopCounterCreeper)
                            || (isAutoPilotProfileSleepy && UseSleepyLimitPopCounterCreeper && sellCreeperContinuation);

                        bool passedLimitPopAlignedRushLine = (!isAutoPilotProfilePeppy || !UsePeppyLimitPopAlignedRushLine)
                            || (isAutoPilotProfilePeppy && UsePeppyLimitPopAlignedRushLine && isAboveRushLine);
                        bool passedLimitPopCounterRushLine = (!isAutoPilotProfileSleepy || !UseSleepyLimitPopCounterRushLine)
                            || (isAutoPilotProfileSleepy && UseSleepyLimitPopCounterRushLine && isBelowRushLine);

                        int popDropBuyCount = 0;
                        int popDropSellCount = 0;

                        bool passedNoExistingPopOrderCheck = !GetPopDropOrderCount(out popDropBuyCount, out popDropSellCount);

                        /*
                        Print("*** DEBUG passedLimitToPullbackCheck=" + passedLimitToPullbackCheck
                            + " passedLimitPopAlignedCreeper=" + passedLimitPopAlignedCreeper
                            + " passedLimitPopCounterCreeper=" + passedLimitPopCounterCreeper
                            + " passedLimitPopAlignedRushLine=" + passedLimitPopAlignedRushLine
                            + " passedLimitPopCounterRushLine=" + passedLimitPopCounterRushLine);
                        */

                        if (passedNoExistingPopOrderCheck
                            && passedLimitToPullbackCheck
                            && (passedLimitPopAlignedCreeper || passedLimitPopAlignedRushLine)
                            && (passedLimitPopCounterCreeper || passedLimitPopCounterRushLine))
                        {
                            DecrementBuyPopDelayedTradeCount(signalName);

                            //RealLogger.PrintOutput("Attempting to open a buy stop order (" + attachedInstrument.FullName + ") via " + signalName);
                            HandleBuyPop(signalName);
                        }
                        else
                        {
                            return;
                        }
                    }
                    else if (useSellPopActivateFlag)
                    {
                        bool isAutoPilotProfilePeppy = currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy;
                        bool isAutoPilotProfileSleepy = currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Sleepy;
                        bool isAboveRushLine = previous1ClosePrice >= autoCloseAndTrailRLValue;
                        bool isBelowRushLine = previous1ClosePrice <= autoCloseAndTrailRLValue;
                        bool buyCreeperContinuation = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;
                        bool sellCreeperContinuation = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                        bool passedLimitToPullbackCheck = (!popLimitToPullbackFlag) || (popLimitToPullbackFlag && IsInValidSellPopPullBack());

                        bool passedLimitPopAlignedCreeper = (!isAutoPilotProfilePeppy || !UsePeppyLimitPopAlignedCreeper)
                            || (isAutoPilotProfilePeppy && UsePeppyLimitPopAlignedCreeper && sellCreeperContinuation);
                        bool passedLimitPopCounterCreeper = (!isAutoPilotProfileSleepy || !UseSleepyLimitPopCounterCreeper)
                            || (isAutoPilotProfileSleepy && UseSleepyLimitPopCounterCreeper && buyCreeperContinuation);

                        bool passedLimitPopAlignedRushLine = (!isAutoPilotProfilePeppy || !UsePeppyLimitPopAlignedRushLine)
                            || (isAutoPilotProfilePeppy && UsePeppyLimitPopAlignedRushLine && isBelowRushLine);
                        bool passedLimitPopCounterRushLine = (!isAutoPilotProfileSleepy || !UseSleepyLimitPopCounterRushLine)
                            || (isAutoPilotProfileSleepy && UseSleepyLimitPopCounterRushLine && isAboveRushLine);

                        int popDropBuyCount = 0;
                        int popDropSellCount = 0;

                        bool passedNoExistingPopOrderCheck = !GetPopDropOrderCount(out popDropBuyCount, out popDropSellCount);
                        /*
                        Print("*** DEBUG passedLimitToPullbackCheck=" + passedLimitToPullbackCheck
                            + " passedLimitPopAlignedCreeper=" + passedLimitPopAlignedCreeper
                            + " passedLimitPopCounterCreeper=" + passedLimitPopCounterCreeper
                            + " passedLimitPopAlignedRushLine=" + passedLimitPopAlignedRushLine
                            + " passedLimitPopCounterRushLine=" + passedLimitPopCounterRushLine);
                        */

                        if (passedNoExistingPopOrderCheck
                            && passedLimitToPullbackCheck
                            && (passedLimitPopAlignedCreeper || passedLimitPopAlignedRushLine)
                            && (passedLimitPopCounterCreeper || passedLimitPopCounterRushLine))
                        {
                            DecrementSellPopDelayedTradeCount(signalName);

                            //RealLogger.PrintOutput("Attempting to open a buy stop order (" + attachedInstrument.FullName + ") via " + signalName);
                            HandleSellPop(signalName);
                        }
                        else
                        {
                            return;
                        }
                    }
                }

                //DeactivatePopDelayedEntryFeatures(signalName);
            }
        }

        private void AttemptToEngageAutoPilot()
        {
            string signalName = "AttemptToEngageAutoPilot";

            bool autoPilotIsInAlertMode = (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup);

            if ((IsAccountFlat(attachedInstrument) || useAutoPilotAddOnFlag || autoPilotIsInAlertMode)
                && RealOrderService.AreAllOrderUpdateCyclesComplete()
                && AutoPilotRunOncePerBar.IsFirstRunThisBar)
            {
                AutoPilotRunOncePerBar.SetRunCompletedThisBar();

                if ((currentTradeSignalStatus != TickHunterTradeSignalTypes.Disabled && currentAutoPilotStatus != TickHunterAutoPilotTypes.Disabled)
                    || currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.Disabled)
                {
                    bool allowNewAutoPilotEntries = AllowNewAutoPilotOrders(attachedInstrument);

                    if (!allowNewAutoPilotEntries)
                    {
                        RealLogger.PrintOutput("ERROR: Blocking new AutoPilot orders as stop-loss equity remaining floor hit." + " via " + signalName);
                        DeactivateAutoEntryFeatures(signalName);
                    }
                    else
                    {
                        signalName = "AutoPilot";
                        string algoSetupName = "AutoPilot";
                        MarketPosition openMarketPosition = MarketPosition.Flat;
                        //RealLogger.PrintOutput("Trade signal autoPilotBullishTrend=" + autoPilotBullishTrend + " currentTradeSignalStatus= " + currentTradeSignalStatus);// + " autoPilotBullishTrend= " + autoPilotBullishTrend + " tradeSignalBullishMicroTrend=" + tradeSignalBullishMicroTrend + " tradeSignalBullishMicroTrendPrevious=" + tradeSignalBullishMicroTrendPrevious);

                        bool requireSpeedLineCheck = UseAutoPilotSpeedLineFilter;
                        bool passedBuySpeedLineFilterCheck = false;
                        bool passedSellSpeedLineFilterCheck = false;
                        bool isCloseAboveSpeedLine = (autoPilotSpeedLineFilterValue <= previous1ClosePrice);
                        bool isCloseAboveSpeedLine2 = (autoPilotSpeedLineFilterValue2 <= previous2ClosePrice);
                        bool isCloseAboveSpeedLine3 = (autoPilotSpeedLineFilterValue3 <= previous3ClosePrice);
                        bool isCloseAboveSpeedLine4 = (autoPilotSpeedLineFilterValue4 <= previous4ClosePrice);
                        bool isCloseAboveSpeedLine5 = (autoPilotSpeedLineFilterValue5 <= previous5ClosePrice);
                        bool isCloseAboveSpeedLine6 = (autoPilotSpeedLineFilterValue6 <= previous6ClosePrice);
                        bool isCloseAboveSpeedLine7 = (autoPilotSpeedLineFilterValue7 <= previous7ClosePrice);
                        bool isCloseAboveSpeedLine8 = (autoPilotSpeedLineFilterValue8 <= previous8ClosePrice);
                        bool isCloseAboveSpeedLine9 = (autoPilotSpeedLineFilterValue9 <= previous9ClosePrice);

                        bool buyZombieBoostedSetup = (autoPilotSetupZombieBuySetup2 && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup3 && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup4 && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup5 && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup6 && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup7 && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup8 && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup9 && autoPilotSetupZombieBuyContinuation8 && !previous8CandleBullish && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish);


                        bool sellZombieBoostedSetup = (autoPilotSetupZombieSellSetup2 && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup3 && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup4 && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup5 && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup6 && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup7 && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup8 && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup9 && autoPilotSetupZombieSellContinuation8 && previous8CandleBullish && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish);

                        //bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                        //bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;

                        bool buyZombieSetup = (autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode)
                            || (requireSpeedLineCheck &&
                                (
                                    (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && autoPilotSetupZombieValue3 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && autoPilotSetupZombieValue4 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && autoPilotSetupZombieValue5 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && autoPilotSetupZombieValue6 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && !isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupBuyCode && autoPilotSetupZombieValue7 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && !isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupBuyCode && !isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupBuyCode && autoPilotSetupZombieValue8 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && !isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupBuyCode && !isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupBuyCode && !isCloseAboveSpeedLine8 && autoPilotSetupZombieValue8 == ZombieSetupBuyCode && autoPilotSetupZombieValue9 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && !isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupBuyCode && !isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupBuyCode && !isCloseAboveSpeedLine8 && autoPilotSetupZombieValue8 == ZombieSetupBuyCode && !isCloseAboveSpeedLine9 && autoPilotSetupZombieValue9 == ZombieSetupBuyCode && autoPilotSetupZombieValue10 == ZombieSetupSellCode)
                                )
                            );

                        bool sellZombieSetup = (autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode)
                            || (requireSpeedLineCheck &&
                                (
                                    (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && autoPilotSetupZombieValue3 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && autoPilotSetupZombieValue4 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && autoPilotSetupZombieValue5 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && autoPilotSetupZombieValue6 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupSellCode && autoPilotSetupZombieValue7 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupSellCode && isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupSellCode && autoPilotSetupZombieValue8 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupSellCode && isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupSellCode && isCloseAboveSpeedLine8 && autoPilotSetupZombieValue8 == ZombieSetupSellCode && autoPilotSetupZombieValue9 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupSellCode && isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupSellCode && isCloseAboveSpeedLine8 && autoPilotSetupZombieValue8 == ZombieSetupSellCode && isCloseAboveSpeedLine9 && autoPilotSetupZombieValue9 == ZombieSetupSellCode && autoPilotSetupZombieValue10 == ZombieSetupBuyCode)
                                )
                            );

                        bool buyCreeperZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode
                            && (autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2);
                        bool sellCreeperZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode
                            && (autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2);

                        bool buyRiverFilter = (previous1ClosePrice >= autoCloseAndTrailMA4Value);
                        bool sellRiverFilter = (previous1ClosePrice < autoCloseAndTrailMA4Value);

                        bool buyDriftFilter = (previous1ClosePrice >= autoCloseAndTrailDL4Value);
                        bool sellDriftFilter = (previous1ClosePrice < autoCloseAndTrailDL4Value);

                        bool buyZombieRiverBreak = autoPilotSetupZombieBuyContinuation1
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9 && previous10ClosePrice < autoCloseAndTrailMA4Value10)
                            );

                        bool sellZombieRiverBreak = autoPilotSetupZombieSellContinuation1
                            && (
                                (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9 && previous10ClosePrice >= autoCloseAndTrailMA4Value10)
                            );

                        bool buyZombieDriftBreak = autoPilotSetupZombieBuyContinuation1
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10)
                            );

                        bool sellZombieDriftBreak = autoPilotSetupZombieSellContinuation1
                            && (
                                (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10)
                            );


                        bool buyWalkerSetup = (!AutoPilotSetupWalkerFreshCrossOnly && autoPilotSetupWalkerValue <= previous1ClosePrice) ||
                            (AutoPilotSetupWalkerFreshCrossOnly && autoPilotSetupWalkerValue <= previous1ClosePrice && autoPilotSetupWalkerValue2 > previous2ClosePrice);
                        bool sellWalkerSetup = (!AutoPilotSetupWalkerFreshCrossOnly && autoPilotSetupWalkerValue > previous1ClosePrice) ||
                            (AutoPilotSetupWalkerFreshCrossOnly && autoPilotSetupWalkerValue > previous1ClosePrice && autoPilotSetupWalkerValue2 <= previous2ClosePrice);
                        /*
                        bool buyCreeperSetup = (previous1CandleBullish && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3)
                            || (previous1CandleBullish && !previous2CandleBullish && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4 && autoPilotSetupCreeperValue4 < autoPilotSetupCreeperValue5)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && autoPilotSetupCreeperValue4 >= autoPilotSetupCreeperValue5 && autoPilotSetupCreeperValue5 < autoPilotSetupCreeperValue6)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && autoPilotSetupCreeperValue5 >= autoPilotSetupCreeperValue6 && autoPilotSetupCreeperValue6 < autoPilotSetupCreeperValue7)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && autoPilotSetupCreeperValue6 >= autoPilotSetupCreeperValue7 && autoPilotSetupCreeperValue7 < autoPilotSetupCreeperValue8)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && !previous7CandleBullish && autoPilotSetupCreeperValue7 >= autoPilotSetupCreeperValue8 && autoPilotSetupCreeperValue8 < autoPilotSetupCreeperValue9)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && !previous7CandleBullish && !previous8CandleBullish && autoPilotSetupCreeperValue8 >= autoPilotSetupCreeperValue9 && autoPilotSetupCreeperValue9 < autoPilotSetupCreeperValue10);

                        bool sellCreeperSetup = (!previous1CandleBullish && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3)
                            || (!previous1CandleBullish && previous2CandleBullish && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4 && autoPilotSetupCreeperValue4 >= autoPilotSetupCreeperValue5)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && autoPilotSetupCreeperValue4 < autoPilotSetupCreeperValue5 && autoPilotSetupCreeperValue5 >= autoPilotSetupCreeperValue6)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && autoPilotSetupCreeperValue5 < autoPilotSetupCreeperValue6 && autoPilotSetupCreeperValue6 >= autoPilotSetupCreeperValue7)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && autoPilotSetupCreeperValue6 < autoPilotSetupCreeperValue7 && autoPilotSetupCreeperValue7 >= autoPilotSetupCreeperValue8)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && previous7CandleBullish && autoPilotSetupCreeperValue7 < autoPilotSetupCreeperValue8 && autoPilotSetupCreeperValue8 >= autoPilotSetupCreeperValue9)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && previous7CandleBullish && previous8CandleBullish && autoPilotSetupCreeperValue8 < autoPilotSetupCreeperValue9 && autoPilotSetupCreeperValue9 >= autoPilotSetupCreeperValue10);
                        */

                        bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;
                        bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;
                        bool altBuyCreeperSetup2 = autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4;
                        bool altSellCreeperSetup2 = autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4;

                        bool altBuyZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                        bool altSellZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                        bool altBuyZombieSetup2 = autoPilotSetupZombieValue2 == ZombieSetupBuyCode && autoPilotSetupZombieValue3 == ZombieSetupSellCode;
                        bool altSellZombieSetup2 = autoPilotSetupZombieValue2 == ZombieSetupSellCode && autoPilotSetupZombieValue3 == ZombieSetupBuyCode;

                        bool buyCreeperSetup = altBuyCreeperSetup1;
                        bool sellCreeperSetup = altSellCreeperSetup1;

                        bool buyCreeperDriftSetup = (previous1ClosePrice >= autoCloseAndTrailDL4Value
                            && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3);

                        bool sellCreeperDriftSetup = (previous1ClosePrice < autoCloseAndTrailDL4Value
                            && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3);

                        bool buyCreeperDriftBreak = autoPilotSetupCreeperBuyContinuation1
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10)
                            );

                        bool sellCreeperDriftBreak = autoPilotSetupCreeperSellContinuation1
                            && (
                                (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10)
                            );

                        int maAboveDL4Count = 0;
                        if (autoCloseAndTrailDL1Value >= autoCloseAndTrailDL4Value) maAboveDL4Count++;
                        if (autoCloseAndTrailDL2Value >= autoCloseAndTrailDL4Value) maAboveDL4Count++;
                        if (autoCloseAndTrailDL3Value >= autoCloseAndTrailDL4Value) maAboveDL4Count++;
                        if (autoCloseAndTrailRLValue >= autoCloseAndTrailDL4Value) maAboveDL4Count++;


                        int maBelowDL4Count = 0;
                        if (autoCloseAndTrailDL1Value <= autoCloseAndTrailDL4Value) maBelowDL4Count++;
                        if (autoCloseAndTrailDL2Value <= autoCloseAndTrailDL4Value) maBelowDL4Count++;
                        if (autoCloseAndTrailDL3Value <= autoCloseAndTrailDL4Value) maBelowDL4Count++;
                        if (autoCloseAndTrailRLValue <= autoCloseAndTrailDL4Value) maBelowDL4Count++;

                        bool buyXCreeperDriftSetup = (previous1ClosePrice >= autoCloseAndTrailDL4Value
                            && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3)
                            && maAboveDL4Count >= 2;

                        bool sellXCreeperDriftSetup = (previous1ClosePrice < autoCloseAndTrailDL4Value
                            && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3)
                            && maBelowDL4Count >= 2;

                        bool buyXCreeperDriftBreak = autoPilotSetupCreeperBuyContinuation1
                            && maAboveDL4Count >= 2
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10 && previous11ClosePrice < autoCloseAndTrailDL4Value11)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10 && previous11ClosePrice >= autoCloseAndTrailDL4Value11 && previous12ClosePrice < autoCloseAndTrailDL4Value12)
                            );

                        bool sellXCreeperDriftBreak = autoPilotSetupCreeperSellContinuation1
                            && maBelowDL4Count >= 2
                            && (
                                (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10 && previous11ClosePrice >= autoCloseAndTrailDL4Value11)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10 && previous11ClosePrice < autoCloseAndTrailDL4Value11 && previous12ClosePrice >= autoCloseAndTrailDL4Value12)
                            );

                        bool buyCreeperRiverSetup = (previous1ClosePrice >= autoCloseAndTrailMA4Value
                            && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3);

                        bool sellCreeperRiverSetup = (previous1ClosePrice < autoCloseAndTrailMA4Value
                            && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3);

                        bool buyCreeperRiverBreak = autoPilotSetupCreeperBuyContinuation1
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9 && previous10ClosePrice < autoCloseAndTrailMA4Value10)
                            );

                        bool sellCreeperRiverBreak = autoPilotSetupCreeperSellContinuation1
                            && (
                                (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9 && previous10ClosePrice >= autoCloseAndTrailMA4Value10)
                            );

                        bool recentNewHigh = stingRayRecentHigherHighValue == StingRayHigherHighCode;
                        bool buyCreeperContinuation = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;
                        bool recentNewLow = stingRayRecentLowerLowValue == StingRayLowerLowCode;
                        bool sellCreeperContinuation = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                        bool buyStingRayBreakSetup = (recentNewHigh && buyCreeperContinuation);
                        bool sellStingRayBreakSetup = (recentNewLow && sellCreeperContinuation);

                        /*
                        bool buyZombieStackedSetup = (altBuyZombieSetup1 && altBuyCreeperSetup1)
                            || (altBuyZombieSetup1 && altBuyCreeperSetup2)
                            || (altBuyZombieSetup2 && altBuyCreeperSetup1)
                            || (altBuyZombieSetup1 && autoPilotSetupCreeperBuyContinuation1);

                        bool sellZombieStackedSetup = (altSellZombieSetup1 && altSellCreeperSetup1)
                            || (altSellZombieSetup1 && altSellCreeperSetup2)
                            || (altSellZombieSetup2 && altSellCreeperSetup1)
                            || (altSellZombieSetup1 && autoPilotSetupCreeperSellContinuation1);
                        */

                        bool buyZombieStackedSetup = (altBuyZombieSetup1 && autoPilotSetupCreeperBuyContinuation1)
                            || (altBuyCreeperSetup1 && autoPilotSetupZombieBuyContinuation1);

                        bool sellZombieStackedSetup = (altSellZombieSetup1 && autoPilotSetupCreeperSellContinuation1)
                            || (altSellCreeperSetup1 && autoPilotSetupZombieSellContinuation1);

                        if (requireSpeedLineCheck)
                        {
                            passedBuySpeedLineFilterCheck = isCloseAboveSpeedLine;
                            passedSellSpeedLineFilterCheck = !isCloseAboveSpeedLine;
                        }
                        else
                        {
                            passedBuySpeedLineFilterCheck = true;
                            passedSellSpeedLineFilterCheck = true;
                        }

                        bool isPriceAboveDL3 = previous1ClosePrice >= autoCloseAndTrailDL3Value;
                        bool isPriceBelowDL3 = previous1ClosePrice <= autoCloseAndTrailDL3Value;
                        bool isPriceAboveDL4 = previous1ClosePrice >= autoCloseAndTrailDL4Value;
                        bool isPriceBelowDL4 = previous1ClosePrice <= autoCloseAndTrailDL4Value;

                        bool isPriceAbovePBMiddle = previous1ClosePrice >= snapPowerBoxMiddleValue;
                        bool isPriceBelowPBMiddle = previous1ClosePrice <= snapPowerBoxMiddleValue;

                        bool isPriceAboveCreek1Edge = previous1ClosePrice >= autoCloseAndTrailDL3LValue;
                        bool isPriceBelowCreek1Edge = previous1ClosePrice <= autoCloseAndTrailDL3HValue;

                        bool isPriceAboveCreek5Edge = previous1ClosePrice >= autoCloseAndTrailDL4LValue;
                        bool isPriceBelowCreek5Edge = previous1ClosePrice <= autoCloseAndTrailDL4HValue;

                        bool usingAutoPilotLiteAlerts = (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup);

                        bool usingAutoPilotPopOrders = (currentAutoPilotOrderStatus == TickHunterAutoPilotOrderTypes.MarketPop);

                        bool twoOrMoreBullish = (previous1CandleBullish && previous2CandleBullish)
                            || (previous1CandleBullish && previous3CandleBullish)
                            || (previous2CandleBullish && previous3CandleBullish);

                        bool twoOrMoreBearish = (!previous1CandleBullish && !previous2CandleBullish)
                            || (!previous1CandleBullish && !previous3CandleBullish)
                            || (!previous2CandleBullish && !previous3CandleBullish);

                        bool buySlider = usingAutoPilotPopOrders
                            && twoOrMoreBearish
                            && previous1HighPrice <= previous2HighPrice && previous2HighPrice <= previous3HighPrice
                            && previous1HighPrice <= autoCloseAndTrailRLValue
                            && previous2HighPrice <= autoCloseAndTrailRLValue2
                            && previous3HighPrice <= autoCloseAndTrailRLValue3;

                        bool sellSlider = usingAutoPilotPopOrders
                            && twoOrMoreBullish
                            && previous1LowPrice >= previous2LowPrice && previous2LowPrice >= previous3LowPrice
                            && previous1LowPrice >= autoCloseAndTrailRLValue
                            && previous2LowPrice >= autoCloseAndTrailRLValue2
                            && previous3LowPrice >= autoCloseAndTrailRLValue3;


                        bool isAltSetupFlag = false;

                        /*
                        bool buyPeppySetupCombo = isPriceBelowDL4 && altBuyCreeperSetup1;
                        bool sellPeppySetupCombo = isPriceAboveDL4 && altSellCreeperSetup1;

                        bool buyPeppySetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceAboveDL4 && altBuyCreeperSetup1) || buyZombieSetup);
                        bool sellPeppySetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceBelowDL4 && altSellCreeperSetup1) || sellZombieSetup);
                        */


                        bool buyPeppySetupCombo = false;
                        bool sellPeppySetupCombo = false;

                        bool buyPeppySetupAltCombo = false;
                        bool sellPeppySetupAltCombo = false;

                        bool buySleepySetupCombo = false;
                        bool sellSleepySetupCombo = false;

                        bool buySleepySetupAltCombo = false;
                        bool sellSleepySetupAltCombo = false;


                        bool profileSetupZombieOnly = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly);
                        bool profileSetupCreeperOnly = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly);
                        bool profileSetupSliderOnly = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.SliderOnly);
                        bool profileSetupZombieOrSliderCombo = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOrSliderCombo);
                        bool profileSetupCreeperOrSliderCombo = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOrSliderCombo);
                        bool profileSetupZombieOrCreeperCombo = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOrCreeperCombo);
                        bool profileSetupZombieOrCreeperOrSliderCombo = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOrCreeperOrSliderCombo);


                        if (currentAutoPilotProfileStatus != TickHunterAutoPilotProfileTypes.Disabled)
                        {
                            if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                            {
                                buyPeppySetupCombo = buyZombieSetup;
                                sellPeppySetupCombo = sellZombieSetup;

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && buyZombieSetup);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && sellZombieSetup);
                            }
                            else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                            {
                                buyPeppySetupCombo = altBuyCreeperSetup1;
                                sellPeppySetupCombo = altSellCreeperSetup1;

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && altBuyCreeperSetup1);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && altSellCreeperSetup1);
                            }
                            else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.SliderOnly)
                            {
                                buyPeppySetupCombo = buySlider;
                                sellPeppySetupCombo = sellSlider;

                                buySleepySetupCombo = (buySlider);
                                sellSleepySetupCombo = (sellSlider);
                            }
                            else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOrSliderCombo)
                            {
                                buyPeppySetupCombo = buyZombieSetup;
                                sellPeppySetupCombo = sellZombieSetup;

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && buyZombieSetup) || (buySlider);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && sellZombieSetup) || (sellSlider);
                            }
                            else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOrSliderCombo)
                            {
                                buyPeppySetupCombo = altBuyCreeperSetup1;
                                sellPeppySetupCombo = altSellCreeperSetup1;

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && altBuyCreeperSetup1) || (buySlider);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && altSellCreeperSetup1) || (sellSlider);
                            }
                            else
                            {
                                buyPeppySetupCombo = altBuyCreeperSetup1;
                                sellPeppySetupCombo = altSellCreeperSetup1;

                                buyPeppySetupAltCombo = usingAutoPilotLiteAlerts && (buyZombieSetup || buySlider);
                                sellPeppySetupAltCombo = usingAutoPilotLiteAlerts && (sellZombieSetup || sellSlider);

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && altBuyCreeperSetup1);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && altSellCreeperSetup1);

                                buySleepySetupAltCombo = usingAutoPilotLiteAlerts && (((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && buyZombieSetup) || buySlider);
                                sellSleepySetupAltCombo = usingAutoPilotLiteAlerts && (((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && sellZombieSetup) || sellSlider);

                                /*
                                buySlowRollSetupCombo = ((isPriceAboveCreek1Edge || isPriceAboveCreek5Edge) && (altBuyCreeperSetup1 || buyCreeperDriftBreak)) || (isPriceAbovePBMiddle && buySlider);
                                sellSlowRollSetupCombo = ((isPriceBelowCreek1Edge || isPriceBelowCreek5Edge) && (altSellCreeperSetup1 || sellCreeperDriftBreak)) || (isPriceBelowPBMiddle && sellSlider);

                                buySlowRollSetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceAboveCreek1Edge || isPriceAboveCreek5Edge) && (buyZombieSetup));
                                sellSlowRollSetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceBelowCreek1Edge || isPriceBelowCreek5Edge) && (sellZombieSetup));

                                buyEonRollSetupCombo = ((isPriceAboveCreek1Edge || isPriceAboveCreek5Edge) && (altBuyCreeperSetup1 || buyCreeperDriftBreak)) || (isPriceAbovePBMiddle && buySlider);
                                sellEonRollSetupCombo = ((isPriceBelowCreek1Edge || isPriceBelowCreek5Edge) && (altSellCreeperSetup1 || sellCreeperDriftBreak)) || (isPriceBelowPBMiddle && sellSlider);

                                buyEonRollSetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceAboveCreek1Edge || isPriceAboveCreek5Edge) && buyZombieSetup);
                                sellEonRollSetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceBelowCreek1Edge || isPriceBelowCreek5Edge) && sellZombieSetup);
                                */
                            }
                        }


                        bool isZombieSetupFlavor = false;
                        bool isCreeperSetupFlavor = false;
                        bool isSliderSetupFlavor = false;

                        if (buyZombieSetup && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombie";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellZombieSetup && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombie";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (buyZombieBoostedSetup && passedBuySpeedLineFilterCheck && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOnly
                            || currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOrStackedCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieBoosted";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellZombieBoostedSetup && passedSellSpeedLineFilterCheck && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOnly
                            || currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOrStackedCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieBoosted";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (buyZombieStackedSetup && passedBuySpeedLineFilterCheck && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieStackedOnly
                            || currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOrStackedCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieStacked";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellZombieStackedSetup && passedSellSpeedLineFilterCheck && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieStackedOnly
                            || currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOrStackedCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieStacked";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (((buyZombieSetup && buyRiverFilter) || buyZombieRiverBreak) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrRiverBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieOrRiverBreakCombo";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (((sellZombieSetup && sellRiverFilter) || sellZombieRiverBreak) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrRiverBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieOrRiverBreakCombo";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (((buyZombieSetup && buyDriftFilter) || buyZombieDriftBreak) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrDriftBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieOrDriftBreakCombo";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (((sellZombieSetup && sellDriftFilter) || sellZombieDriftBreak) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrDriftBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieOrDriftBreakCombo";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (buyWalkerSetup && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.WalkerOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyWalker";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellWalkerSetup && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.WalkerOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellWalker";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (buyCreeperSetup && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyCreeper";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellCreeperSetup && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellCreeper";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyCreeperDriftSetup || buyCreeperDriftBreak) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrDriftBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishDriftTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishDriftTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyCreeperOrDriftBreakCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellCreeperDriftSetup || sellCreeperDriftBreak) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrDriftBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishDriftTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishDriftTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellCreeperOrDriftBreakCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyCreeperRiverSetup || buyCreeperRiverBreak) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrRiverBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishRiverTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishRiverTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyCreeperOrRiverBreakCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellCreeperRiverSetup || sellCreeperRiverBreak) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrRiverBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishRiverTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishRiverTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellCreeperOrRiverBreakCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyStingRayBreakSetup && buyDriftFilter) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.StingRayBreakOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishRiverTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishRiverTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyStingRayBreakOnly";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellStingRayBreakSetup && sellDriftFilter) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.StingRayBreakOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishRiverTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishRiverTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellStingRayBreakOnly";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyCreeperSetup || buyCreeperZombieSetup) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrCZCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyCreeperOrCZCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellCreeperSetup || sellCreeperZombieSetup) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrCZCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellCreeperOrCZCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyCreeperSetup || buyZombieSetup) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrCreeperCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieOrCreeperCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellCreeperSetup || sellZombieSetup) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrCreeperCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieOrCreeperCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyPeppySetupCombo || buyPeppySetupAltCombo) && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.PeppySetupCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishDriftTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishDriftTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuySetupCombo-Peppy";

                            if (buySlider && (profileSetupSliderOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrSliderCombo))
                            {
                                algoSetupName = "BuySlider-Peppy";
                                isSliderSetupFlavor = true;
                            }
                            else if (altBuyCreeperSetup1 && (profileSetupCreeperOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrCreeperCombo))
                            {
                                algoSetupName = "BuyCreeper-Peppy";
                                isCreeperSetupFlavor = true;
                            }
                            else if (buyZombieSetup && (profileSetupZombieOnly || profileSetupZombieOrSliderCombo || profileSetupZombieOrCreeperOrSliderCombo))
                            {
                                algoSetupName = "BuyZombie-Peppy";
                                isZombieSetupFlavor = true;
                            }

                            isAltSetupFlag = buyPeppySetupAltCombo;

                            if (isAltSetupFlag) algoSetupName += " (Alt)";

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellPeppySetupCombo || sellPeppySetupAltCombo) && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.PeppySetupCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellSetupCombo-Peppy";

                            if (sellSlider && (profileSetupSliderOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrSliderCombo))
                            {
                                algoSetupName = "SellSlider-Peppy";
                                isSliderSetupFlavor = true;
                            }
                            else if (altSellCreeperSetup1 && (profileSetupCreeperOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrCreeperCombo))
                            {
                                algoSetupName = "SellCreeper-Peppy";
                                isCreeperSetupFlavor = true;
                            }
                            else if (sellZombieSetup && (profileSetupZombieOnly || profileSetupZombieOrSliderCombo || profileSetupZombieOrCreeperOrSliderCombo))
                            {
                                algoSetupName = "SellZombie-Peppy";
                                isZombieSetupFlavor = true;
                            }

                            isAltSetupFlag = sellPeppySetupAltCombo;

                            if (isAltSetupFlag) algoSetupName += " (Alt)";

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buySleepySetupCombo || buySleepySetupAltCombo) && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.SleepySetupCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuySetupCombo-Sleepy";

                            if (buySlider && (profileSetupSliderOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrSliderCombo))
                            {
                                algoSetupName = "BuySlider-Sleepy";
                                isSliderSetupFlavor = true;
                            }
                            else if (altBuyCreeperSetup1 && (profileSetupCreeperOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrCreeperCombo))
                            {
                                algoSetupName = "BuyCreeper-Sleepy";
                                isCreeperSetupFlavor = true;
                            }
                            else if (buyZombieSetup && (profileSetupZombieOnly || profileSetupZombieOrSliderCombo || profileSetupZombieOrCreeperOrSliderCombo))
                            {
                                algoSetupName = "BuyZombie-Sleepy";
                                isZombieSetupFlavor = true;
                            }


                            isAltSetupFlag = sellSleepySetupAltCombo;

                            if (isAltSetupFlag) algoSetupName += " (Alt)";

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellSleepySetupCombo || sellSleepySetupAltCombo) && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.SleepySetupCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellSetupCombo-Sleepy";

                            if (sellSlider && (profileSetupSliderOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrSliderCombo))
                            {
                                algoSetupName = "SellSlider-Sleepy";
                                isSliderSetupFlavor = true;
                            }
                            if (altSellCreeperSetup1 && (profileSetupCreeperOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrCreeperCombo))
                            {
                                algoSetupName = "SellCreeper-Sleepy";
                                isCreeperSetupFlavor = true;
                            }
                            else if (sellZombieSetup && (profileSetupZombieOnly || profileSetupZombieOrSliderCombo || profileSetupZombieOrCreeperOrSliderCombo))
                            {
                                algoSetupName = "SellZombie-Sleepy";
                                isZombieSetupFlavor = true;
                            }


                            isAltSetupFlag = sellSleepySetupAltCombo;

                            if (isAltSetupFlag) algoSetupName += " (Alt)";

                            openMarketPosition = MarketPosition.Short;
                        }


                        bool openNewPosition = (openMarketPosition == MarketPosition.Long || openMarketPosition == MarketPosition.Short);

                        if (openNewPosition)
                        {
                            int buyCount = 0;
                            int sellCount = 0;
                            bool hasPosition = GetPositionVolume(attachedInstrument, out buyCount, out sellCount);
                            bool isBuyAddOn = (useAutoPilotAddOnFlag && buyCount > 0 && openMarketPosition == MarketPosition.Long);
                            bool isSellAddOn = (useAutoPilotAddOnFlag && sellCount > 0 && openMarketPosition == MarketPosition.Short);
                            bool isReversalSetup = (autoPilotIsInAlertMode && hasPosition
                                && (buyCount > 0 && openMarketPosition == MarketPosition.Short
                                || sellCount > 0 && openMarketPosition == MarketPosition.Long));

                            if (!hasPosition || isBuyAddOn || isSellAddOn || isReversalSetup)
                            {

                                int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                                bool autoPilotMaxVolumeCheckRequired = AutoPilotMaxVolume > 0;
                                bool passedAutoPilotMaxVolumeCheck = false;

                                if (autoPilotMaxVolumeCheckRequired)
                                {
                                    int totalCombinedNewVolume = 0;
                                    int positionVolume = 0;

                                    if (openMarketPosition == MarketPosition.Long)
                                    {
                                        positionVolume = buyCount;

                                    }
                                    else if (openMarketPosition == MarketPosition.Short)
                                    {
                                        positionVolume = sellCount;
                                    }

                                    totalCombinedNewVolume = positionVolume + autoEntryVolume;

                                    if (totalCombinedNewVolume <= AutoPilotMaxVolume)
                                    {
                                        passedAutoPilotMaxVolumeCheck = true;
                                    }
                                    else
                                    {
                                        RealLogger.PrintOutput("BLOCKED: AutoPilot reached max volume of " + AutoPilotMaxVolume + " (AutoPilotMaxVolume) with an exiting position volume of " + positionVolume + " for a total combined new volume of " + totalCombinedNewVolume);
                                    }
                                }
                                else
                                {
                                    passedAutoPilotMaxVolumeCheck = true;
                                }


                                if (passedAutoPilotMaxVolumeCheck)
                                {
                                    if (isSliderSetupFlavor)
                                    {
                                        if (openMarketPosition == MarketPosition.Short)
                                        {
                                            if (usedSellSliderSetupCycle)
                                                return;
                                            else
                                                usedSellSliderSetupCycle = true;
                                        }
                                        else
                                        {
                                            if (usedBuySliderSetupCycle)
                                                return;
                                            else
                                                usedBuySliderSetupCycle = true;
                                        }
                                    }

                                    if (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup)
                                    {
                                        RealLogger.PrintOutput("AutoPilot detected " + algoSetupName + " setup and now opening trade alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);


                                        string orderTypeText = "BUY";

                                        if (openMarketPosition == MarketPosition.Short)
                                            orderTypeText = "SELL";

                                        string orderEntryTypeText = "market";

                                        if (currentAutoPilotOrderStatus == TickHunterAutoPilotOrderTypes.MarketPop)
                                            orderEntryTypeText = "Pop";


                                        string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                        string messageTitle = "";

                                        if (isCreeperSetupFlavor)
                                        {
                                            if (openMarketPosition == MarketPosition.Short)
                                            {
                                                messageTitle = isAltSetupFlag ? SellCreeperAlertAltMessageTitle : SellCreeperAlertMessageTitle;
                                            }
                                            else
                                            {
                                                messageTitle = isAltSetupFlag ? BuyCreeperAlertAltMessageTitle : BuyCreeperAlertMessageTitle;

                                            }
                                        }
                                        else if (isSliderSetupFlavor)
                                        {
                                            if (openMarketPosition == MarketPosition.Short)
                                            {
                                                messageTitle = isAltSetupFlag ? SellZombieAlertAltMessageTitle : SellSliderAlertMessageTitle;
                                            }
                                            else
                                            {
                                                messageTitle = isAltSetupFlag ? BuyZombieAlertAltMessageTitle : BuySliderAlertMessageTitle;
                                            }
                                        }
                                        else
                                        {
                                            if (openMarketPosition == MarketPosition.Short)
                                            {
                                                messageTitle = isAltSetupFlag ? SellZombieAlertAltMessageTitle : SellZombieAlertMessageTitle;
                                            }
                                            else
                                            {
                                                messageTitle = isAltSetupFlag ? BuyZombieAlertAltMessageTitle : BuyZombieAlertMessageTitle;
                                            }
                                        }

                                        string reverseMessageText = "";
                                        if (isReversalSetup) reverseMessageText = "close your existing position and ";

                                        string message = "AutoPilot detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to " + reverseMessageText + "open a " + orderEntryTypeText + " '" + orderTypeText + "' order with " + autoEntryVolume + " contract(s)?";

                                        ExitCloseAlertWindows();
                                        ExitTradeAlertWindows();

                                        if (PlaySoundOnSetupAlert)
                                        {
                                            PlaySound(fullSoundFilename);
                                        }

                                        ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                        {
                                            MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, !isAltSetupFlag);
                                            isTradeAlertMessageBoxOpen = true;
                                            //MessageBoxResult result = NinjaTrader.Gui.Tools.NTMessageBoxSimple.Show(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question);
                                            //MessageBoxResult result = MessageBox.Show((Window.GetWindow(ChartControl.OwnerChart as DependencyObject)), message, FullSystemName + " Trade Alert", MessageBoxButton.YesNoCancel, MessageBoxImage.Question, MessageBoxResult.No);

                                            if (result == MessageBoxResult.Yes)
                                            {
                                                if (currentAutoPilotOrderStatus == TickHunterAutoPilotOrderTypes.MarketPop)
                                                {
                                                    RealLogger.PrintOutput("AutoPilot trade alert prompt accepted " + algoSetupName + " setup and now opening Pop order for " + GetInstrumentPeriodText() + " (altsetup=" + isAltSetupFlag.ToString().ToLower() + ")" + " via " + signalName);

                                                    if (openMarketPosition == MarketPosition.Long)
                                                    {
                                                        double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                                        double highPrice = CalculateTrailHighPrice(MarketPosition.Long, true);
                                                        double highestPrice = Math.Max(askPrice, highPrice);
                                                        double newPopPrice = GetInitialPopPrice(MarketPosition.Long, highestPrice);

                                                        DeactivatePopDelayedEntryFeatures(signalName);
                                                        CancelPopDropOrders(signalName);

                                                        if (isReversalSetup) FlattenEverything(signalName, true, attachedInstrument);
                                                        CreateBuyStop(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                                                    }
                                                    else
                                                    {
                                                        double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                                        double lowPrice = CalculateTrailLowPrice(MarketPosition.Short, true);
                                                        double lowestPrice = Math.Min(bidPrice, lowPrice);
                                                        double newPopPrice = GetInitialPopPrice(MarketPosition.Short, lowestPrice);

                                                        DeactivatePopDelayedEntryFeatures(signalName);
                                                        CancelPopDropOrders(signalName);

                                                        if (isReversalSetup) FlattenEverything(signalName, true, attachedInstrument);
                                                        CreateSellStop(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                                                    }
                                                }
                                                else
                                                {
                                                    RealLogger.PrintOutput("AutoPilot trade alert prompt accepted " + algoSetupName + " setup and now opening market order for " + GetInstrumentPeriodText() + " (altsetup=" + isAltSetupFlag.ToString().ToLower() + ")" + " via " + signalName);

                                                    if (openMarketPosition == MarketPosition.Long)
                                                    {
                                                        DeactivatePopDelayedEntryFeatures(signalName);
                                                        CancelPopDropOrders(signalName);

                                                        if (isReversalSetup) FlattenEverything(signalName, true, attachedInstrument);
                                                        SubmitMarketOrder(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, autoEntryVolume);
                                                    }
                                                    else
                                                    {
                                                        DeactivatePopDelayedEntryFeatures(signalName);
                                                        CancelPopDropOrders(signalName);

                                                        if (isReversalSetup) FlattenEverything(signalName, true, attachedInstrument);
                                                        SubmitMarketOrder(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, autoEntryVolume);
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                RealLogger.PrintOutput("AutoPilot trade alert prompt declined for " + GetInstrumentPeriodText() + " (altsetup=" + isAltSetupFlag.ToString().ToLower() + ")" + " via " + signalName);
                                            }
                                        }));
                                    }
                                    else
                                    {
                                        if (UseAutoPilotLite) DisableAutoPilotLiteButton(0); else DecrementAutoPilotTradeCount();

                                        DeactivatePopDelayedEntryFeatures(signalName);
                                        CancelPopDropOrders(signalName);

                                        //RealLogger.PrintOutput("got here AutoPilot hasPosition=" + hasPosition + " buyCount=" + buyCount + " sellCount=" + sellCount + " isCloseAutoSlopeMinProfit=" + isCloseAutoSlopeMinProfit + " openMarketPosition=" + openMarketPosition);

                                        if (currentAutoPilotOrderStatus == TickHunterAutoPilotOrderTypes.MarketPop)
                                        {
                                            RealLogger.PrintOutput("AutoPilot detected " + algoSetupName + " setup and now opening Pop order" + " via " + signalName);

                                            if (openMarketPosition == MarketPosition.Long)
                                            {
                                                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                                double highPrice = CalculateTrailHighPrice(MarketPosition.Long, true);
                                                double highestPrice = Math.Max(askPrice, highPrice);
                                                double newPopPrice = GetInitialPopPrice(MarketPosition.Long, highestPrice);

                                                CreateBuyStop(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                                            }
                                            else
                                            {
                                                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                                double lowPrice = CalculateTrailLowPrice(MarketPosition.Short, true);
                                                double lowestPrice = Math.Min(bidPrice, lowPrice);
                                                double newPopPrice = GetInitialPopPrice(MarketPosition.Short, lowestPrice);

                                                CreateSellStop(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                                            }
                                        }
                                        else
                                        {
                                            RealLogger.PrintOutput("AutoPilot detected " + algoSetupName + " setup and now opening market order" + " via " + signalName);

                                            if (openMarketPosition == MarketPosition.Long)
                                            {
                                                SubmitMarketOrder(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, autoEntryVolume);
                                            }
                                            else
                                            {
                                                SubmitMarketOrder(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, autoEntryVolume);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                }
            }
        }



        private void DeactivateAutoEntryFeatures(string signalName)
        {
            if (UseAutoPilotLite)
            {
                if (currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.AlertSetup)
                {
                    DisableAutoPilotLiteButton(0);
                }
            }
            else
            {
                DisableAutoPilotButton(0);
            }

            DeactivatePopDelayedEntryFeatures(signalName);
        }

        private void DeactivatePopDelayedEntryFeatures(string signalName)
        {
            if (useBuyPopActivateFlag)
            {
                DeactivateBuyPopButton(signalName);
            }

            if (useSellPopActivateFlag)
            {
                DeactivateSellPopButton(signalName);
            }
        }

        public class MessageBoxMoreSimple : NinjaTrader.Gui.Tools.NTMessageBoxSimple
        {
            public static MessageBoxMoreSimple BuildMessageBox(Window parent, string message, string messageTitle, MessageBoxButton buttonType, MessageBoxImage imageType, Brush backgroundColor)
            {
                MessageBoxMoreSimple moreSimple = new MessageBoxMoreSimple();
                moreSimple.Title = messageTitle;
                moreSimple.Caption = message;
                moreSimple.ButtonSet = buttonType;
                moreSimple.MsgBoxImage = imageType;
                //moreSimple.Owner = parent;

                //backgroundColor.Freeze();
                //moreSimple.Background = backgroundColor;

                return moreSimple;
            }
            public static MessageBoxResult Show(NTMessageBoxSimple moreSimple)
            {
                return NinjaTrader.Gui.Tools.NTMessageBoxSimple.ShowInternal(moreSimple);
            }

            public MessageBoxMoreSimple()
            {


            }

        }

        private MessageBoxResult ShowMessageBox(Window parent, string message, string messageTitle, MessageBoxButton buttonType, MessageBoxImage imageType, bool useNativeColors = true)
        {
            MessageBoxResult result = MessageBoxResult.None;

            if (useNativeColors)
            {
                result = NinjaTrader.Gui.Tools.NTMessageBoxSimple.Show(parent, message, messageTitle, buttonType, imageType);
            }
            else
            {
                result = MessageBox.Show(parent, message, messageTitle, buttonType, imageType, MessageBoxResult.None);
            }

            return result;
        }

        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [System.Runtime.InteropServices.DllImport("user32.dll", CharSet = System.Runtime.InteropServices.CharSet.Auto)]
        static extern IntPtr SendMessage(IntPtr hWnd, UInt32 Msg, IntPtr wParam, IntPtr lParam);

        //[return: MarshalAs(UnmanagedType.Bool)]
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

        [System.Runtime.InteropServices.DllImport("user32")]
        private static extern bool SetForegroundWindow(IntPtr hwnd);

        [System.Runtime.InteropServices.DllImport("kernel32", SetLastError = true)]
        public static extern bool CloseHandle(IntPtr handle);

        [System.Runtime.InteropServices.DllImport("user32.dll")]
        static extern bool EndDialog(IntPtr hDlg, IntPtr nResult);

        //private const int WM_CLOSE = 0x0010;
        private const int WM_CLOSE = 0x10;
        private const int WM_COMMAND = 0x0011;
        private const int IDCANCEL = 2;
        private const int IDNO = 7;
        private const int WM_IME_NOTIFY = 0x0282;

        private const int WM_DESTROY = 0x0002;

        private const int WM_NCDESTROY = 0x0082;

        private const int IMN_CLOSESTATUSWINDOW = 0x0001;

        private const int WM_KILLFOCUS = 0x0008;


        private IntPtr GetHandleWindow(string title)
        {
            return FindWindow(null, title);
        }

        private void CloseAltMessageBox(string title)
        {
            IntPtr hwnd = GetHandleWindow(title);

            if (hwnd != IntPtr.Zero)
            {
                //Print("*** DEBUG found title=" + title);

                EndDialog(hwnd, (IntPtr)IDCANCEL);

                //CloseHandle(hwnd);

                //SetForegroundWindow(hwnd);

                //System.Windows.Forms.SendKeys.Send(System.Windows.Forms.Keys.Escape);

                //SendMessage(hwnd, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
                //SendMessage(hwnd, WM_COMMAND, idPointer, IntPtr.Zero);

            }
            else
            {
                //Print("*** DEBUG NOT found title=" + title);
            }
        }

        private void CloseMessageBox(string title)
        {
            IntPtr hwnd = GetHandleWindow(title);

            if (hwnd != IntPtr.Zero)
            {
                //Print("*** DEBUG found title=" + title);

                //EndDialog(hwnd, (IntPtr)IDCANCEL);

                SendMessage(hwnd, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);

                //CloseHandle(hwnd);

                //SetForegroundWindow(hwnd);

                //System.Windows.Forms.SendKeys.Send("{ESC}");

                //PostMessage(hwnd, WM_COMMAND, (IntPtr)IDCANCEL, IntPtr.Zero);

                //SendMessage(hwnd, WM_COMMAND, idPointer, IntPtr.Zero);

            }
            else
            {
                //Print("*** DEBUG NOT found title=" + title);
            }
        }

        private void CloseWindow(IntPtr hwnd)
        {
            if (hwnd != IntPtr.Zero)
            {
                SendMessage(hwnd, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
            }
        }

        /*
        private void AttemptToEngageAutobot()
        {
            if (1 == 2)
            {
                if (UseHedgehogEntry)
                {
                    lock (NewPositionLock)
                    {
                        int positionCount = RealPositionService.PositionCount;
                        int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);

                        for (int index = 0; index < positionCount; index++)
                        {
                            RealPosition position = null;
                            if (RealPositionService.TryGetByIndex(index, out position))
                            {
                                if (IsAccountFlat()
                                    && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                {
                                    if (HedgehogEntryBuySymbol1SellSymbol2)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Hedgehog Entry buy (" + HedgehogEntrySymbol1FullName + ") sell (" + HedgehogEntrySymbol2FullName + ")", PrintTo.OutputTab1);

                                        //Interlocked.Exchange(ref activeCloseOrderCount, Account.Orders.Count());
                                        Instrument buyInstrument = Instrument.GetInstrument(HedgehogEntrySymbol1FullName);

                                        SubmitMarketOrder(signalName, buyInstrument, OrderAction.Buy, OrderEntry.Automated, autoEntryVolume);


                                        //Order buyMarketorder = Account.CreateOrder(buyInstrument, OrderAction.Buy, OrderType.Market, OrderEntry.Automated, TimeInForce.Day, AutobotEntryQuantity, 0, 0, "", uniqueSignalKey, Core.Globals.MaxDate, null);
                                        //Account.Submit(new[] { buyMarketorder });

                                        //uniqueSignalKey = Guid.NewGuid().ToString();
                                        //inFlighOrderCache.Add(uniqueSignalKey, AutobotEntryQuantity);

                                        Instrument sellInstrument = Instrument.GetInstrument(HedgehogEntrySymbol2FullName);

                                        SubmitMarketOrder(signalName, sellInstrument, OrderAction.Sell, OrderEntry.Automated, autoEntryVolume);

                                        //Order sellMarketorder = Account.CreateOrder(sellInstrument, OrderAction.SellShort, OrderType.Market, OrderEntry.Automated, TimeInForce.Day, AutobotEntryQuantity, 0, 0, "", uniqueSignalKey, Core.Globals.MaxDate, null);
                                        //Account.Submit(new[] { sellMarketorder });
                                    }
                                    else
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Hedgehog Entry buy (" + HedgehogEntrySymbol2FullName + ") sell (" + HedgehogEntrySymbol1FullName + ")", PrintTo.OutputTab1);

                                        //uniqueSignalKey = Guid.NewGuid().ToString();
                                        //inFlighOrderCache.Add(uniqueSignalKey, AutobotEntryQuantity);

                                        //Interlocked.Exchange(ref lastOrderCount, Account.Orders.Count());

                                        Instrument buyInstrument = Instrument.GetInstrument(HedgehogEntrySymbol2FullName);

                                        SubmitMarketOrder(signalName, buyInstrument, OrderAction.Buy, OrderEntry.Automated, autoEntryVolume);

                                        //Order buyMarketorder = Account.CreateOrder(buyInstrument, OrderAction.Buy, OrderType.Market, OrderEntry.Automated, TimeInForce.Day, AutobotEntryQuantity, 0, 0, "", uniqueSignalKey, Core.Globals.MaxDate, null);
                                        //Account.Submit(new[] { buyMarketorder });

                                        //uniqueSignalKey = Guid.NewGuid().ToString();
                                        //inFlighOrderCache.Add(uniqueSignalKey, AutobotEntryQuantity);

                                        Instrument sellInstrument = Instrument.GetInstrument(HedgehogEntrySymbol1FullName);

                                        SubmitMarketOrder(signalName, sellInstrument, OrderAction.Sell, OrderEntry.Automated, autoEntryVolume);

                                        //Order sellMarketorder = Account.CreateOrder(sellInstrument, OrderAction.SellShort, OrderType.Market, OrderEntry.Automated, TimeInForce.Day, AutobotEntryQuantity, 0, 0, "", uniqueSignalKey, Core.Globals.MaxDate, null);
                                        //Account.Submit(new[] { sellMarketorder });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        */

        private bool IsLiveAccount(Account account)
        {
            bool isLiveAccount = false;

            if (account != null)
            {
                const string SimAccountPrefix = "Sim";
                const string DemoAccountPrefix = "DEMO";

                bool isSimAccount = account.Name.StartsWith(SimAccountPrefix, StringComparison.OrdinalIgnoreCase);
                bool isDemoAccount = account.Name.StartsWith(DemoAccountPrefix, StringComparison.OrdinalIgnoreCase);

                if (!isSimAccount && !isDemoAccount)
                {
                    isLiveAccount = true;
                }
            }

            return isLiveAccount;
        }

        DateTime lastWindowHiddenDetectionTime = DateTime.MinValue;
        const int WindowHiddenDetectionThrottleSeconds = 3;

        private void DetermineIfWindowHidden()
        {
            bool isNextCycleReady = lastWindowHiddenDetectionTime <= GetDateTimeNow();

            if (isNextCycleReady)
            {
                lastWindowHiddenDetectionTime = (GetDateTimeNow()).AddSeconds(WindowHiddenDetectionThrottleSeconds);

                if (ChartControl != null)
                {
                    if (ChartControl.Dispatcher.CheckAccess())
                    {
                        Window chartWindow = ChartControl.OwnerChart as Window;

                        if (chartWindow != null)
                        {
                            bool isWindowHidden = (chartWindow.Visibility == Visibility.Hidden);

                            if (isWindowHidden)
                            {
                                if (!isIndicatorSuspended)
                                {
                                    RealLogger.PrintOutput("Detecting chart window has been set to hidden...suspending " + FullSystemName + " (Workspace Switch)");
                                }

                                isIndicatorSuspended = true;
                            }
                            else
                            {
                                if (isIndicatorSuspended)
                                {
                                    RealLogger.PrintOutput("Detecting chart window has been reactivated...awakening " + FullSystemName + " (Workspace Switch)");
                                }

                                isIndicatorSuspended = false;
                            }
                        }
                    }
                    else
                    {
                        ChartControl.Dispatcher.InvokeAsync(() =>
                        {
                            Window chartWindow = ChartControl.OwnerChart as Window;

                            if (chartWindow != null)
                            {
                                bool isWindowHidden = (chartWindow.Visibility == Visibility.Hidden);

                                if (isWindowHidden)
                                {
                                    if (!isIndicatorSuspended)
                                    {
                                        RealLogger.PrintOutput("Detecting chart window has been set to hidden...suspending " + FullSystemName + " (Workspace Switch)");
                                    }

                                    isIndicatorSuspended = true;
                                }
                                else
                                {
                                    if (isIndicatorSuspended)
                                    {
                                        RealLogger.PrintOutput("Detecting chart window has been reactivated...awakening " + FullSystemName + " (Workspace Switch)");
                                    }

                                    isIndicatorSuspended = false;
                                }
                            }
                        });
                    }

                    //Print("*** DEBUG isIndicatorSuspended=" + isIndicatorSuspended + " slt=" + StopLossInitialTicks);
                }
            }
        }

        DateTime lastAccountInfoLogOutputTime = DateTime.MinValue;
        const int AccountInfoLoggingOutputThrottleSeconds = 60;
        private void AttemptAccountInfoLogging()
        {
            if (UseAccountInfoLogging)
            {
                bool isNextCycleReady = lastAccountInfoLogOutputTime <= GetDateTimeNow();

                if (isNextCycleReady)
                {
                    lastAccountInfoLogOutputTime = (GetDateTimeNow()).AddSeconds(AccountInfoLoggingOutputThrottleSeconds);

                    if (account != null && IsLiveAccount(account))
                    {
                        double accountBalance = Math.Round(account.Get(AccountItem.CashValue, Currency.UsDollar), 2);
                        double grossRealizedPnL = Math.Round(account.Get(AccountItem.GrossRealizedProfitLoss, Currency.UsDollar), 2);
                        double realizedPnL = Math.Round(account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);

                        double accountBalanceWithNewPnL = accountBalance;
                        //if (grossRealizedPnL != 0) accountBalanceWithNewPnL = accountBalance - grossRealizedPnL + realizedPnL;

                        if (accountBalanceWithNewPnL != lastAccountBalance && File.Exists(AccountInfoLoggingPath))
                        {
                            RealLogger.PrintOutput("Logging account information...", PrintTo.OutputTab2);
                            string content = "ACCOUNT_BALANCE,ACCOUNT_EQUITY\r\n" + Convert.ToString(accountBalanceWithNewPnL) + "," + Convert.ToString(accountBalanceWithNewPnL);
                            File.WriteAllText(AccountInfoLoggingPath, content);
                            lastAccountBalance = accountBalanceWithNewPnL;
                        }
                    }
                }
            }
        }

        /*
        private void LoadDayOverMaxLossHighestPnLInSessionData()
        {
            return;
            string fileNameAndPath = System.IO.Path.GetTempPath() + TickHunterSessionStateFileName;

            string formattedDateTime = GetDateTimeNow().ToString("d");
            DateTime currentDate = Convert.ToDateTime(formattedDateTime);

            if (File.Exists(fileNameAndPath))
            {
                using (StreamReader reader = new StreamReader(fileNameAndPath))
                {
                    string currentLine;
                    // currentLine will be null when the StreamReader reaches the end of file
                    while ((currentLine = reader.ReadLine()) != null)
                    {
                        // Search, case insensitive, if the currentLine contains the searched keyword
                        if (!(currentLine.IndexOf("DATE,ACCOUNT_ID,ACCOUNT_PNL", StringComparison.CurrentCultureIgnoreCase) >= 0))
                        {
                            RealLogger.PrintOutput("currentLine=" + currentLine);
                            string[] fields = currentLine.Split(',');
                            int fieldAccountId = Convert.ToInt32(fields[1]);
                            if (account.Id == fieldAccountId)
                            {
                                DateTime fieldDate = Convert.ToDateTime(fields[0]);
                                double fieldPnL = Convert.ToDouble(fields[2]);

                                RealLogger.PrintOutput("fieldAccountId=" + fieldAccountId + " date=" + fieldDate + " fieldPnL=" + fieldPnL);
                                bool needsToBeReset = fieldDate < currentDate;

                                if (needsToBeReset)
                                {
                                    lastDayOverMaxLossHighestPnLInSessionChangeDate = currentDate;
                                    lastDayOverMaxLossHighestPnLInSessionPnL = 0;
                                }
                                else
                                {
                                    lastDayOverMaxLossHighestPnLInSessionChangeDate = fieldDate;
                                    lastDayOverMaxLossHighestPnLInSessionPnL = fieldPnL;
                                }

                                RealLogger.PrintOutput("lastDayOverMaxLossHighestPnLInSessionChangeDate=" + lastDayOverMaxLossHighestPnLInSessionChangeDate + " lastDayOverMaxLossHighestPnLInSessionPnL=" + lastDayOverMaxLossHighestPnLInSessionPnL);
                            }
                        }
                    }
                }
            }
            else
            {
                lastDayOverMaxLossHighestPnLInSessionChangeDate = currentDate;
                lastDayOverMaxLossHighestPnLInSessionPnL = 0;
            }
        }
        */

        /*
         * private void StoreStateDayOverMaxLossHighestPnLInSession()
        {
            return; // debug
            try
            {
                string fileNameAndPath = System.IO.Path.GetTempPath() + TickHunterSessionStateFileName;
                string formattedDateTime = GetDateTimeNow().ToString("d");
                double realizedPnL;

                if (DebugLogLevel > 15) RealLogger.PrintOutput("Storing State in (" + fileNameAndPath + ")");

                StringBuilder content = new StringBuilder();

                content.Append("DATE,ACCOUNT_ID,ACCOUNT_PNL\r\n");

                foreach (Account accountItem in Account.All)
                {
                    realizedPnL = Math.Round(accountItem.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);
                    content.AppendFormat("{0},{1},{2}\r\n", formattedDateTime, accountItem.Id, realizedPnL);
                }

                File.WriteAllText(fileNameAndPath, content.ToString());
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling StoreStateDayOverMaxLossHighestPnLInSession:" + ex.Message + " " + ex.StackTrace);
            }
        }
        */
        private double GetPositionProfitWithStoLoss(Instrument instrument, MarketPosition marketPosition, int quantity, double averagePrice, double stopLossPrice)
        {
            double positionProfit = double.MinValue;

            if (stopLossPrice > 0)
            {
                double tickValue = RealInstrumentService.GetTickValue(instrument);
                double tickSize = instrument.MasterInstrument.TickSize;

                if (marketPosition == MarketPosition.Long)
                {
                    positionProfit = (stopLossPrice - averagePrice) * ((tickValue * quantity) / tickSize);
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    positionProfit = (averagePrice - stopLossPrice) * ((tickValue * quantity) / tickSize);
                }

                double commissionPerSide = GetInstrumentCommissionPerSide(instrument);
                bool includeCommissions = (commissionPerSide > 0);

                if (includeCommissions)
                {
                    positionProfit = positionProfit - (quantity * commissionPerSide * 2);
                }
            }

            return (Math.Round(positionProfit, 2, MidpointRounding.ToEven));
        }

        private double GetPositionProfit(RealPosition position)
        {
            double positionProfit = 0;
            double totalVolume = position.Quantity;
            double averagePrice = position.AveragePrice;
            double tickValue = RealInstrumentService.GetTickValue(position.Instrument);
            double tickSize = position.Instrument.MasterInstrument.TickSize;

            if (position.MarketPosition == MarketPosition.Long)
            {
                double bid = RealInstrumentService.GetBidPrice(position.Instrument);

                positionProfit = (bid - averagePrice) * ((tickValue * totalVolume) / tickSize);
            }
            else if (position.MarketPosition == MarketPosition.Short)
            {
                double ask = RealInstrumentService.GetAskPrice(position.Instrument);

                positionProfit = (averagePrice - ask) * ((tickValue * totalVolume) / tickSize);
            }

            double commissionPerSide = GetInstrumentCommissionPerSide(position.Instrument);
            bool includeCommissions = (commissionPerSide > 0);

            if (includeCommissions)
            {
                positionProfit = positionProfit - (totalVolume * commissionPerSide * 2);
            }

            return (Math.Round(positionProfit, 2, MidpointRounding.ToEven));
        }


        private bool IsMicroInstrument(Instrument instrument)
        {
            bool returnFlag = false;

            if (instrument.FullName.StartsWith(MYMPrefix) || instrument.FullName.StartsWith(MESPrefix) || instrument.FullName.StartsWith(M2KPrefix) || instrument.FullName.StartsWith(MNQPrefix))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool IsEminiInstrument(Instrument instrument)
        {
            bool returnFlag = false;

            if (instrument.FullName.StartsWith(YMPrefix) || instrument.FullName.StartsWith(ESPrefix) || instrument.FullName.StartsWith(RTYPrefix) || instrument.FullName.StartsWith(NQPrefix))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        // Performance-optimized helper to parse TradeSize and extract multiplier
        // Property format: "display|value" where value is "1xS" or "1xC"
        private int ParseTradeSizeMultiplier(string tradeSize)
        {
            if (string.IsNullOrEmpty(tradeSize))
                return 1;

            // Extract internal value from combined format
            string internalValue = TickHunterFollowerTradeSizeValueConverter.GetInternalValue(tradeSize);
            if (string.IsNullOrEmpty(internalValue))
                internalValue = tradeSize; // Fallback if already internal format

            // Fast parsing for internal format: find 'x' and parse number before it
            int xIndex = internalValue.IndexOf('x');
            if (xIndex > 0 && xIndex < internalValue.Length)
            {
                if (int.TryParse(internalValue.Substring(0, xIndex), out int multiplier))
                {
                    return multiplier;
                }
            }

            // Fallback: try legacy format parsing (for backward compatibility)
            int startIdx = -1;
            for (int i = 0; i < internalValue.Length; i++)
            {
                if (char.IsDigit(internalValue[i]))
                {
                    startIdx = i;
                    break;
                }
            }

            if (startIdx == -1)
                return 1;

            int endIdx = startIdx;
            while (endIdx < internalValue.Length && char.IsDigit(internalValue[endIdx]))
            {
                endIdx++;
            }

            if (endIdx > startIdx && int.TryParse(internalValue.Substring(startIdx, endIdx - startIdx), out int legacyMultiplier))
            {
                return legacyMultiplier;
            }

            return 1;
        }

        // Performance-optimized helper to check if TradeSize requests cross to E-mini
        // Property format: "display|value" where value ends with 'C' for cross, 'S' for same
        private bool IsCrossToEmini(string tradeSize)
        {
            if (string.IsNullOrEmpty(tradeSize))
                return false;

            // Extract internal value from combined format
            string internalValue = TickHunterFollowerTradeSizeValueConverter.GetInternalValue(tradeSize);
            if (string.IsNullOrEmpty(internalValue))
                internalValue = tradeSize; // Fallback if already internal format

            // Fast check for internal format: ends with 'C'
            if (internalValue.Length > 0 && internalValue[internalValue.Length - 1] == 'C')
                return true;

            // Fallback: check for legacy format
            return tradeSize.IndexOf("cross to E-mini", StringComparison.OrdinalIgnoreCase) >= 0;
        }

        // Performance-optimized helper to get TradeSize property by index
        private string GetFollowerTradeSize(int accountIndex)
        {
            switch (accountIndex)
            {
                case 1: return Follower1TradeSize ?? string.Empty;
                case 2: return Follower2TradeSize ?? string.Empty;
                case 3: return Follower3TradeSize ?? string.Empty;
                case 4: return Follower4TradeSize ?? string.Empty;
                case 5: return Follower5TradeSize ?? string.Empty;
                case 6: return Follower6TradeSize ?? string.Empty;
                case 7: return Follower7TradeSize ?? string.Empty;
                case 8: return Follower8TradeSize ?? string.Empty;
                case 9: return Follower9TradeSize ?? string.Empty;
                case 10: return Follower10TradeSize ?? string.Empty;
                case 11: return Follower11TradeSize ?? string.Empty;
                case 12: return Follower12TradeSize ?? string.Empty;
                case 13: return Follower13TradeSize ?? string.Empty;
                case 14: return Follower14TradeSize ?? string.Empty;
                case 15: return Follower15TradeSize ?? string.Empty;
                case 16: return Follower16TradeSize ?? string.Empty;
                case 17: return Follower17TradeSize ?? string.Empty;
                case 18: return Follower18TradeSize ?? string.Empty;
                case 19: return Follower19TradeSize ?? string.Empty;
                case 20: return Follower20TradeSize ?? string.Empty;
                case 21: return Follower21TradeSize ?? string.Empty;
                case 22: return Follower22TradeSize ?? string.Empty;
                case 23: return Follower23TradeSize ?? string.Empty;
                case 24: return Follower24TradeSize ?? string.Empty;
                default: return string.Empty;
            }
        }

        // Performance-optimized helper to map micro instrument to E-mini
        private Instrument MapToEminiInstrument(Instrument microInstrument, Account followerAccount)
        {
            if (microInstrument == null || followerAccount == null)
                return microInstrument;

            string instrumentName = microInstrument.MasterInstrument.Name;
            string fullName = microInstrument.FullName;
            string eminiFullName = null;

            // Fast prefix-based mapping
            if (instrumentName.StartsWith(MESPrefix)) // MES  ES
            {
                eminiFullName = ESPrefix + fullName.Substring(MESPrefix.Length);
            }
            else if (instrumentName.StartsWith(MNQPrefix)) // MNQ  NQ
            {
                eminiFullName = NQPrefix + fullName.Substring(MNQPrefix.Length);
            }
            else if (instrumentName.StartsWith(MYMPrefix)) // MYM  YM
            {
                eminiFullName = YMPrefix + fullName.Substring(MYMPrefix.Length);
            }
            else if (instrumentName.StartsWith(M2KPrefix)) // M2K  RTY
            {
                eminiFullName = RTYPrefix + fullName.Substring(M2KPrefix.Length);
            }

            if (eminiFullName != null)
            {
                try
                {
                    Instrument eminiInstrument = Instrument.GetInstrument(eminiFullName);
                    if (eminiInstrument != null)
                        return eminiInstrument;
                }
                catch
                {
                    // Fallback to same instrument if mapping fails
                }
            }

            return microInstrument; // Fallback to same instrument
        }

        // Performance-optimized helper to determine target instrument
        private Instrument GetTargetInstrument(Instrument leaderInstrument, bool crossToEmini, Account followerAccount)
        {
            // Priority 1: If leader is E-mini, always use same instrument
            if (IsEminiInstrument(leaderInstrument))
                return leaderInstrument;

            // Priority 2: If cross to E-mini requested, map to E-mini
            if (crossToEmini)
            {
                return MapToEminiInstrument(leaderInstrument, followerAccount);
            }

            // Priority 3: Default to same instrument
            return leaderInstrument;
        }

        private double GetInstrumentCommissionPerSide(Instrument instrument)
        {
            double commissionPerSide = OtherCommissionPerSide;

            if (instrument == mnqInstrument)
            {
                commissionPerSide = MNQCommissionPerSide;
            }
            else if (instrument == mesInstrument)
            {
                commissionPerSide = MESCommissionPerSide;
            }
            else if (instrument == mymInstrument)
            {
                commissionPerSide = MYMCommissionPerSide;
            }
            else if (instrument == m2kInstrument)
            {
                commissionPerSide = M2KCommissionPerSide;
            }
            else if (instrument == nqInstrument)
            {
                commissionPerSide = NQCommissionPerSide;
            }
            else if (instrument == esInstrument)
            {
                commissionPerSide = ESCommissionPerSide;
            }
            else if (instrument == ymInstrument)
            {
                commissionPerSide = YMCommissionPerSide;
            }
            else if (instrument == rtyInstrument)
            {
                commissionPerSide = RTYCommissionPerSide;
            }

            /*
            if (CommissionPerSide <= 0 && account != null && account.Commission != null && account.Commission.ByMasterInstrument.ContainsKey(instrument.MasterInstrument))
            {
                commissionPerSide = account.Commission.ByMasterInstrument[instrument.MasterInstrument].PerUnit;
            }
            else
            {
                //RealLogger.PrintOutput("ERROR: Missing commission per side for instrument '" + instrument.FullName + "'");
            }
            */


            return commissionPerSide;
        }

        private void ChartControl_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (e.ClickCount == 2)
            {
                if (KeyboardManager.IsCtrlKeyDown())
                {
                    DumpDebugInternalsToOutput();
                }
                //e.Handled = true; // if you want to prevent the chart double click action use true
            }
        }

        private bool TryGetNumpadInput(Key key, out Key numpadKey)
        {
            numpadKey = Key.None;

            // Only return true if NumLock is ON AND it's a NumPad key
            if (!Keyboard.IsKeyToggled(Key.NumLock))
            {
                return false;
            }

            // Digits (NumLock ON only)
            if (key >= Key.NumPad0 && key <= Key.NumPad9)
            {
                numpadKey = key;
                return true;
            }

            // Operators (NumLock ON only)
            switch (key)
            {
                case Key.Divide:
                case Key.Multiply:
                case Key.Subtract:
                case Key.Add:
                    numpadKey = key;
                    return true;
            }

            // Decimal (NumLock ON only)
            if (key == Key.Decimal)
            {
                numpadKey = key;
                return true;
            }

            // Enter (NumLock ON only)
            if (key == Key.Enter)
            {
                numpadKey = key;
                return true;
            }

            return false;
        }

        private Key ConvertHotKeyDisplayNameToKey(string HotKeyDisplayName)
        {
            if (string.IsNullOrEmpty(HotKeyDisplayName))
            {
                return Key.None;
            }

            switch (HotKeyDisplayName)
            {
                case "NumLock + 0":
                    return Key.NumPad0;
                case "NumLock + 1":
                    return Key.NumPad1;
                case "NumLock + 2":
                    return Key.NumPad2;
                case "NumLock + 3":
                    return Key.NumPad3;
                case "NumLock + 4":
                    return Key.NumPad4;
                case "NumLock + 5":
                    return Key.NumPad5;
                case "NumLock + 6":
                    return Key.NumPad6;
                case "NumLock + 7":
                    return Key.NumPad7;
                case "NumLock + 8":
                    return Key.NumPad8;
                case "NumLock + 9":
                    return Key.NumPad9;
                case "NumLock + /":
                    return Key.Divide;
                case "NumLock + *":
                    return Key.Multiply;
                case "NumLock + -":
                    return Key.Subtract;
                case "NumLock + +":
                    return Key.Add;
                case "NumLock + Enter":
                    return Key.Enter;
                case "NumLock + .":
                    return Key.Decimal;
                default:
                    return Key.None;
            }
        }

        private void OnPreviewKeyDown(object sender, KeyEventArgs e)
        {
            // Handle PreviewKeyDown events here
            // e.Handled = true; // Set to true to prevent further processing of the key event

            if (TryGetNumpadInput(e.Key, out Key numpadKey))
            {
                if (CheckAndHandleHotkeys(numpadKey))
                {
                    if (this.DebugLogLevel > 90) RealLogger.PrintOutput(string.Format("Numpad key pressed: {0}", numpadKey));
                    e.Handled = true;
                    return;
                }
                else
                {
                    RealLogger.PrintOutput(string.Format("Numpad key pressed: {0}", numpadKey));
                    e.Handled = true;
                    return;
                }
            }
        }

        private bool CheckAndHandleHotkeys(Key numpadKey)
        {
            if (buyMarketHotKeyValue != Key.None && buyMarketHotKeyValue == numpadKey)
            {
                if (IsTickHunterActivated()) BuyMarketButtonAction("BuyMarketHotkey");
                return true;
            }
            else if (sellMarketHotKeyValue != Key.None && sellMarketHotKeyValue == numpadKey)
            {
                if (IsTickHunterActivated()) SellMarketButtonAction("SellMarketHotkey");
                return true;
            }
            else if (buyPopHotKeyValue != Key.None && buyPopHotKeyValue == numpadKey)
            {
                if (BuyPopButton != null && IsTickHunterActivated()) BuyPopButtonAction("BuyPopHotkey", BuyPopButton);
                return true;
            }
            else if (sellPopHotKeyValue != Key.None && sellPopHotKeyValue == numpadKey)
            {
                if (SellPopButton != null && IsTickHunterActivated()) SellPopButtonAction("SellPopHotkey", SellPopButton);
                return true;
            }
            else if (closeHotKeyValue != Key.None && closeHotKeyValue == numpadKey)
            {
                if (IsTickHunterActivated()) FlattenEverythingButtonAction("CloseHotkey");
                return true;
            }
            else if (reverseHotKeyValue != Key.None && reverseHotKeyValue == numpadKey)
            {
                if (IsTickHunterActivated()) ReverseButtonAction("ReverseHotkey");
                return true;
            }
            else if (breakEvenPlusHotKeyValue != Key.None && breakEvenPlusHotKeyValue == numpadKey)
            {
                if (IsTickHunterActivated()) BEButtonAction("BreakEvenPlusHotkey");
                return true;
            }
            else if (stopLossPlusHotKeyValue != Key.None && stopLossPlusHotKeyValue == numpadKey)
            {
                if (IsTickHunterActivated()) SLButtonAction("StopLossPlusHotkey");
                return true;
            }
            else if (volumeHotKeyValue != Key.None && volumeHotKeyValue == numpadKey)
            {
                if (toggleEntryVolumeAutoButton != null && IsTickHunterActivated()) ToggleEntryVolumeAutoButtonAction("VolumeHotkey", toggleEntryVolumeAutoButton);
                return true;
            }
            else if (activateHotKeyValue != Key.None && activateHotKeyValue == numpadKey)
            {
                if (!IsTickHunterActivated())
                {
                    ActivateTickHunter("ActivateHotKey");
                }
                else
                {
                    DeactivateTickHunter("ActivateHotKey");
                }
                return true;
            }
            else
            {
                return false;
            }
        }


        private void DumpDebugInternalsToOutput()
        {
            string signalName = "DumpDebugInternalsToOutput";
            try
            {
                if (hasRanOnceFirstCycle)
                {
                    RealLogger.PrintOutput("***Activated DumpDebugInternalsToOutput...");

                    int positionCount = RealPositionService.PositionCount;

                    RealLogger.PrintOutput("Dump Positions: positionCount=" + positionCount);

                    for (int index = 0; index < positionCount; index++)
                    {
                        RealPosition position = null;
                        if (RealPositionService.TryGetByIndex(index, out position))
                        {
                            RealLogger.PrintOutput("- Instrument=" + position.Instrument.FullName + " Type=" + position.MarketPosition.ToString() + " Quan=" + position.Quantity);
                        }
                    }

                    int orderCount = RealOrderService.OrderCount;

                    RealLogger.PrintOutput("Dump Orders: orderCount=" + orderCount);

                    for (int index = 0; index < orderCount; index++)
                    {
                        RealOrder order = null;

                        if (RealOrderService.TryGetByIndex(index, out order))
                        {
                            RealLogger.PrintOutput("- Instrument=" + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " Quan=" + order.Quantity + " State=" + order.OrderState.ToString() + " OrderId=" + order.OrderId);
                        }
                    }

                    int orderUpdateMultiCycleCacheCount = RealOrderService.OrderUpdateMultiCycleCache.Count;

                    RealLogger.PrintOutput("Dump Order Update Multi-Cycle Orders: orderUpdateMultiCycleCacheCount=" + orderUpdateMultiCycleCacheCount);


                    int orderPartialFillCacheCount = RealOrderService.OrderPartialFillCache.Count;

                    RealLogger.PrintOutput("Dump OrderPartialFillCache: orderPartialFillCacheCount=" + orderPartialFillCacheCount);

                    Dictionary<string, int> keyValues = RealOrderService.OrderPartialFillCache;

                    foreach (KeyValuePair<string, int> entry in keyValues)
                    {
                        RealLogger.PrintOutput("- Key=" + entry.Key + " Value=" + entry.Value);
                    }
                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling DumpInternalsToOutput:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                throw;
            }
        }

        private void AttemptToClosePositionsInProfit()
        {
            string signalName = "AttemptToClosePositionsInProfit";

            if (currentCloseAutoStatus != TickHunterCloseAutoTypes.Disabled || UsePositionProfitLogging || IsBogeyTargetEnabled() || IsECATPEnabled())
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(ClosePositionsInProfitLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (RealOrderService.AreAllOrderUpdateCyclesComplete())
                        {
                            bool isCloseAutoSlopeAll = (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage4Break
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.DriftLine4Break
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieStackedFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ProfilePeppy
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ProfileSleepy
                                );

                            bool hasAttachedPosition = !IsAccountFlat(attachedInstrument);
                            bool hasBlendedPosition = (IsBlendedInstrumentEnabled() && !IsAccountFlat(blendedInstrument));
                            bool hasPosition = (hasAttachedPosition || hasBlendedPosition);
                            bool hasHODLEnabled = IsHODLEnabled();

                            if ((hasAttachedPosition || hasBlendedPosition) && !hasHODLEnabled)
                            {
                                int totalVolume = 0;
                                //int totalMicroVolume = 0;
                                //int totalEminiVolume = 0;
                                int totalOtherVolume = 0;
                                int totalMNQVolume = 0;
                                int totalNQVolume = 0;
                                int totalM2KVolume = 0;
                                int totalRTYVolume = 0;
                                int totalMESVolume = 0;
                                int totalESVolume = 0;
                                int totalMYMVolume = 0;
                                int totalYMVolume = 0;
                                double totalUnrealizedProfitLoss = 0;
                                double unrealizedProfitLoss = 0;

                                double attachedPositionAveragePrice = 0;
                                double totalUnrealizedProfitLossAttached = 0;
                                int totalQuantityAttached = 0;

                                MarketPosition positionMarketPosition = MarketPosition.Flat;
                                int positionQuantity = 0;

                                int positionCount = RealPositionService.PositionCount;

                                for (int index = 0; index < positionCount; index++)
                                {
                                    RealPosition position = null;
                                    if (RealPositionService.TryGetByIndex(index, out position))
                                    {
                                        hasPosition = true;

                                        positionQuantity = position.Quantity;
                                        totalVolume += positionQuantity;
                                        //if (IsMicroInstrument(position.Instrument)) totalMicroVolume += positionQuantity;
                                        //else if (IsEminiInstrument(position.Instrument)) totalEminiVolume += positionQuantity;

                                        if (position.Instrument == mymInstrument)
                                            totalMYMVolume += position.Quantity;
                                        else if (position.Instrument == mesInstrument)
                                            totalMESVolume += position.Quantity;
                                        else if (position.Instrument == m2kInstrument)
                                            totalM2KVolume += position.Quantity;
                                        else if (position.Instrument == mnqInstrument)
                                            totalMNQVolume += position.Quantity;
                                        else if (position.Instrument == ymInstrument)
                                            totalYMVolume += position.Quantity;
                                        else if (position.Instrument == esInstrument)
                                            totalESVolume += position.Quantity;
                                        else if (position.Instrument == rtyInstrument)
                                            totalRTYVolume += position.Quantity;
                                        else if (position.Instrument == nqInstrument)
                                            totalNQVolume += position.Quantity;
                                        else
                                            totalOtherVolume += position.Quantity;

                                        unrealizedProfitLoss = GetPositionProfit(position);
                                        totalUnrealizedProfitLoss += Math.Round(unrealizedProfitLoss, 2);

                                        if (position.Instrument == attachedInstrument)
                                        {
                                            hasAttachedPosition = true;
                                            positionMarketPosition = position.MarketPosition;
                                            totalUnrealizedProfitLossAttached += Math.Round(unrealizedProfitLoss, 2);
                                            totalQuantityAttached += positionQuantity;
                                            attachedPositionAveragePrice = position.AveragePrice;
                                        }
                                        else if (position.Instrument == blendedInstrument)
                                        {
                                            hasBlendedPosition = true;
                                        }
                                    }
                                }

                                if (hasPosition)
                                {
                                    double minAutoCloseProfit = (AutoCloseMinProfitDollarsPerVolume * totalQuantityAttached);

                                    double expectedECAProfitDollars = GetECATargetDollars(totalVolume, totalOtherVolume,
                                        totalMYMVolume, totalMESVolume, totalM2KVolume, totalMNQVolume,
                                        totalYMVolume, totalESVolume, totalRTYVolume, totalNQVolume);

                                    cacheECATakeProfitDollars = expectedECAProfitDollars;

                                    if (UsePositionProfitLogging && hasAttachedPosition)
                                    {
                                        if (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget)
                                        {
                                            RealLogger.PrintOutput("Total vs Target PnL: $" + totalUnrealizedProfitLoss.ToString("N2") + " vs $" + expectedECAProfitDollars.ToString("N2") + " with " + Convert.ToString(totalVolume) + " volume / avg price " + attachedPositionAveragePrice.ToString("N2") + " via " + signalName, PrintTo.OutputTab1, true, true);
                                        }
                                        else
                                        {
                                            RealLogger.PrintOutput("Total PnL: $" + totalUnrealizedProfitLoss.ToString("N2") + " with " + Convert.ToString(totalVolume) + " volume / avg price " + attachedPositionAveragePrice.ToString("N2") + " via " + signalName, PrintTo.OutputTab1, true, true);
                                        }
                                    }

                                    if (hasAttachedPosition || hasBlendedPosition)
                                    {
                                        if (IsECATPEnabled()
                                            && !IsHODLEnabled()
                                            && totalUnrealizedProfitLoss > 0
                                            && expectedECAProfitDollars > 0
                                            && totalUnrealizedProfitLoss >= expectedECAProfitDollars)
                                        {
                                            bool hasSyncedECATakeProfit = (IsAutoPositionTakeProfitEnabled() && IsECATPEnabled()
                                                && this.TakeProfitSyncECATargetPrice && lastECATakeProfitLinePrice > 0
                                                && this.TakeProfitRefreshManagementEnabled);
                                            //&& (attachedInstrumentPositionTakeProfitPrice > 0 || blendedInstrumentPositionTakeProfitPrice > 0));

                                            if (!hasSyncedECATakeProfit)
                                            {
                                                DeactivateAutoEntryFeatures(signalName);

                                                RealLogger.PrintOutput("ECA target reached: Total vs Target PnL: $" + totalUnrealizedProfitLoss.ToString("N2") + " vs $" + expectedECAProfitDollars.ToString("N2") + " with " + Convert.ToString(totalVolume) + " volume" + " via " + signalName, PrintTo.OutputTab1, true, false);

                                                bool isNextFlattenEverythingCycleReady = lastFlattenEverythingCycleChangeTime <= GetDateTimeNow();

                                                if (isNextFlattenEverythingCycleReady)
                                                {
                                                    lastFlattenEverythingCycleChangeTime = (GetDateTimeNow()).AddSeconds(FlattenEverythingThrottleSeconds);

                                                    FlattenEverything("EquityCloseAllTakeProfit", true, null);
                                                    hasPosition = false;
                                                    hasAttachedPosition = false;
                                                    hasBlendedPosition = false;
                                                }
                                            }
                                        }
                                        else if (IsBogeyTargetEnabled()
                                            && !IsHODLEnabled()
                                            && lastBogeyTargetBaseDollars > 0
                                            && totalUnrealizedProfitLoss > 0
                                            && totalUnrealizedProfitLoss >= lastBogeyTargetBaseDollars
                                            && lastBogeyTargetLinePrice > 0)
                                        {
                                            bool hasSyncedECATakeProfit = (IsAutoPositionTakeProfitEnabled() && IsECATPEnabled()
                                                && this.TakeProfitSyncECATargetPrice && lastECATakeProfitLinePrice > 0
                                                && this.TakeProfitRefreshManagementEnabled);
                                            //&& (attachedInstrumentPositionTakeProfitPrice > 0 || blendedInstrumentPositionTakeProfitPrice > 0));

                                            bool hasSyncedBogeyTakeProfit = (IsAutoPositionTakeProfitEnabled() && IsBogeyTargetEnabled()
                                                && this.TakeProfitSyncBogeyTargetPrice && lastBogeyTargetLinePrice > 0
                                                && this.TakeProfitRefreshManagementEnabled);
                                            //&& (attachedInstrumentPositionTakeProfitPrice > 0 || blendedInstrumentPositionTakeProfitPrice > 0));

                                            if (!hasSyncedBogeyTakeProfit && !hasSyncedECATakeProfit)
                                            {
                                                string formattedDailyMaxProfitDollars = "";
                                                if (lastBogeyTargetBaseDollars > 0)
                                                {
                                                    formattedDailyMaxProfitDollars = "$" + lastBogeyTargetBaseDollars.ToString("N0");
                                                }
                                                else
                                                {
                                                    formattedDailyMaxProfitDollars = "($" + lastBogeyTargetBaseDollars.ToString("N0") + ")";
                                                }

                                                DeactivateAutoEntryFeatures(signalName);

                                                RealLogger.PrintOutput("Bogey target reached: $" + BogeyTargetBaseDollars.ToString("N0") + " / " + formattedDailyMaxProfitDollars, PrintTo.OutputTab1, false);

                                                bool isNextFlattenEverythingCycleReady = lastFlattenEverythingCycleChangeTime <= GetDateTimeNow();

                                                if (isNextFlattenEverythingCycleReady)
                                                {
                                                    lastFlattenEverythingCycleChangeTime = (GetDateTimeNow()).AddSeconds(FlattenEverythingThrottleSeconds);

                                                    FlattenEverything("BogeyTarget", true, null);
                                                    hasPosition = false;
                                                    hasAttachedPosition = false;
                                                    hasBlendedPosition = false;
                                                }
                                            }
                                        }
                                        
                                        if (hasPosition && isCloseAutoSlopeAll)
                                        {

                                            if (AutoCloseRunOncePerBar.IsFirstRunThisBar)
                                            {
                                                AutoCloseRunOncePerBar.SetRunCompletedThisBar();

                                                bool closePositionFlag = false;

                                                bool hasMinAutoCloseProfit = totalUnrealizedProfitLossAttached >= minAutoCloseProfit;

                                                if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {

                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        if (autoCloseAndTrailMA1Value < autoCloseAndTrailMA1Value2 && autoCloseAndTrailMA1Value2 >= autoCloseAndTrailMA1Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        if (autoCloseAndTrailMA1Value >= autoCloseAndTrailMA1Value2 && autoCloseAndTrailMA1Value2 < autoCloseAndTrailMA1Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }

                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {

                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        if (autoCloseAndTrailMA2Value < autoCloseAndTrailMA2Value2 && autoCloseAndTrailMA2Value2 >= autoCloseAndTrailMA2Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        if (autoCloseAndTrailMA2Value >= autoCloseAndTrailMA2Value2 && autoCloseAndTrailMA2Value2 < autoCloseAndTrailMA2Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }

                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {

                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        if (autoCloseAndTrailMA3Value < autoCloseAndTrailMA3Value2 && autoCloseAndTrailMA3Value2 >= autoCloseAndTrailMA3Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        if (autoCloseAndTrailMA3Value >= autoCloseAndTrailMA3Value2 && autoCloseAndTrailMA3Value2 < autoCloseAndTrailMA3Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage4Break
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool sellCreeperRiverBreak = autoPilotSetupCreeperSellContinuation1
                                                            && (
                                                                (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9 && previous10ClosePrice >= autoCloseAndTrailMA4Value10)
                                                            );

                                                        if (sellCreeperRiverBreak)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool buyCreeperRiverBreak = autoPilotSetupCreeperBuyContinuation1
                                                            && (
                                                                (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9 && previous10ClosePrice < autoCloseAndTrailMA4Value10)
                                                            );

                                                        if (buyCreeperRiverBreak)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.DriftLine4Break
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool sellCreeperDriftBreak = autoPilotSetupCreeperSellContinuation1
                                                            && (
                                                                (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10)
                                                            );

                                                        if (sellCreeperDriftBreak)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool buyCreeperDriftBreak = autoPilotSetupCreeperBuyContinuation1
                                                            && (
                                                                (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10)
                                                            );

                                                        if (buyCreeperDriftBreak)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;

                                                        if (sellZombieSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "ZombieFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                if (PlaySoundOnSetupAlert)
                                                                {
                                                                    PlaySound(fullSoundFilename);
                                                                }

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;

                                                        if (buyZombieSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "ZombieFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieStackedFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool altSellZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                                                        bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;

                                                        bool sellZombieStackedSetup = (altSellZombieSetup1 && autoPilotSetupCreeperSellContinuation1)
                                                            || (altSellCreeperSetup1 && autoPilotSetupZombieSellContinuation1);

                                                        if (sellZombieStackedSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "ZombieStackedFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool altBuyZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                                                        bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;

                                                        bool buyZombieStackedSetup = (altBuyZombieSetup1 && autoPilotSetupCreeperBuyContinuation1)
                                                            || (altBuyCreeperSetup1 && autoPilotSetupZombieBuyContinuation1);

                                                        if (buyZombieStackedSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "ZombieStackedFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip)
                                                {
                                                    if (hasAttachedPosition)
                                                    {

                                                        bool buyZombieBoostedSetup = (autoPilotSetupZombieBuySetup2 && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup3 && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup4 && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup5 && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup6 && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup7 && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup8 && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup9 && autoPilotSetupZombieBuyContinuation8 && !previous8CandleBullish && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish);


                                                        bool sellZombieBoostedSetup = (autoPilotSetupZombieSellSetup2 && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup3 && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup4 && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup5 && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup6 && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup7 && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup8 && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup9 && autoPilotSetupZombieSellContinuation8 && previous8CandleBullish && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish);

                                                        if (positionMarketPosition == MarketPosition.Long)
                                                        {

                                                            if (sellZombieBoostedSetup)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "BUY";
                                                                    string algoSetupName = "ZombieBoostedFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                        else if (positionMarketPosition == MarketPosition.Short)
                                                        {
                                                            if (buyZombieBoostedSetup)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "SELL";
                                                                    string algoSetupName = "ZombieBoostedFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        double lowestKLinePrice = Math.Min(GetKineticLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool sellKLineDualSetup = lowestKLinePrice > previous1ClosePrice;

                                                        if (sellKLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "KLineDualFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                if (PlaySoundOnSetupAlert)
                                                                {
                                                                    PlaySound(fullSoundFilename);
                                                                }

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        double highestKLinePrice = Math.Max(GetKineticLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool buyKLineDualSetup = highestKLinePrice < previous1ClosePrice;

                                                        if (buyKLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "KLineDualFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        /*
                                                        bool sellCreeperSetup = (!previous1CandleBullish && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3)
                                                            || (!previous1CandleBullish && previous2CandleBullish && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4 && autoPilotSetupCreeperValue4 >= autoPilotSetupCreeperValue5)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && autoPilotSetupCreeperValue4 < autoPilotSetupCreeperValue5 && autoPilotSetupCreeperValue5 >= autoPilotSetupCreeperValue6)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && autoPilotSetupCreeperValue5 < autoPilotSetupCreeperValue6 && autoPilotSetupCreeperValue6 >= autoPilotSetupCreeperValue7)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && autoPilotSetupCreeperValue6 < autoPilotSetupCreeperValue7 && autoPilotSetupCreeperValue7 >= autoPilotSetupCreeperValue8)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && previous7CandleBullish && autoPilotSetupCreeperValue7 < autoPilotSetupCreeperValue8 && autoPilotSetupCreeperValue8 >= autoPilotSetupCreeperValue9)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && previous7CandleBullish && previous8CandleBullish && autoPilotSetupCreeperValue8 < autoPilotSetupCreeperValue9 && autoPilotSetupCreeperValue9 >= autoPilotSetupCreeperValue10);
                                                        */

                                                        bool sellCreeperSetup = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;

                                                        if (sellCreeperSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "CreeperFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        /*
                                                        bool buyCreeperSetup = (previous1CandleBullish && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3)
                                                            || (previous1CandleBullish && !previous2CandleBullish && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4 && autoPilotSetupCreeperValue4 < autoPilotSetupCreeperValue5)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && autoPilotSetupCreeperValue4 >= autoPilotSetupCreeperValue5 && autoPilotSetupCreeperValue5 < autoPilotSetupCreeperValue6)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && autoPilotSetupCreeperValue5 >= autoPilotSetupCreeperValue6 && autoPilotSetupCreeperValue6 < autoPilotSetupCreeperValue7)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && autoPilotSetupCreeperValue6 >= autoPilotSetupCreeperValue7 && autoPilotSetupCreeperValue7 < autoPilotSetupCreeperValue8)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && !previous7CandleBullish && autoPilotSetupCreeperValue7 >= autoPilotSetupCreeperValue8 && autoPilotSetupCreeperValue8 < autoPilotSetupCreeperValue9)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && !previous7CandleBullish && !previous8CandleBullish && autoPilotSetupCreeperValue8 >= autoPilotSetupCreeperValue9 && autoPilotSetupCreeperValue9 < autoPilotSetupCreeperValue10);
                                                        */

                                                        bool buyCreeperSetup = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;

                                                        if (buyCreeperSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "CreeperFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }

                                                    //RealLogger.PrintOutput("positionMarketPosition=" + positionMarketPosition.ToString() + " autoPilotSetupCreeperValue=" + autoPilotSetupCreeperValue + " autoPilotSetupCreeperValue2=" + autoPilotSetupCreeperValue2 + " autoPilotSetupCreeperValue3=" + autoPilotSetupCreeperValue3 + " closePositionFlag=" + closePositionFlag);
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        double lowestZipLinePrice = Math.Min(GetZipLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool sellZipLineDualSetup = lowestZipLinePrice > previous1ClosePrice;

                                                        if (sellZipLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "ZLineDualFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        double highestZipLinePrice = Math.Max(GetZipLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool buyZipLineDualSetup = highestZipLinePrice < previous1ClosePrice;

                                                        if (buyZipLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "ZLineDualFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }

                                                    //RealLogger.PrintOutput("positionMarketPosition=" + positionMarketPosition.ToString() + " autoPilotSetupCreeperValue=" + autoPilotSetupCreeperValue + " autoPilotSetupCreeperValue2=" + autoPilotSetupCreeperValue2 + " autoPilotSetupCreeperValue3=" + autoPilotSetupCreeperValue3 + " closePositionFlag=" + closePositionFlag);
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        double lowestZipLinePrice = Math.Min(GetZipLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool sellZipLineDualSetup = lowestZipLinePrice > previous1ClosePrice;

                                                        double lowestKLinePrice = Math.Min(GetKineticLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool sellKLineDualSetup = lowestKLinePrice > previous1ClosePrice;

                                                        if (sellZipLineDualSetup && sellKLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "KZFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        double highestZipLinePrice = Math.Max(GetZipLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool buyZipLineDualSetup = highestZipLinePrice < previous1ClosePrice;

                                                        double highestKLinePrice = Math.Max(GetKineticLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool buyKLineDualSetup = highestKLinePrice < previous1ClosePrice;

                                                        if (buyZipLineDualSetup && buyKLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "KZFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }

                                                    //RealLogger.PrintOutput("positionMarketPosition=" + positionMarketPosition.ToString() + " autoPilotSetupCreeperValue=" + autoPilotSetupCreeperValue + " autoPilotSetupCreeperValue2=" + autoPilotSetupCreeperValue2 + " autoPilotSetupCreeperValue3=" + autoPilotSetupCreeperValue3 + " closePositionFlag=" + closePositionFlag);
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ProfilePeppy)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;
                                                        bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;

                                                        if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                                                        {
                                                            sellZombieSetup = false;
                                                        }
                                                        else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                                                        {
                                                            altSellCreeperSetup1 = false;
                                                        }

                                                        if ((altSellCreeperSetup1 || sellZombieSetup)
                                                            && !attachedInstrumentPositionCreeperSurging
                                                            && !attachedInstrumentPositionCreeperGushing1)
                                                        {
                                                            double newProfileStopLossPrice = 0;
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1)
                                                                newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                                newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                                newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1
                                                                || !attachedInstrumentPositionFlowing2
                                                                || !attachedInstrumentPositionFlowing3
                                                                || !attachedInstrumentPositionFlowing4)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode && closeAutoMinProfitFlag && !hasMinAutoCloseProfit)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "BUY";
                                                                    string algoSetupName = "CreeperFlip";
                                                                    if (altSellCreeperSetup1 && sellZombieSetup)
                                                                        algoSetupName = "StackedFlip";
                                                                    else if (sellZombieSetup)
                                                                        algoSetupName = "ZombieFlip";


                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;
                                                        bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;

                                                        if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                                                        {
                                                            buyZombieSetup = false;
                                                        }
                                                        else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                                                        {
                                                            altBuyCreeperSetup1 = false;
                                                        }

                                                        if ((altBuyCreeperSetup1 || buyZombieSetup)
                                                            && !attachedInstrumentPositionCreeperSurging
                                                            && !attachedInstrumentPositionCreeperGushing1)
                                                        {
                                                            double newProfileStopLossPrice = 0;
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1)
                                                                newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                                newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                                newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1
                                                                || !attachedInstrumentPositionFlowing2
                                                                || !attachedInstrumentPositionFlowing3
                                                                || !attachedInstrumentPositionFlowing4)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode && closeAutoMinProfitFlag && !hasMinAutoCloseProfit)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "SELL";
                                                                    string algoSetupName = "CreeperFlip";
                                                                    if (altBuyCreeperSetup1 && buyZombieSetup)
                                                                        algoSetupName = "StackedFlip";
                                                                    else if (buyZombieSetup)
                                                                        algoSetupName = "ZombieFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ProfileSleepy)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;
                                                        bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;

                                                        if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                                                        {
                                                            sellZombieSetup = false;
                                                        }
                                                        else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                                                        {
                                                            altSellCreeperSetup1 = false;
                                                        }

                                                        if ((altSellCreeperSetup1 || sellZombieSetup)
                                                            && !attachedInstrumentPositionCreeperSurging
                                                            && !attachedInstrumentPositionCreeperGushing1)
                                                        {
                                                            double newProfileStopLossPrice = 0;
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1)
                                                                newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                                newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                                newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1
                                                                || !attachedInstrumentPositionFlowing2
                                                                || !attachedInstrumentPositionFlowing3
                                                                || !attachedInstrumentPositionFlowing4)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode && closeAutoMinProfitFlag && !hasMinAutoCloseProfit)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "BUY";
                                                                    string algoSetupName = "CreeperFlip";
                                                                    if (altSellCreeperSetup1 && sellZombieSetup)
                                                                        algoSetupName = "StackedFlip";
                                                                    else if (sellZombieSetup)
                                                                        algoSetupName = "ZombieFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    //closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;
                                                        bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;

                                                        if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                                                        {
                                                            buyZombieSetup = false;
                                                        }
                                                        else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                                                        {
                                                            altBuyCreeperSetup1 = false;
                                                        }

                                                        if ((altBuyCreeperSetup1 || buyZombieSetup)
                                                            && !attachedInstrumentPositionCreeperSurging
                                                            && !attachedInstrumentPositionCreeperGushing1)
                                                        {
                                                            double newProfileStopLossPrice = 0;
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1)
                                                                newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                                newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                                newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1
                                                                || !attachedInstrumentPositionFlowing2
                                                                || !attachedInstrumentPositionFlowing3
                                                                || !attachedInstrumentPositionFlowing4)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode && closeAutoMinProfitFlag && !hasMinAutoCloseProfit)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "SELL";
                                                                    string algoSetupName = "CreeperFlip";
                                                                    if (altBuyCreeperSetup1 && buyZombieSetup)
                                                                        algoSetupName = "StackedFlip";
                                                                    else if (buyZombieSetup)
                                                                        algoSetupName = "ZombieFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    //closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                if (closePositionFlag)
                                                {
                                                    FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);

                                                    hasPosition = false;
                                                    hasAttachedPosition = false;
                                                    hasBlendedPosition = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            if (!hasAttachedPosition && !hasHODLEnabled && isCloseAutoSlopeAll
                                && (
                                (currentTradeSignalStatus != TickHunterTradeSignalTypes.Disabled)
                                || (currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.AlertSetup
                                && currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.Disabled))
                                )
                            {

                                if (AutoCloseRunOncePerBar.IsFirstRunThisBar)
                                {
                                    AutoCloseRunOncePerBar.SetRunCompletedThisBar();

                                    int buyPendingOrderCount = 0;
                                    int sellPendingOrderCount = 0;

                                    bool hasPendingOrder = GetPopDropOrderCount(out buyPendingOrderCount, out sellPendingOrderCount);
                                    bool hasBuyPendingOrder = (buyPendingOrderCount > 0);

                                    bool closePendingOrderFlag = false;

                                    if (hasPendingOrder)
                                    {
                                        if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope)
                                        {
                                            if (hasBuyPendingOrder)
                                            {
                                                if (autoCloseAndTrailMA1Value < autoCloseAndTrailMA1Value2 && autoCloseAndTrailMA1Value2 >= autoCloseAndTrailMA1Value3)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                if (autoCloseAndTrailMA1Value >= autoCloseAndTrailMA1Value2 && autoCloseAndTrailMA1Value2 < autoCloseAndTrailMA1Value3)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }
                                        else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope)
                                        {

                                            if (hasBuyPendingOrder)
                                            {
                                                if (autoCloseAndTrailMA2Value < autoCloseAndTrailMA2Value2 && autoCloseAndTrailMA2Value2 >= autoCloseAndTrailMA2Value3)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                if (autoCloseAndTrailMA2Value >= autoCloseAndTrailMA2Value2 && autoCloseAndTrailMA2Value2 < autoCloseAndTrailMA2Value3)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }
                                        else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope)
                                        {

                                            if (hasBuyPendingOrder)
                                            {
                                                if (autoCloseAndTrailMA3Value < autoCloseAndTrailMA3Value2 && autoCloseAndTrailMA3Value2 >= autoCloseAndTrailMA3Value3)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                if (autoCloseAndTrailMA3Value >= autoCloseAndTrailMA3Value2 && autoCloseAndTrailMA3Value2 < autoCloseAndTrailMA3Value3)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }
                                        else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip)
                                        {

                                            if (hasBuyPendingOrder)
                                            {
                                                if (autoPilotSetupZombieValue == ZombieSetupSellCode)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                if (autoPilotSetupZombieValue == ZombieSetupBuyCode)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }
                                        else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip)
                                        {
                                            bool buyZombieBoostedSetup = (autoPilotSetupZombieBuySetup2 && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                || (autoPilotSetupZombieBuySetup3 && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                || (autoPilotSetupZombieBuySetup4 && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                || (autoPilotSetupZombieBuySetup5 && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                || (autoPilotSetupZombieBuySetup6 && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                || (autoPilotSetupZombieBuySetup7 && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                || (autoPilotSetupZombieBuySetup8 && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                || (autoPilotSetupZombieBuySetup9 && autoPilotSetupZombieBuyContinuation8 && !previous8CandleBullish && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish);


                                            bool sellZombieBoostedSetup = (autoPilotSetupZombieSellSetup2 && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                || (autoPilotSetupZombieSellSetup3 && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                || (autoPilotSetupZombieSellSetup4 && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                || (autoPilotSetupZombieSellSetup5 && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                || (autoPilotSetupZombieSellSetup6 && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                || (autoPilotSetupZombieSellSetup7 && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                || (autoPilotSetupZombieSellSetup8 && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                || (autoPilotSetupZombieSellSetup9 && autoPilotSetupZombieSellContinuation8 && previous8CandleBullish && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish);

                                            if (hasBuyPendingOrder)
                                            {
                                                if (sellZombieBoostedSetup)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                if (buyZombieBoostedSetup)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }
                                        else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip)
                                        {
                                            if (hasBuyPendingOrder)
                                            {
                                                double lowestKLinePrice = Math.Min(GetKineticLine1Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks));
                                                bool sellKLineDualSetup = lowestKLinePrice > previous1ClosePrice;

                                                if (sellKLineDualSetup)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                double highestKLinePrice = Math.Max(GetKineticLine1Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks));
                                                bool buyKLineDualSetup = highestKLinePrice < previous1ClosePrice;

                                                if (buyKLineDualSetup)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }
                                        else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip)
                                        {
                                            bool risingAvgLine = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;

                                            if (hasBuyPendingOrder)
                                            {
                                                if (!risingAvgLine)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                if (risingAvgLine)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }
                                        else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip)
                                        {
                                            if (hasBuyPendingOrder)
                                            {
                                                double lowestZipLinePrice = Math.Min(GetZipLine1Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks));
                                                bool sellZipLineDualSetup = lowestZipLinePrice > previous1ClosePrice;

                                                if (sellZipLineDualSetup)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                double highestZipLinePrice = Math.Max(GetZipLine1Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks));
                                                bool buyZipLineDualSetup = highestZipLinePrice < previous1ClosePrice;

                                                if (buyZipLineDualSetup)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }
                                        else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip)
                                        {
                                            if (hasBuyPendingOrder)
                                            {
                                                double lowestZipLinePrice = Math.Min(GetZipLine1Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks));
                                                bool sellZipLineDualSetup = lowestZipLinePrice > previous1ClosePrice;

                                                double lowestKLinePrice = Math.Min(GetKineticLine1Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks));
                                                bool sellKLineDualSetup = lowestKLinePrice > previous1ClosePrice;

                                                if (sellZipLineDualSetup && sellKLineDualSetup)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                            else
                                            {
                                                double highestZipLinePrice = Math.Max(GetZipLine1Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks));
                                                bool buyZipLineDualSetup = highestZipLinePrice < previous1ClosePrice;

                                                double highestKLinePrice = Math.Max(GetKineticLine1Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks));
                                                bool buyKLineDualSetup = highestKLinePrice < previous1ClosePrice;

                                                if (buyZipLineDualSetup && buyKLineDualSetup)
                                                {
                                                    closePendingOrderFlag = true;
                                                }
                                            }
                                        }

                                        if (closePendingOrderFlag)
                                        {
                                            CancelPopDropOrders(currentCloseAutoStatus.ToString());
                                        }
                                    }
                                }

                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling AttemptToClosePositionsInProfit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                    {
                        Monitor.Exit(ClosePositionsInProfitLock);
                    }
                }
            }

        }

        private void ExitCloseAlertWindows()
        {
            if (ChartControl != null && closeAutoAlertFlag)
            {
                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                {
                    CloseMessageBox(CloseAlertMessageTitle);
                    CloseAltMessageBox(CloseAlertAltMessageTitle);
                }));
            }
        }

        private void ExitTradeAlertWindows()
        {
            if (ChartControl != null && currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup)
            {
                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                {
                    CloseMessageBox(BuyZombieAlertMessageTitle);
                    CloseAltMessageBox(BuyZombieAlertAltMessageTitle);
                    CloseMessageBox(SellZombieAlertMessageTitle);
                    CloseAltMessageBox(SellZombieAlertAltMessageTitle);
                    CloseMessageBox(BuyCreeperAlertMessageTitle);
                    CloseAltMessageBox(BuyCreeperAlertAltMessageTitle);
                    CloseMessageBox(SellCreeperAlertMessageTitle);
                    CloseAltMessageBox(SellCreeperAlertAltMessageTitle);
                    CloseMessageBox(BuySliderAlertMessageTitle);
                    CloseMessageBox(SellSliderAlertMessageTitle);
                }));
            }
        }

        private void AttemptToClosePositionsInLoss()
        {
            string signalName = "AttemptToClosePositionsInLoss";

            if (IsMaxDDStopLossEnabled() || IsDayOverAccountBalanceFloorEnabled() || IsDayOverMaxLossEnabled())
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(ClosePositionsInLossLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (!IsAccountFlat(attachedInstrument)
                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                        {
                            int totalVolume = 0;
                            int totalMicroVolume = 0;
                            int totalEminiVolume = 0;
                            double totalUnrealizedProfitLoss = 0;
                            double unrealizedProfitLoss = 0;
                            int positionQuantity = 0;
                            double oldStopLossPrice = 0;
                            OrderType stopLossOrderType = OrderType.Unknown;
                            int oldStopLossOrderQuantity = 0;
                            int stopLossOrderCount = 0;
                            bool hasStopLoss = false;

                            int positionCount = RealPositionService.PositionCount;

                            for (int index = 0; index < positionCount; index++)
                            {
                                RealPosition position = null;
                                if (RealPositionService.TryGetByIndex(index, out position))
                                {
                                    oldStopLossPrice = 0;
                                    stopLossOrderType = OrderType.Unknown;
                                    oldStopLossOrderQuantity = 0;
                                    stopLossOrderCount = 0;
                                    hasStopLoss = false;

                                    positionQuantity = position.Quantity;
                                    totalVolume += positionQuantity;
                                    if (IsMicroInstrument(position.Instrument)) totalMicroVolume += positionQuantity;
                                    else if (IsEminiInstrument(position.Instrument)) totalEminiVolume += positionQuantity;
                                    unrealizedProfitLoss = GetPositionProfit(position);
                                    totalUnrealizedProfitLoss += Math.Round(unrealizedProfitLoss, 2);

                                    oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out stopLossOrderType, out oldStopLossOrderQuantity, out stopLossOrderCount);
                                    hasStopLoss = (oldStopLossPrice > 0);
                                }
                            }
                            bool test = (lastDayOverMaxLossDollars > 0 && unrealizedProfitLoss < 0 && (unrealizedProfitLoss * -1) >= lastDayOverMaxLossDollars);

                            if (totalVolume > 0 && totalUnrealizedProfitLoss < 0)
                            {
                                //if (UseDebugLogging) RealLogger.PrintOutput("Max DD: $" + totalUnrealizedProfitLoss.ToString("N2") + " vs DD $" + maxDDInDollars.ToString("N2") + " with " + Convert.ToString(totalVolume) + " volume", PrintTo.OutputTab1, true);
                                double netLiquidationBalance = Math.Round(account.Get(AccountItem.NetLiquidation, Currency.UsDollar), 2);

                                if (IsMaxDDStopLossEnabled() && totalUnrealizedProfitLoss <= maxDDInDollars)
                                {
                                    DeactivateAutoEntryFeatures(signalName);

                                    RealLogger.PrintOutput("Max DD reached: $" + totalUnrealizedProfitLoss.ToString("N2") + " ($" + maxDDInDollars.ToString("N2") + ") with " + Convert.ToString(totalVolume) + " volume", PrintTo.OutputTab1, false);

                                    bool isNextFlattenEverythingCycleReady = lastFlattenEverythingCycleChangeTime <= GetDateTimeNow();

                                    if (isNextFlattenEverythingCycleReady)
                                    {
                                        lastFlattenEverythingCycleChangeTime = (GetDateTimeNow()).AddSeconds(FlattenEverythingThrottleSeconds);

                                        FlattenEverything("MaxDDStopLoss", true, null);
                                    }
                                }
                                else if (IsDayOverAccountBalanceFloorEnabled() && netLiquidationBalance <= DayOverAccountBalanceFloorDollars)
                                {
                                    DeactivateAutoEntryFeatures(signalName);

                                    RealLogger.PrintOutput("Day over account balance floor reached: $" + DayOverAccountBalanceFloorDollars.ToString("N2") + "/ $" + netLiquidationBalance.ToString("N2"), PrintTo.OutputTab1, false);

                                    bool isNextFlattenEverythingCycleReady = lastFlattenEverythingCycleChangeTime <= GetDateTimeNow();

                                    if (isNextFlattenEverythingCycleReady)
                                    {
                                        lastFlattenEverythingCycleChangeTime = (GetDateTimeNow()).AddSeconds(FlattenEverythingThrottleSeconds);

                                        FlattenEverything("DayOverAccountBalanceFloorDollars", true, null);
                                    }
                                }
                                else if (IsDayOverMaxLossEnabled() && (activeDayOverMaxLossAutoClose || (!IsAutoPositionStopLossEnabled() && (lastDayOverMaxLossDollars > 0 && unrealizedProfitLoss < 0 && (unrealizedProfitLoss * -1) >= lastDayOverMaxLossDollars)))) // ||
                                {
                                    string formattedDailyMaxLossDollars = "";
                                    if (lastDayOverMaxLossDollars > 0)
                                    {
                                        formattedDailyMaxLossDollars = "$" + lastDayOverMaxLossDollars.ToString("N0");
                                    }
                                    else
                                    {
                                        formattedDailyMaxLossDollars = "($" + lastDayOverMaxLossDollars.ToString("N0") + ")";
                                    }

                                    DeactivateAutoEntryFeatures(signalName);

                                    RealLogger.PrintOutput("Day over max loss reached: $" + dayOverMaxLossDollars.ToString("N0") + " / " + formattedDailyMaxLossDollars, PrintTo.OutputTab1, false);

                                    bool isNextFlattenEverythingCycleReady = lastFlattenEverythingCycleChangeTime <= GetDateTimeNow();

                                    if (isNextFlattenEverythingCycleReady)
                                    {
                                        lastFlattenEverythingCycleChangeTime = (GetDateTimeNow()).AddSeconds(FlattenEverythingThrottleSeconds);

                                        FlattenEverything("DayOverMaxLoss", true, null);
                                        activeDayOverMaxLossAutoClose = false;
                                    }
                                }
                                else if (IsExcessIntradayMarginMinDollarsEnabled() && lastAccountIntradayExcessMargin != 0 && lastAccountIntradayExcessMargin < ExcessIntradayMarginMinDollars)
                                {
                                    RealLogger.PrintOutput("Excess intraday margin min dollars reached: $" + lastAccountIntradayExcessMargin.ToString("N0")
                                        + " ($" + ExcessIntradayMarginMinDollars.ToString("N0") + ")");

                                    bool isNextFlattenEverythingCycleReady = lastFlattenEverythingCycleChangeTime <= GetDateTimeNow();

                                    if (isNextFlattenEverythingCycleReady)
                                    {
                                        lastFlattenEverythingCycleChangeTime = (GetDateTimeNow()).AddSeconds(FlattenEverythingThrottleSeconds);

                                        FlattenEverything("ExcessIntradayMarginMinDollars", true, null);
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling AttemptToClosePositionsInLoss:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                    {
                        Monitor.Exit(ClosePositionsInLossLock);
                    }
                }
            }

        }

        private void CreateSellStop(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.SellShort)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            OrderType orderType = OrderType.StopMarket;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildEntryOrderName();


                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Day, quantity, 0, price, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy()) NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);

                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening stop order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening stop order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);

                    }
                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreateSellStop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void CreateBuyStop(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.SellShort)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            OrderType orderType = OrderType.StopMarket;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildEntryOrderName();

                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Day, quantity, 0, price, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy()) NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);


                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening stop order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening stop order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);
                    }


                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreateBuyStop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void CreateSellLimit(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.Buy && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            OrderType orderType = OrderType.Limit;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildEntryOrderName();

                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Day, quantity, price, 0, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy()) NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);

                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening limit order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening limit order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);
                    }

                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreateSellLimit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void CreateBuyLimit(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.Buy && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            OrderType orderType = OrderType.Limit;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildEntryOrderName();

                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Day, quantity, price, 0, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy()) NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);

                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening limit order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening limit order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);
                    }

                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreateBuyLimit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void UpdateStopOrder(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.SellShort)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported in UpdateStopOrder.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);


            if (orderAction == OrderAction.BuyToCover && price <= lastPrice)
            {
                RealLogger.PrintOutput("ERROR: Stop order price must be greater than last price.");
                return;
            }
            else if (orderAction == OrderAction.SellShort && price >= lastPrice)
            {
                RealLogger.PrintOutput("ERROR: Stop order price must be less than last price.");
                return;
            }

            bool orderChanged = false;
            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidBuyStopOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, instrument, OrderAction.SellShort))
                    {
                        orderChanged = false;
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {

                            if (foundNTOrder.StopPrice != price)
                            {
                                foundNTOrder.StopPriceChanged = price;
                                orderChanged = true;
                            }

                            if (orderChanged)
                            {
                                try
                                {
                                    account.Change(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in UpdateStopOrder:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                        }
                    }
                }
            }

        }

        private void UpdateLimitOrder(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, double price)
        {
            if (orderAction != OrderAction.Buy && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported in UpdateLimitOrder.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);


            if (orderAction == OrderAction.Buy && price >= lastPrice)
            {
                RealLogger.PrintOutput("ERROR: Limit order price must be less than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && price <= lastPrice)
            {
                RealLogger.PrintOutput("ERROR: Limit order price must be greater than last price.");
                return;
            }

            bool orderChanged = false;
            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidBuyLimitOrder(order, instrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, instrument, OrderAction.Sell))
                    {
                        orderChanged = false;
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            if (foundNTOrder.LimitPrice != price)
                            {
                                foundNTOrder.LimitPriceChanged = price;
                                orderChanged = true;
                            }

                            if (orderChanged)
                            {
                                try
                                {
                                    account.Change(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in UpdateLimitOrder:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                        }
                    }
                }
            }

        }

        private void CreatePositionStopLoss(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);
            bool isValid = RealOrderService.IsValidStopLossPrice(instrument, orderAction, price, lastPrice);
            if (orderAction == OrderAction.BuyToCover && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Stop Loss order price must be greater than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Stop Loss order price must be less than last price.");
                return;
            }

            OrderType orderType = OrderType.StopMarket;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildStopOrderName();

                try
                {
                    Order stopOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Gtc, quantity, 0, price, "", orderName, Core.Globals.MaxDate, null);

                    account.Submit(new[] { stopOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreatePositionStopLoss:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void UpdatePositionStopLoss(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);
            bool isValid = RealOrderService.IsValidStopLossPrice(instrument, orderAction, price, lastPrice);
            if (orderAction == OrderAction.BuyToCover && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Stop Loss order price must be greater than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Stop Loss order price must be less than last price.");
                return;
            }


            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidStopLossOrder(order, instrument, orderAction))
                    {
                        bool orderChanged = false;
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            if (foundNTOrder.Quantity != quantity && quantity != 0)
                            {
                                foundNTOrder.QuantityChanged = quantity;
                                orderChanged = true;
                            }
                            if (foundNTOrder.StopPrice != price)
                            {
                                foundNTOrder.StopPriceChanged = price;
                                orderChanged = true;
                            }

                            if (orderChanged)
                            {
                                try
                                {
                                    account.Change(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in UpdatePositionStopLoss:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }

                            }
                            if (quantity != 0) break; //only change one if also setting quantity
                        }
                    }
                }
            }

        }

        private void CreatePositionTakeProfit(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);
            bool isValid = RealOrderService.IsValidTakeProfitPrice(instrument, orderAction, price, lastPrice);
            if (orderAction == OrderAction.BuyToCover && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Take Profit order price must be less than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Take Profit order price must be greater than last price.");
                return;
            }

            OrderType orderType = OrderType.Limit;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildTargetOrderName();

                try
                {
                    Order targetOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Gtc, quantity, price, 0, "", orderName, Core.Globals.MaxDate, null);

                    account.Submit(new[] { targetOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreatePositionTakeProfit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }

            }
        }

        private void ScheduleDelayedTakeProfit(string signalName, Instrument instrument, OrderAction orderAction, int quantity, double price)
        {
            lock (DelayedTakeProfitLock)
            {
                try
                {
                    // If there's already a scheduled take profit for the same instrument and order action, update it with new total quantity
                    // BUT only if it hasn't expired yet - if it has expired, let CheckAndExecuteDelayedTakeProfit execute it first
                    if (hasScheduledTakeProfit 
                        && scheduledTakeProfitInstrument == instrument 
                        && scheduledTakeProfitOrderAction.HasValue 
                        && scheduledTakeProfitOrderAction.Value == orderAction
                        && scheduledTakeProfitCreationTime > GetDateTimeNow()) // Only update if not expired
                    {
                        // Delay reset is driven by quantity changes, not price changes
                        bool quantityChanged = scheduledTakeProfitQuantity != quantity;
                        bool priceChanged = Math.Abs(scheduledTakeProfitPrice - price) > 0.01; // Use small epsilon for price comparison
                        
                        if (quantityChanged)
                        {
                            // Reset the delay timer when quantity changes - this allows batching multiple position changes within the delay window
                        scheduledTakeProfitQuantity = quantity; // This will be the current total position quantity
                        scheduledTakeProfitPrice = price;
                            scheduledTakeProfitCreationTime = (GetDateTimeNow()).AddSeconds(TakeProfitAddOnDelaySeconds);
                            
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated scheduled TP: quantity=" + quantity.ToString() + " price=" + price.ToString("N2") + " delay=" + TakeProfitAddOnDelaySeconds.ToString() + "s (batching) via " + signalName);
                        }
                        else if (priceChanged)
                        {
                            // Update price only without resetting delay timer
                            scheduledTakeProfitPrice = price;
                            
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated scheduled TP price only: price=" + price.ToString("N2") + " (expires in " + (scheduledTakeProfitCreationTime - GetDateTimeNow()).TotalSeconds.ToString("F1") + "s) via " + signalName);
                        }
                        else
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Skipping TP schedule update: quantity and price unchanged (expires in " + (scheduledTakeProfitCreationTime - GetDateTimeNow()).TotalSeconds.ToString("F1") + "s) via " + signalName);
                        }
                    }
                    else if (hasScheduledTakeProfit 
                        && scheduledTakeProfitInstrument == instrument 
                        && scheduledTakeProfitOrderAction.HasValue 
                        && scheduledTakeProfitOrderAction.Value == orderAction
                        && scheduledTakeProfitCreationTime <= GetDateTimeNow()) // Expired - let CheckAndExecuteDelayedTakeProfit execute it
                    {
                        // Check if quantity changed - if so, we need to reschedule for the new position change
                        bool quantityChanged = scheduledTakeProfitQuantity != quantity;
                        
                        if (quantityChanged)
                        {
                            // Quantity changed - reschedule with new values to batch the new position change
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Rescheduling expired TP due to quantity change: quantity=" + quantity.ToString() + " price=" + price.ToString("N2") + " via " + signalName);
                            scheduledTakeProfitQuantity = quantity;
                            scheduledTakeProfitPrice = price;
                            scheduledTakeProfitCreationTime = (GetDateTimeNow()).AddSeconds(TakeProfitAddOnDelaySeconds);
                            
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Rescheduled delayed TP: quantity=" + quantity.ToString() + " price=" + price.ToString("N2") + " delay=" + TakeProfitAddOnDelaySeconds.ToString() + "s via " + signalName);
                        }
                        else
                        {
                            // Quantity unchanged - let CheckAndExecuteDelayedTakeProfit execute the expired scheduled TP
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Skipping TP schedule: expired scheduled TP will be executed by CheckAndExecuteDelayedTakeProfit via " + signalName);
                        }
                    }
                    else
                    {
                        // Cancel any existing scheduled take profit for different instrument/action
                        if (hasScheduledTakeProfit)
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Canceling previous scheduled TP for different instrument/action via " + signalName);
                        }
                        
                        // Schedule new delayed take profit creation
                        scheduledTakeProfitInstrument = instrument;
                        scheduledTakeProfitOrderAction = orderAction;
                        scheduledTakeProfitQuantity = quantity;
                        scheduledTakeProfitPrice = price;
                        scheduledTakeProfitCreationTime = (GetDateTimeNow()).AddSeconds(TakeProfitAddOnDelaySeconds);
                        hasScheduledTakeProfit = true;
                        
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Scheduled delayed TP: quantity=" + quantity.ToString() + " price=" + price.ToString("N2") + " delay=" + TakeProfitAddOnDelaySeconds.ToString() + "s via " + signalName);
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in ScheduleDelayedTakeProfit: " + ex.Message + " " + ex.StackTrace + " via " + signalName);
                }
            }
        }

        private bool HasActiveTakeProfitOrder(Instrument instrument, OrderAction orderAction)
        {
            int orderCount = RealOrderService.OrderCount;
            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;
                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidTakeProfitOrder(order, instrument, orderAction))
                    {
                        Order foundNTOrder = GetNinjaTraderOrder(order);
                        if (foundNTOrder != null && !Order.IsTerminalState(foundNTOrder.OrderState))
                        {
                            return true; // Found active (non-terminal) take profit order
                        }
                    }
                }
            }
            return false;
        }

        private bool HasActiveStopLossOrder(Instrument instrument, OrderAction orderAction)
        {
            int orderCount = RealOrderService.OrderCount;
            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;
                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidStopLossOrder(order, instrument, orderAction))
                    {
                        Order foundNTOrder = GetNinjaTraderOrder(order);
                        if (foundNTOrder != null && !Order.IsTerminalState(foundNTOrder.OrderState))
                        {
                            return true; // Found active (non-terminal) stop loss order
                        }
                    }
                }
            }
            return false;
        }

        private void CheckAndExecuteDelayedTakeProfit(string signalName)
        {
            lock (DelayedTakeProfitLock)
            {
                try
                {
                    if (hasScheduledTakeProfit && scheduledTakeProfitCreationTime <= GetDateTimeNow())
                    {
                        if (scheduledTakeProfitInstrument != null 
                            && scheduledTakeProfitOrderAction.HasValue 
                            && scheduledTakeProfitQuantity > 0 
                            && scheduledTakeProfitPrice > 0
                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                        {
                            // Get current position quantity to ensure we use the latest total
                            int currentPositionQuantity = 0;
                            RealPosition position = null;
                            bool positionExists = false;
                            
                            // Iterate through positions to find the one matching the instrument and account
                            int positionCount = RealPositionService.PositionCount;
                            for (int index = 0; index < positionCount; index++)
                            {
                                RealPosition tempPosition = null;
                                if (RealPositionService.TryGetByIndex(index, out tempPosition))
                                {
                                    if (tempPosition != null && tempPosition.Instrument == scheduledTakeProfitInstrument && account != null && tempPosition.Account == account)
                                    {
                                        position = tempPosition;
                                        positionExists = true;
                                        currentPositionQuantity = position.Quantity;
                                        break;
                                    }
                                }
                            }
                            
                            // Safety check: Don't create/update TP order if position is flat
                            if (positionExists && position != null && !position.IsFlat() && currentPositionQuantity > 0 && scheduledTakeProfitOrderAction.HasValue)
                            {
                                // Use the larger of scheduled quantity or current position quantity (in case position changed)
                                int finalQuantity = Math.Max(scheduledTakeProfitQuantity, currentPositionQuantity);
                                
                                if (finalQuantity > 0)
                                {
                                    double lastPrice = RealInstrumentService.GetLastPrice(scheduledTakeProfitInstrument);
                                    bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(scheduledTakeProfitInstrument, scheduledTakeProfitOrderAction.Value, scheduledTakeProfitPrice, lastPrice);
                                    
                                    if (isPriceValid)
                                    {
                                        bool hasActiveTP = HasActiveTakeProfitOrder(scheduledTakeProfitInstrument, scheduledTakeProfitOrderAction.Value);
                                        
                                        if (!hasActiveTP)
                                        {
                                            // No active TP order - create new one
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Executing delayed TP: quantity=" + finalQuantity.ToString() + " price=" + scheduledTakeProfitPrice.ToString("N2") + " via " + signalName);
                                        CreatePositionTakeProfit(signalName, scheduledTakeProfitInstrument, scheduledTakeProfitOrderAction.Value, OrderEntry.Manual, finalQuantity, scheduledTakeProfitPrice);
                                        }
                                        else
                                        {
                                            // Active TP order exists - update it (for quantity mismatch)
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Executing delayed TP update: quantity=" + finalQuantity.ToString() + " price=" + scheduledTakeProfitPrice.ToString("N2") + " via " + signalName);
                                            UpdatePositionTakeProfit(signalName, scheduledTakeProfitInstrument, scheduledTakeProfitOrderAction.Value, OrderEntry.Manual, finalQuantity, scheduledTakeProfitPrice);
                                        }
                                    }
                                    else
                                    {
                                        RealLogger.PrintOutput("WARNING: Delayed TP price invalid, skipping creation. Price=" + scheduledTakeProfitPrice.ToString("N2") + " LastPrice=" + lastPrice.ToString("N2") + " via " + signalName);
                                    }
                                }
                            }
                            else
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput("Skipping delayed TP: position flat. PositionExists=" + positionExists.ToString() + " IsFlat=" + (positionExists ? position.IsFlat().ToString() : "N/A") + " Quantity=" + currentPositionQuantity.ToString() + " via " + signalName);
                            }
                            
                            // Clear scheduled take profit
                            hasScheduledTakeProfit = false;
                            scheduledTakeProfitInstrument = null;
                            scheduledTakeProfitOrderAction = null;
                            scheduledTakeProfitQuantity = 0;
                            scheduledTakeProfitPrice = 0;
                            scheduledTakeProfitCreationTime = DateTime.MinValue;
                        }
                        else
                        {
                            // Clear invalid scheduled take profit
                            hasScheduledTakeProfit = false;
                            scheduledTakeProfitInstrument = null;
                            scheduledTakeProfitOrderAction = null;
                            scheduledTakeProfitQuantity = 0;
                            scheduledTakeProfitPrice = 0;
                            scheduledTakeProfitCreationTime = DateTime.MinValue;
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CheckAndExecuteDelayedTakeProfit: " + ex.Message + " " + ex.StackTrace + " via " + signalName);
                }
            }
        }

        private void ScheduleDelayedStopLoss(string signalName, Instrument instrument, OrderAction orderAction, int quantity, double price)
        {
            lock (DelayedStopLossLock)
            {
                try
                {
                    // If there's already a scheduled stop loss for the same instrument and order action, update it with new total quantity
                    // BUT only if it hasn't expired yet - if it has expired, let CheckAndExecuteDelayedStopLoss execute it first
                    if (hasScheduledStopLoss 
                        && scheduledStopLossInstrument == instrument 
                        && scheduledStopLossOrderAction.HasValue 
                        && scheduledStopLossOrderAction.Value == orderAction
                        && scheduledStopLossCreationTime > GetDateTimeNow()) // Only update if not expired
                    {
                        // Delay reset is driven by quantity changes, not price changes
                        bool quantityChanged = scheduledStopLossQuantity != quantity;
                        bool priceChanged = Math.Abs(scheduledStopLossPrice - price) > 0.01; // Use small epsilon for price comparison
                        
                        if (quantityChanged)
                        {
                            // Reset the delay timer when quantity changes - this allows batching multiple position changes within the delay window
                        scheduledStopLossQuantity = quantity; // This will be the current total position quantity
                        scheduledStopLossPrice = price;
                            scheduledStopLossCreationTime = (GetDateTimeNow()).AddSeconds(StopLossAddOnDelaySeconds);
                            
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated scheduled SL: quantity=" + quantity.ToString() + " price=" + price.ToString("N2") + " delay=" + StopLossAddOnDelaySeconds.ToString() + "s (batching) via " + signalName);
                        }
                        else if (priceChanged)
                        {
                            // Update price only without resetting delay timer
                            scheduledStopLossPrice = price;
                            
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated scheduled SL price only: price=" + price.ToString("N2") + " (expires in " + (scheduledStopLossCreationTime - GetDateTimeNow()).TotalSeconds.ToString("F1") + "s) via " + signalName);
                        }
                        else
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Skipping SL schedule update: quantity and price unchanged (expires in " + (scheduledStopLossCreationTime - GetDateTimeNow()).TotalSeconds.ToString("F1") + "s) via " + signalName);
                        }
                    }
                    else if (hasScheduledStopLoss 
                        && scheduledStopLossInstrument == instrument 
                        && scheduledStopLossOrderAction.HasValue 
                        && scheduledStopLossOrderAction.Value == orderAction
                        && scheduledStopLossCreationTime <= GetDateTimeNow()) // Expired - let CheckAndExecuteDelayedStopLoss execute it
                    {
                        // Check if quantity changed - if so, we need to reschedule for the new position change
                        bool quantityChanged = scheduledStopLossQuantity != quantity;
                        
                        if (quantityChanged)
                        {
                            // Quantity changed - reschedule with new values to batch the new position change
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Rescheduling expired SL due to quantity change: quantity=" + quantity.ToString() + " price=" + price.ToString("N2") + " via " + signalName);
                            scheduledStopLossQuantity = quantity;
                            scheduledStopLossPrice = price;
                            scheduledStopLossCreationTime = (GetDateTimeNow()).AddSeconds(StopLossAddOnDelaySeconds);
                            
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Rescheduled delayed SL: quantity=" + quantity.ToString() + " price=" + price.ToString("N2") + " delay=" + StopLossAddOnDelaySeconds.ToString() + "s via " + signalName);
                        }
                        else
                        {
                            // Quantity unchanged - let CheckAndExecuteDelayedStopLoss execute the expired scheduled SL
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Skipping SL schedule: expired scheduled SL will be executed by CheckAndExecuteDelayedStopLoss via " + signalName);
                        }
                    }
                    else
                    {
                        // Cancel any existing scheduled stop loss for different instrument/action
                        if (hasScheduledStopLoss)
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Canceling previous scheduled SL for different instrument/action via " + signalName);
                        }
                        
                        // Schedule new delayed stop loss creation
                        scheduledStopLossInstrument = instrument;
                        scheduledStopLossOrderAction = orderAction;
                        scheduledStopLossQuantity = quantity;
                        scheduledStopLossPrice = price;
                        scheduledStopLossCreationTime = (GetDateTimeNow()).AddSeconds(StopLossAddOnDelaySeconds);
                        hasScheduledStopLoss = true;
                        
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Scheduled delayed SL: quantity=" + quantity.ToString() + " price=" + price.ToString("N2") + " delay=" + StopLossAddOnDelaySeconds.ToString() + "s via " + signalName);
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in ScheduleDelayedStopLoss: " + ex.Message + " " + ex.StackTrace + " via " + signalName);
                }
            }
        }

        private void CheckAndExecuteDelayedStopLoss(string signalName)
        {
            lock (DelayedStopLossLock)
            {
                try
                {
                    if (hasScheduledStopLoss && scheduledStopLossCreationTime <= GetDateTimeNow())
                    {
                        if (scheduledStopLossInstrument != null 
                            && scheduledStopLossOrderAction.HasValue 
                            && scheduledStopLossQuantity > 0 
                            && scheduledStopLossPrice > 0
                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                        {
                            // Get current position quantity to ensure we use the latest total
                            int currentPositionQuantity = 0;
                            RealPosition position = null;
                            bool positionExists = false;
                            
                            // Iterate through positions to find the one matching the instrument and account
                            int positionCount = RealPositionService.PositionCount;
                            for (int index = 0; index < positionCount; index++)
                            {
                                RealPosition tempPosition = null;
                                if (RealPositionService.TryGetByIndex(index, out tempPosition))
                                {
                                    if (tempPosition != null && tempPosition.Instrument == scheduledStopLossInstrument && account != null && tempPosition.Account == account)
                                    {
                                        position = tempPosition;
                                        positionExists = true;
                                        currentPositionQuantity = position.Quantity;
                                        break;
                                    }
                                }
                            }
                            
                            // Safety check: Don't create/update SL order if position is flat
                            if (positionExists && position != null && !position.IsFlat() && currentPositionQuantity > 0 && scheduledStopLossOrderAction.HasValue)
                            {
                                // Use the larger of scheduled quantity or current position quantity (in case position changed)
                                int finalQuantity = Math.Max(scheduledStopLossQuantity, currentPositionQuantity);
                                
                                if (finalQuantity > 0)
                                {
                                    double lastPrice = RealInstrumentService.GetLastPrice(scheduledStopLossInstrument);
                                    bool isPriceValid = RealOrderService.IsValidStopLossPrice(scheduledStopLossInstrument, scheduledStopLossOrderAction.Value, scheduledStopLossPrice, lastPrice);
                                    
                                    if (isPriceValid)
                                    {
                                        bool hasActiveSL = HasActiveStopLossOrder(scheduledStopLossInstrument, scheduledStopLossOrderAction.Value);
                                        
                                        if (!hasActiveSL)
                                        {
                                            // No active SL order - create new one
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Executing delayed SL: quantity=" + finalQuantity.ToString() + " price=" + scheduledStopLossPrice.ToString("N2") + " via " + signalName);
                                        CreatePositionStopLoss(signalName, scheduledStopLossInstrument, scheduledStopLossOrderAction.Value, OrderEntry.Manual, finalQuantity, scheduledStopLossPrice);
                                        }
                                        else
                                        {
                                            // Active SL order exists - update it (for quantity mismatch)
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Executing delayed SL update: quantity=" + finalQuantity.ToString() + " price=" + scheduledStopLossPrice.ToString("N2") + " via " + signalName);
                                            UpdatePositionStopLoss(signalName, scheduledStopLossInstrument, scheduledStopLossOrderAction.Value, OrderEntry.Manual, finalQuantity, scheduledStopLossPrice);
                                        }
                                    }
                                    else
                                    {
                                        RealLogger.PrintOutput("WARNING: Delayed SL price invalid, skipping creation. Price=" + scheduledStopLossPrice.ToString("N2") + " LastPrice=" + lastPrice.ToString("N2") + " via " + signalName);
                                    }
                                }
                            }
                            else
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput("Skipping delayed SL: position flat. PositionExists=" + positionExists.ToString() + " IsFlat=" + (positionExists ? position.IsFlat().ToString() : "N/A") + " Quantity=" + currentPositionQuantity.ToString() + " via " + signalName);
                            }
                            
                            // Clear scheduled stop loss
                            hasScheduledStopLoss = false;
                            scheduledStopLossInstrument = null;
                            scheduledStopLossOrderAction = null;
                            scheduledStopLossQuantity = 0;
                            scheduledStopLossPrice = 0;
                            scheduledStopLossCreationTime = DateTime.MinValue;
                        }
                        else
                        {
                            // Clear invalid scheduled stop loss
                            hasScheduledStopLoss = false;
                            scheduledStopLossInstrument = null;
                            scheduledStopLossOrderAction = null;
                            scheduledStopLossQuantity = 0;
                            scheduledStopLossPrice = 0;
                            scheduledStopLossCreationTime = DateTime.MinValue;
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CheckAndExecuteDelayedStopLoss: " + ex.Message + " " + ex.StackTrace + " via " + signalName);
                }
            }
        }

        private bool ConsolidatePositionTPSLOrders(string signalName, Instrument instrument)
        {
            bool returnFlag = false;

            bool closeAll = false;

            int buyOrderCount = 0;
            int sellOrderCount = 0;

            bool hasSkippedFirst = false;
            OrderType stopLossOrderType = OrderType.StopMarket;
            OrderType takeProfitOrderType = OrderType.Limit;

            List<Order> cancelOrderList = new List<Order>();

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;
                bool isFirstStopLossOrder = false;
                bool isFirstTakeProfitOrder = false;
                Order firstStopLossOrder = null;
                Order firstTakeProfitOrder = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidStopLossOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidStopLossOrder(order, instrument, OrderAction.Sell)
                       || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.Sell))
                    {
                        if (order.OrderType == stopLossOrderType && (order.OrderState == OrderState.Accepted || order.OrderState == OrderState.Working))
                        {
                            if (!isFirstStopLossOrder)
                            {
                                isFirstStopLossOrder = true;
                                Order foundNTOrder = GetNinjaTraderOrder(order);
                                firstStopLossOrder = foundNTOrder;
                            }
                            else
                            {
                                Order foundNTOrder = GetNinjaTraderOrder(order);
                                cancelOrderList.Add(foundNTOrder);
                            }
                        }
                        else if (order.OrderType == takeProfitOrderType && order.OrderState == OrderState.Working)
                        {
                            if (!isFirstTakeProfitOrder)
                            {
                                isFirstTakeProfitOrder = true;
                                Order foundNTOrder = GetNinjaTraderOrder(order);
                                firstTakeProfitOrder = foundNTOrder;
                            }
                            else
                            {
                                Order foundNTOrder = GetNinjaTraderOrder(order);
                                cancelOrderList.Add(foundNTOrder);
                            }
                        }
                    }
                }

                int stopLossQuantity = 0;
                int takeProfitQuantity = 0;

                if (firstStopLossOrder != null)
                {
                    stopLossQuantity = firstStopLossOrder.Quantity;
                }

                if (firstTakeProfitOrder != null)
                {
                    takeProfitQuantity = firstTakeProfitOrder.Quantity;
                }

                foreach (Order cancelOrder in cancelOrderList)
                {
                    bool increamentStopLossQuantity = false;
                    bool increamentTakeProfitQuantity = false;
                    int initialStopLossQuantity = 0;
                    int initialTakeProfitQuantity = 0;
                    int cancelOrderQuantity = 0;

                    try
                    {
                        increamentStopLossQuantity = (cancelOrder.OrderType == stopLossOrderType && firstStopLossOrder != null);
                        increamentTakeProfitQuantity = (cancelOrder.OrderType == takeProfitOrderType && firstTakeProfitOrder != null);
                        cancelOrderQuantity = cancelOrder.Quantity;

                        account.Cancel(new[] { cancelOrder });

                        if (increamentStopLossQuantity)
                        {
                            stopLossQuantity += cancelOrderQuantity;

                            firstStopLossOrder.QuantityChanged = stopLossQuantity;

                            account.Change(new[] { firstStopLossOrder });

                            firstStopLossOrder.Quantity = stopLossQuantity;
                        }
                        else if (increamentTakeProfitQuantity)
                        {
                            takeProfitQuantity += cancelOrderQuantity;

                            firstTakeProfitOrder.QuantityChanged = takeProfitQuantity;

                            account.Change(new[] { firstTakeProfitOrder });

                            firstTakeProfitOrder.Quantity = takeProfitQuantity;
                        }

                        returnFlag = true;
                    }
                    catch (Exception ex)
                    {
                        RealLogger.PrintOutput("Exception in ConsolidatePositionTPSLOrders:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                    }
                }
            }

            return returnFlag;
        }

        private bool CancelPositionTPSLOrders(string signalName, Instrument instrument, OrderAction? orderAction = null)
        {
            bool returnFlag = false;
            bool closeAll = false;
            OrderAction tempOrderAction = OrderAction.BuyToCover;

            if (orderAction == null)
                closeAll = true;
            else if (orderAction == OrderAction.BuyToCover)
                tempOrderAction = OrderAction.BuyToCover;
            else if (orderAction == OrderAction.Sell)
                tempOrderAction = OrderAction.Sell;
            else
            {
                RealLogger.PrintOutput("Order action type not supported: " + Convert.ToString(orderAction));
            }

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (closeAll && (RealOrderService.IsValidStopLossOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidStopLossOrder(order, instrument, OrderAction.Sell)
                        || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.Sell))
                        || (!closeAll && (RealOrderService.IsValidStopLossOrder(order, instrument, tempOrderAction) || RealOrderService.IsValidTakeProfitOrder(order, instrument, tempOrderAction))))
                    {
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            try
                            {

                                account.Cancel(new[] { foundNTOrder });
                                returnFlag = true;
                            }
                            catch (Exception ex)
                            {
                                RealLogger.PrintOutput("Exception in CancelPositionTPSLOrders:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                            }
                        }
                    }
                }
            }

            return returnFlag;
        }

        private bool CancelPositionTPOrders(string signalName, Instrument instrument, OrderAction? orderAction = null)
        {
            bool returnFlag = false;
            bool closeAll = false;
            OrderAction tempOrderAction = OrderAction.BuyToCover;

            if (orderAction == null)
                closeAll = true;
            else if (orderAction == OrderAction.BuyToCover)
                tempOrderAction = OrderAction.BuyToCover;
            else if (orderAction == OrderAction.Sell)
                tempOrderAction = OrderAction.Sell;
            else
            {
                RealLogger.PrintOutput("Order action type not supported: " + Convert.ToString(orderAction));
            }

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (closeAll
                        && (RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.BuyToCover)
                        || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.Sell))
                        || (!closeAll && RealOrderService.IsValidTakeProfitOrder(order, instrument, tempOrderAction)))
                    {
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            try
                            {

                                account.Cancel(new[] { foundNTOrder });
                                returnFlag = true;
                            }
                            catch (Exception ex)
                            {
                                RealLogger.PrintOutput("Exception in CancelPositionTPSLOrders:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                            }
                        }
                    }
                }
            }

            return returnFlag;
        }

        private void UpdatePositionTakeProfit(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);
            bool isValid = RealOrderService.IsValidTakeProfitPrice(instrument, orderAction, price, lastPrice);
            if (orderAction == OrderAction.BuyToCover && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Take Profit order price must be less than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Take Profit order price must be greater than last price.");
                return;
            }

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidTakeProfitOrder(order, instrument, orderAction))
                    {
                        bool orderChanged = false;
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            if (foundNTOrder.Quantity != quantity && quantity != 0)
                            {
                                foundNTOrder.QuantityChanged = quantity;
                                orderChanged = true;
                            }
                            if (foundNTOrder.LimitPrice != price)
                            {
                                foundNTOrder.LimitPriceChanged = price;
                                orderChanged = true;
                            }

                            if (orderChanged)
                            {
                                try
                                {
                                    account.Change(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in UpdatePositionTakeProfit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                            if (quantity != 0) break; //only change one if also setting quantity
                        }
                    }
                }
            }
        }

        private bool FlattenEverything(string signalName, bool continueTillZeroRemainingQuantity, Instrument limitToSingleInstrument)
        {
            bool positionFound = false;

            var lockTimeout = TimeSpan.FromMilliseconds(250);
            bool lockTaken = false;

            try
            {
                Monitor.TryEnter(FlattenEverythingLock, lockTimeout, ref lockTaken);

                if (lockTaken)
                {
                    if (RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        CloseAllAccountPendingOrders(signalName, limitToSingleInstrument);

                        if (!IsAccountFlat())
                        {
                            double unrealizedProfitLoss = 0;
                            OrderAction orderAction = OrderAction.Buy;
                            int positionCount = RealPositionService.PositionCount;

                            for (int index = 0; index < positionCount; index++)
                            {
                                RealPosition position = null;
                                if (RealPositionService.TryGetByIndex(index, out position))
                                {
                                    if (limitToSingleInstrument == null || position.Instrument == limitToSingleInstrument)
                                    {
                                        position.StoreState();
                                        positionFound = true;

                                        unrealizedProfitLoss = GetPositionProfit(position);

                                        if (position.MarketPosition == MarketPosition.Long)
                                            orderAction = OrderAction.Sell;
                                        else if (position.MarketPosition == MarketPosition.Short)
                                            orderAction = OrderAction.Buy;

                                        if (position.Quantity > 0 && !position.HasStateChanged() && !position.IsFlat())
                                        {
                                            RealLogger.PrintOutput(signalName + " closing " + position.MarketPosition.ToString() + " " + position.Instrument.FullName + " Quantity=" + position.Quantity + " PnL=" + Convert.ToString(unrealizedProfitLoss) + " via " + signalName, PrintTo.OutputTab1);

                                            SubmitMarketOrderChunked(signalName, position.Instrument, orderAction, OrderEntry.Manual, position.Quantity, continueTillZeroRemainingQuantity);
                                        }

                                        if (!continueTillZeroRemainingQuantity) break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling FlattenEverything:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                throw;
            }
            finally
            {
                if (lockTaken)
                {
                    Monitor.Exit(FlattenEverythingLock);
                }
            }

            return positionFound;
        }

        private bool IsMaxDDStopLossEnabled()
        {
            bool returnFlag = false;

            if (maxDDInDollars < 0)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsDayOverAccountBalanceFloorEnabled()
        {
            bool returnFlag = false;

            if (DayOverAccountBalanceFloorDollars > 0)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsDayOverMaxLossEnabled()
        {
            bool returnFlag = false;

            if (dayOverMaxLossDollars > 0)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsHODLEnabled()
        {
            bool returnFlag = false;

            if (breakEvenAutoHODLFlag)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsBogeyTargetEnabled()
        {
            bool returnFlag = false;

            if (BogeyTargetBaseDollars > 0 && currentBogeyTargetMultiplier != BogeyTargetMultiplierDisabled
                && currentProfitTargetStatus == TickHunterProfitTargetTypes.BogeyTarget)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsAutoPositionTakeProfitEnabled()
        {
            bool returnFlag = false;

            if (UseAutoPositionTakeProfit && !IsHODLEnabled() && !bypassAutoPositionTakeProfit)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsAutoPositionStopLossEnabled()
        {
            bool returnFlag = false;

            if (UseAutoPositionStopLoss)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsECATPEnabled()
        {
            bool returnFlag = false;

            if ((ECATargetDollars > 0 || ECATargetDollarsPerOtherVolume > 0) && currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsExcessIntradayMarginMinDollarsEnabled()
        {
            bool returnFlag = false;

            if (ExcessIntradayMarginMinDollars > 0)
                returnFlag = true;

            return (returnFlag);
        }

        private int GetValidVolumeSize(int volumeSize)
        {
            int newVolumeSize = DEFAULT_VOLUME_SIZE;

            bool isPositiveVolumeSize = volumeSize > 0;

            if (isPositiveVolumeSize)
            {
                newVolumeSize = volumeSize;
            }
            else
            {
                RealLogger.PrintOutput("GetValidVolumeSize: Invalid volume size: " + volumeSize.ToString("N0"));
            }

            return newVolumeSize;
        }

        private int GetLimitedIncrementVolumeSize(int incrementVolumeSize, int maxInitialTrancheVolumeSize, bool limitTrancheVolumeToInProfit)
        {
            int newVolumeSize = DEFAULT_VOLUME_SIZE;

            int validatedIncrementVolumeSize = GetValidVolumeSize(incrementVolumeSize);

            if (limitTrancheVolumeToInProfit)
            {
                int validatedMaxInitialTrancheVolumeSize = GetValidVolumeSize(maxInitialTrancheVolumeSize);

                bool isIncrementVolumeSizeValidForBogey = limitTrancheVolumeToInProfit && validatedIncrementVolumeSize <= validatedMaxInitialTrancheVolumeSize;

                if (!limitTrancheVolumeToInProfit
                   || isIncrementVolumeSizeValidForBogey)
                {
                    newVolumeSize = validatedIncrementVolumeSize;
                }
                else if (validatedIncrementVolumeSize <= validatedMaxInitialTrancheVolumeSize)
                {
                    newVolumeSize = validatedIncrementVolumeSize;
                }
                else
                {
                    newVolumeSize = validatedMaxInitialTrancheVolumeSize;
                    //RealLogger.PrintOutput("GetValidVolumeSize: Invalid increment volume size: IncrementVolumeSize=" + incrementVolumeSize.ToString("N0") + " MaxInitialTrancheVolumeSize=" + maxInitialTrancheVolumeSize.ToString("N0"));
                }
            }
            else
            {
                newVolumeSize = validatedIncrementVolumeSize;
            }

            return newVolumeSize;
        }

        private bool TryGetLimitTrancheVolumeSize(int positionVolumeSize, bool positionInProfit, int incrementVolumeSize, out int newVolumeSize)
        {
            bool addOnVolumeAllowed = false;
            newVolumeSize = DEFAULT_VOLUME_SIZE;

            if (LimitToVolumeMaxOption)
            {
                bool maxVolumeGroup1Enabled = EntryVolumeMaxOption1 > 0;
                bool maxVolumeGroup2Enabled = EntryVolumeMaxOption2 > 0;
                bool maxVolumeGroup3Enabled = EntryVolumeMaxOption3 > 0;
                bool maxVolumeGroup4Enabled = EntryVolumeMaxOption4 > 0;
                bool maxVolumeGroup5Enabled = EntryVolumeMaxOption5 > 0;

                if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option1)
                {
                    if (maxVolumeGroup1Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption1;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption1 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option2)
                {
                    if (maxVolumeGroup2Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption2;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption2 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option3)
                {
                    if (maxVolumeGroup3Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption3;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption3 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option4)
                {
                    if (maxVolumeGroup4Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption4;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption4 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option5)
                {
                    if (maxVolumeGroup5Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption5;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption5 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
            }
            
            if (limitTrancheVolumeToInProfitFlag
                && ((!LimitToVolumeMaxOption) || (LimitToVolumeMaxOption && addOnVolumeAllowed)))
            {
                int limitedIncrementVolumeSize = GetLimitedIncrementVolumeSize(incrementVolumeSize, maxInitialTrancheVolumeSize, limitTrancheVolumeToInProfitFlag);
                bool isPositionVolumeAlreadyAtBogeyVolumeSize = positionVolumeSize >= maxInitialTrancheVolumeSize;

                if (positionInProfit && isPositionVolumeAlreadyAtBogeyVolumeSize)
                {
                    newVolumeSize = incrementVolumeSize;
                    addOnVolumeAllowed = true;
                }
                else
                {
                    int remainingVolumeSize = maxInitialTrancheVolumeSize - positionVolumeSize;

                    bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                    bool isFullIncrementTooLarge = limitedIncrementVolumeSize > remainingVolumeSize;

                    if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                    {
                        newVolumeSize = remainingVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                    else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                    {
                        newVolumeSize = limitedIncrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }

            }

            return addOnVolumeAllowed;
        }

        private int GetRandomNumber(int maxValue)
        {
            int randomNumber = 0;

            if (maxValue == 1)
            {
                randomNumber = maxValue;
            }
            else if (maxValue > 0)
            {
                int minValue = (int)maxValue / 2; // half number to create range
                Random random = new Random();
                randomNumber = random.Next(minValue, maxValue + 1);
            }

            return randomNumber;
        }

        private void SubmitMarketOrder(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity)
        {
            lock (MarketOrderLock)
            {
                string orderName = RealOrderService.BuildEntryOrderName();

                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, OrderType.Market, orderEntry, TimeInForce.Day, quantity, 0, 0, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy())
                    {
                        NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);
                    }

                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening market order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening market order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);
                    }

                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in SubmitMarketOrder:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void SubmitMarketOrderChunked(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, bool continueTillZeroRemainingQuantity = true)
        {

            int quantityRemaining = quantity;
            int chunkedQuantity = 0;
            int cycleCount = 1;

            lock (MarketOrderLock)
            {
                if (quantityRemaining > 0)
                {
                    lock (MarketOrderLock)
                    {
                        while (quantityRemaining > 0)
                        {
                            if (quantityRemaining > this.SingleOrderChunkMaxQuantity)
                            {
                                int randomQuantity = GetRandomNumber(this.SingleOrderChunkMaxQuantity);
                                chunkedQuantity = randomQuantity;
                            }
                            else if (quantityRemaining > this.SingleOrderChunkMinQuantity)
                            {
                                int randomQuantity = GetRandomNumber(this.SingleOrderChunkMinQuantity);
                                chunkedQuantity = randomQuantity;
                            }
                            else
                            {
                                chunkedQuantity = quantityRemaining;
                            }

                            quantityRemaining -= chunkedQuantity;

                            if (cycleCount > 1 && SingleOrderChunkDelayMilliseconds > 0) Thread.Sleep(SingleOrderChunkDelayMilliseconds);

                            string orderName = RealOrderService.BuildExitOrderName();

                            try
                            {
                                Order exitOrder = account.CreateOrder(instrument, orderAction, OrderType.Market, orderEntry, TimeInForce.Day, chunkedQuantity, 0, 0, "", orderName, Core.Globals.MaxDate, null);

                                account.Submit(new[] { exitOrder });
                            }
                            catch (Exception ex)
                            {
                                RealLogger.PrintOutput("Exception in SubmitMarketOrder:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                            }

                            cycleCount++;

                            if (!continueTillZeroRemainingQuantity) break;
                        }
                    }
                }
            }
        }

        private int CalculateAutoEntryVolume(TickHunterEntryVolumeAutoTypes entryVolumeAutoType)
        {
            int entryVolume = AutoEntryVolumeOption1;

            if (entryVolumeAutoType == TickHunterEntryVolumeAutoTypes.Option2)
            {
                entryVolume = AutoEntryVolumeOption2;
            }
            else if (entryVolumeAutoType == TickHunterEntryVolumeAutoTypes.Option3)
            {
                entryVolume = AutoEntryVolumeOption3;
            }
            else if (entryVolumeAutoType == TickHunterEntryVolumeAutoTypes.Option4)
            {
                entryVolume = AutoEntryVolumeOption4;
            }
            else if (entryVolumeAutoType == TickHunterEntryVolumeAutoTypes.Option5)
            {
                entryVolume = AutoEntryVolumeOption5;
            }

            return entryVolume;
        }

        private void GenerateEntryVolumeAutoButtonText()
        {
            const string AutoEntryButtonPrefix = "V(";
            const string AutoEntryButtonSuffix = ")";
            const string AutoEntryButtonToolTipPrefix = "Volume (";

            ToggleAutoEntryVolOption1ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption1 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption1ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption1 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption2ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption2 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption2ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption2 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption3ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption3 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption3ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption3 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption4ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption4 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption4ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption4 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption5ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption5 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption5ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption5 + AutoEntryButtonSuffix;
        }

        private int CalculateEntryVolumeMax(TickHunterEntryVolumeMaxTypes entryVolumeMaxType)
        {
            int entryVolume = EntryVolumeMaxOption1;

            if (entryVolumeMaxType == TickHunterEntryVolumeMaxTypes.Option2)
            {
                entryVolume = EntryVolumeMaxOption2;
            }
            else if (entryVolumeMaxType == TickHunterEntryVolumeMaxTypes.Option3)
            {
                entryVolume = EntryVolumeMaxOption3;
            }
            else if (entryVolumeMaxType == TickHunterEntryVolumeMaxTypes.Option4)
            {
                entryVolume = EntryVolumeMaxOption4;
            }
            else if (entryVolumeMaxType == TickHunterEntryVolumeMaxTypes.Option5)
            {
                entryVolume = EntryVolumeMaxOption5;
            }

            return entryVolume;
        }

        private void GenerateEntryVolumeMaxButtonText()
        {
            const string EntryButtonPrefix = "VM(";
            const string EntryButtonSuffix = ")";
            const string EntryButtonToolTipPrefix = "Volume Max (";

            ToggleEntryVolMaxOption1ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption1 + EntryButtonSuffix;
            ToggleEntryVolMaxOption1ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption1 + EntryButtonSuffix;
            ToggleEntryVolMaxOption2ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption2 + EntryButtonSuffix;
            ToggleEntryVolMaxOption2ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption2 + EntryButtonSuffix;
            ToggleEntryVolMaxOption3ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption3 + EntryButtonSuffix;
            ToggleEntryVolMaxOption3ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption3 + EntryButtonSuffix;
            ToggleEntryVolMaxOption4ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption4 + EntryButtonSuffix;
            ToggleEntryVolMaxOption4ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption4 + EntryButtonSuffix;
            ToggleEntryVolMaxOption5ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption5 + EntryButtonSuffix;
            ToggleEntryVolMaxOption5ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption5 + EntryButtonSuffix;
        }

        private void GetBogeyTargetTypeButtonText(int bogeyTargetMultiplier, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            if (bogeyTargetMultiplier > BogeyTargetMultiplierDisabled)
            {
                const string StarText = "*";
                const string ZeroPnLText = " (ZeroPnL)";

                string flagActiveText = "";
                string flagActiveTextToolTip = "";

                if (!bogeyTargetStartWithFullPnLFlag)
                {
                    flagActiveText = StarText;
                    flagActiveTextToolTip = ZeroPnLText;
                }

                buttonText = String.Format(ToggleProfitTargetX0ButtonEnabledText, bogeyTargetMultiplier, flagActiveText);
                buttonToolTipText = String.Format(ToggleProfitTargetX0ButtonEnabledToolTip, bogeyTargetMultiplier, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleProfitTargetButtonDisabledText;
                buttonToolTipText = ToggleProfitTargetButtonDisabledToolTip;
            }
        }

        private bool IsAccountFlat()
        {
            bool returnFlag = true;

            returnFlag = (RealPositionService.PositionCount == 0);

            return returnFlag;
        }

        private bool IsAccountFlat(Instrument instrument)
        {
            bool returnFlag = true;

            RealPosition position = new RealPosition();

            returnFlag = (!RealPositionService.TryGetByInstrumentFullName(instrument.FullName, out position));

            return returnFlag;
        }

        private void CloseAllAccountPendingOrders(string signalName, Instrument limitToSingleInstrument)
        {
            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (limitToSingleInstrument == null || order.Instrument == limitToSingleInstrument)
                    {
                        if (!Order.IsTerminalState(order.OrderState))
                        {
                            if (DebugLogLevel > 0) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                            Order foundNTOrder = GetNinjaTraderOrder(order);

                            if (foundNTOrder != null)
                            {
                                try
                                {
                                    account.Cancel(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in CloseAllAccountPendingOrders:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                        }
                    }
                }
            }
        }

        protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
        {
            try
            {
                base.OnRender(chartControl, chartScale);

                if (!hasDrawnButtons)
                {
                    if (IsStrategyAttachedToChart() && HasRanOnceFirstCycle())
                    {
                        DrawButtonPanel();
                        if (!IsTickHunterActivated())
                        {
                            string signalName = "OnRender";
                            DeactivateTickHunter(signalName);
                        }
                        else
                        {
                            SetButtonPanelVisiblity();
                        }

                        hasDrawnButtons = true;
                    }
                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception in OnRender:" + ex.Message + " " + ex.StackTrace);  //log and rethrow
                throw;
            }
        }

        private bool HasRanOnceFirstCycle()
        {
            string signalName = "HasRanOnceFirstCycle";

            if (!hasRanOnceFirstCycle && attachedInstrumentServerSupported && BarsInProgress == 0 && CurrentBar > 0) //&& BarsInProgress == 0 && this.State == State.Realtime)
            {
                lock (AccountLock)
                {
                    if (!hasRanOnceFirstCycle)
                    {
                        this.RealOrderService = new RealOrderService();
                        this.RealPositionService = new RealPositionService();

                        lastOrderOutputTime = DateTime.MinValue;

                        DeactivateAutoEntryFeatures(signalName);

                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            LoadAccount();
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                LoadAccount();
                            }));
                        }

                        if (account != null)
                        {
                            LoadATMStrategy();
                            LoadPositions();
                            
                            // TPSL check moved to ActivateTickHunter to only run when activated

                            if (IsDayOverAccountBalanceFloorEnabled())
                            {
                                RealLogger.PrintOutput("Day Over Account Balance Floor: $" + DayOverAccountBalanceFloorDollars.ToString("N2"), PrintTo.OutputTab1);
                                RealLogger.PrintOutput("Day Over Account Balance Floor: $" + DayOverAccountBalanceFloorDollars.ToString("N2"), PrintTo.OutputTab2);
                            }

                            if (IsBogeyTargetEnabled())
                            {
                                double bogeyTargetMultiplier = currentBogeyTargetMultiplier; // CalculateBogeyTargetMutiplier(currentBogeyTargetStatus);
                                double dpMultipliedAmount = (BogeyTargetBaseDollars * bogeyTargetMultiplier);

                                RealLogger.PrintOutput("Bogey Target Base: $" + BogeyTargetBaseDollars.ToString("N2") + " x " + bogeyTargetMultiplier.ToString("N0") + " ($" + dpMultipliedAmount.ToString("N0") + ")", PrintTo.OutputTab1);
                                RealLogger.PrintOutput("Bogey Target Base: $" + BogeyTargetBaseDollars.ToString("N2") + " x " + bogeyTargetMultiplier.ToString("N0") + " ($" + dpMultipliedAmount.ToString("N0") + ")", PrintTo.OutputTab2);
                            }

                            if (limitTrancheVolumeToInProfitFlag)
                            {
                                RealLogger.PrintOutput("Max Initial Tranche Volume Size: " + maxInitialTrancheVolumeSize.ToString("N0"));
                            }

                            if (limitTrancheVolumePerBarFlag)
                            {
                                RealLogger.PrintOutput("Min Tranche Volume Per Bar Delay Seconds: " + MinTrancheVolumeDelaySeconds.ToString("N0"));
                            }

                            if (IsDayOverMaxLossEnabled())
                            {
                                RealLogger.PrintOutput("Day Over Max Loss: $" + dayOverMaxLossDollars.ToString("N2"), PrintTo.OutputTab1);
                                RealLogger.PrintOutput("Day Over Max Loss: $" + dayOverMaxLossDollars.ToString("N2"), PrintTo.OutputTab2);
                            }

                            if (IsMaxDDStopLossEnabled())
                            {
                                RealLogger.PrintOutput("Max DD: $" + maxDDInDollars.ToString("N2"), PrintTo.OutputTab1);
                                RealLogger.PrintOutput("Max DD: $" + maxDDInDollars.ToString("N2"), PrintTo.OutputTab2);
                            }

                            attachedInstrumentCommissionPerSide = GetInstrumentCommissionPerSide(attachedInstrument);
                            RealLogger.PrintOutput("Detected commission per side: $" + attachedInstrumentCommissionPerSide.ToString("N2") + " for " + attachedInstrument.FullName, PrintTo.OutputTab1);
                            RealLogger.PrintOutput("Detected commission per side: $" + attachedInstrumentCommissionPerSide.ToString("N2") + " for " + attachedInstrument.FullName, PrintTo.OutputTab2);

                            attachedInstrumentIntradayMarginDollars = GetInstrumentIntradayMarginDollars(attachedInstrument);
                            RealLogger.PrintOutput("Detected intraday margin dollars: $" + attachedInstrumentIntradayMarginDollars.ToString("N2") + " for " + attachedInstrument.FullName, PrintTo.OutputTab1);
                            RealLogger.PrintOutput("Detected intraday margin dollars: $" + attachedInstrumentIntradayMarginDollars.ToString("N2") + " for " + attachedInstrument.FullName, PrintTo.OutputTab2);

                            attachedInstrumentPositionMaxVolume = GetInstrumentPositionMaxVolume(attachedInstrument);
                            RealLogger.PrintOutput("Detected position max volume: " + attachedInstrumentPositionMaxVolume.ToString("N0") + " for " + attachedInstrument.FullName, PrintTo.OutputTab1);
                            RealLogger.PrintOutput("Detected position max volume: " + attachedInstrumentPositionMaxVolume.ToString("N0") + " for " + attachedInstrument.FullName, PrintTo.OutputTab2);

                                                       if (UseHotKeys)
                            {
                                string hotKeyDisplayName = string.Empty;

                                hotKeyDisplayName = BuyMarketHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    buyMarketHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected buy market hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = SellMarketHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    sellMarketHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected sell market hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = BuyPopHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    buyPopHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected buy pop hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = SellPopHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    sellPopHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected sell pop hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = CloseHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    closeHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected close hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = ReverseHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    reverseHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected reverse hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = BreakEvenPlusHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    breakEvenPlusHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected break-even plus hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = StopLossPlusHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    stopLossPlusHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected stop-loss plus hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = VolumeHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    volumeHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected volume hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }

                                hotKeyDisplayName = ActivateHotKey;
                                if (!string.IsNullOrEmpty(hotKeyDisplayName))
                                {
                                    activateHotKeyValue = ConvertHotKeyDisplayNameToKey(hotKeyDisplayName);
                                    RealLogger.PrintOutput("Detected activate hot key: " + hotKeyDisplayName, PrintTo.OutputTab1);
                                }
                            }


                            /*
                            if (UseHedgehogEntry && attachedInstrumentIsFuture)
                            {
                                RealLogger.PrintOutput("Validating HedgehogEntrySymbol1...", PrintTo.OutputTab2);
                                ValidateInstrument(HedgehogEntrySymbol1FullName);

                                RealLogger.PrintOutput("Validating HedgehogEntrySymbol2...", PrintTo.OutputTab2);
                                ValidateInstrument(HedgehogEntrySymbol2FullName);
                            }
                            */





                            /*
                            if (ChartControl.Dispatcher.CheckAccess())
                            {
                                LoadAccount();
                            }
                            else
                            {
                                ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                                {
                                    LoadAccount();
                                }));
                            }
                            */

                            /*

                            if (IsStrategyAttachedToChart() && UserControlCollection.Contains(buttonGrid))
                            {
                                if (ChartControl != null)
                                {
                                    if (ChartControl.Dispatcher.CheckAccess())
                                    {
                                        SetButtonPanelVisiblity();
                                    }
                                    else
                                    {
                                        ChartControl.Dispatcher.InvokeAsync((() =>
                                        {
                                            SetButtonPanelVisiblity();
                                        }));
                                    }
                                }
                            }
                            */

                            hasRanOnceFirstCycle = true;
                        }
                    }
                }
            }

            return hasRanOnceFirstCycle;
        }

        private void OnAccountStatusUpdate(object sender, AccountStatusEventArgs e)
        {

            // Output the account name and status

            //NinjaTrader.Code.Output.Process(string.Format("OnAccountStatusUpdate - Account: {0} Status: {1}", e.Account.Name, e.Status), PrintTo.OutputTab1);

        }

        private void OnAccountItemUpdate(object sender, AccountItemEventArgs e)

        {

            // Output the account item

            //NinjaTrader.Code.Output.Process(string.Format("OnAccountItemUpdate - Account: {0} AccountItem: {1} Value: {2}", e.Account.Name, e.AccountItem, e.Value), PrintTo.OutputTab1);

        }

        private void OnExecutionUpdate(object sender, ExecutionEventArgs e)
        {
            string signalName = "OnExecutionUpdate";
            /*
            lastExecutionUpdatePrice = 0;

            if (e != null)
            {
                lastExecutionUpdatePrice = e.Execution.Price;
            }
            */

            // Output the execution

            //Print("OnExecutionUpdate - OrderId=" + Convert.ToString(e.OrderId) + " ExecId=" + Convert.ToString(e.ExecutionId) + " quanity=" + Convert.ToString(e.Quantity) + " price=" + e.Execution.Price + " op=" + e.Operation + " name=" + e.Execution.Name + " mp=" + e.MarketPosition + " e.instra=" + e.Execution.Instrument.FullName);
            //NinjaTrader.Code.Output.Process(string.Format("Instrument: {0} Quantity: {1} Price: {2}", e.Execution.Instrument.FullName, e.Quantity, e.Price), PrintTo.OutputTab1);


            //if (entryOrder != null && execution.Order == entryOrder)
            //{
            //    string ocoString = "ocoString";
            //    profitTarget = SubmitOrderUnmanaged(1, OrderAction.Sell, OrderType.StopMarket, e.Execution.Order.Filled, e.Execution.Order.AverageFillPrice + 60, 0, ocoString, "profit target");
            //}

            try
            {
                //Print("OnExecutionUpdate running RealTimePipeline");
                Dispatcher.InvokeAsync(() =>
                {
                    if (hasRanOnceFirstCycle)
                    {
                        try
                        {
                            lock (ThreadManagerLock)
                            {
                                //RealLogger.PrintOutput("OnExecutionUpdate - UseHordeTradeCopier: " + UseHordeTradeCopier.ToString() + " hasFollowerAccounts: " + hasFollowerAccounts.ToString(), PrintTo.OutputTab1);
                                if (UseHordeTradeCopier && hasFollowerAccounts && IsTickHunterActivated())
                                {
                                    Execution execution = e.Execution;
                                    //RealLogger.PrintOutput("OnExecutionUpdate - Execution: " + execution.Order.OrderState.ToString() + " from " + execution.Account.DisplayName + " for " + execution.Instrument.FullName + " on " + execution.Order.OrderType.ToString() + " for " + execution.Quantity.ToString() + " units" + " at " + execution.Order.OrderState.ToString(), PrintTo.OutputTab1);

                                    // Only react to executions from the MASTER account
                                    if (execution.Order.OrderState == OrderState.Filled || execution.Order.OrderState == OrderState.PartFilled)
                                    {
                                        //RealLogger.PrintOutput("OnExecutionUpdate - Execution: " + execution.Order.OrderState.ToString() + " from " + execution.Account.DisplayName + " for " + execution.Instrument.FullName, PrintTo.OutputTab1);

                                        // Only process actual fills (full or partial)
                                        if (execution.Order.OrderState == OrderState.Filled || execution.Order.OrderState == OrderState.PartFilled)
                                        {
                                            //RealLogger.PrintOutput("OnExecutionUpdate X - Execution: " + execution.Order.OrderState.ToString() + " from " + execution.Account.DisplayName + " for " + execution.Instrument.FullName, PrintTo.OutputTab1);
                                            // Quantity filled THIS time (handles partials correctly)
                                            int fillQty       = execution.Quantity;
                                            OrderAction action = execution.Order.OrderAction;
                                            Instrument instrument = execution.Instrument;
                                            
                                            // Cache leader instrument E-mini check for performance
                                            bool leaderIsEmini = IsEminiInstrument(instrument);

                                            // Performance optimization: iterate only through active follower accounts instead of all 24 indexes
                                            // Use index-based loop to avoid issues if list changes during iteration
                                            for (int i = 0; i < activeFollowerAccounts.Count; i++)
                                            {
                                                var followerInfo = activeFollowerAccounts[i];
                                                if (followerInfo.Account == null)
                                                    continue;

                                                try
                                                {
                                                    // Use cached parsed values (parsed once during LoadAccount, not on every execution)
                                                    int multiplier = followerInfo.Multiplier;
                                                    bool crossToEmini = followerInfo.CrossToEmini;
                                                    
                                                    // Calculate quantity
                                                    int calculatedQty = fillQty * multiplier;
                                                    
                                                    // Determine target instrument (optimized: skip check if leader is E-mini)
                                                    Instrument targetInstrument = leaderIsEmini ? instrument : GetTargetInstrument(instrument, crossToEmini, followerInfo.Account);
                                                    
                                                    Order mirrorOrder = followerInfo.Account.CreateOrder(
                                                        targetInstrument,
                                                        action,
                                                        OrderType.Market,
                                                        OrderEntry.Automated,
                                                        TimeInForce.Day,
                                                        calculatedQty,
                                                        0, 0, "",
                                                        "TH-Horde_" + Guid.NewGuid().ToString(),
                                                        Core.Globals.MaxDate,
                                                        null);

                                                    followerInfo.Account.Submit(new Order[] { mirrorOrder });
                                                }
                                                catch (Exception ex)
                                                {
                                                    string accountName = "Unknown";
                                                    if (followerInfo != null && followerInfo.Account != null && followerInfo.Account.DisplayName != null)
                                                    {
                                                        accountName = followerInfo.Account.DisplayName;
                                                    }
                                                    int accountIndex = followerInfo != null ? followerInfo.Index : -1;
                                                    RealLogger.PrintOutput("Exception in OnExecutionUpdate Mirror for follower account " + accountName + " (index " + accountIndex + "): " + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                                }
                                            }
                                            
                                        }
                                    }
                                }

                                TriggerCustomEvent(o =>
                                {
                                    RealTimePipeline();
                                }, null);
                            }
                        }
                        catch (Exception ex)
                        {
                            //log and stuff exception
                            RealLogger.PrintOutput("Exception calling OnExecutionUpdate Dispatcher.InvokeAsync:" + ex.Message + " " + ex.StackTrace);
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                //log and stuff exception
                RealLogger.PrintOutput("Exception calling OnExecutionUpdate:" + ex.Message + " " + ex.StackTrace);
            }
        }

        private void OnExecutionUpdateHorde(object sender, ExecutionEventArgs e)
        {
            string signalName = "OnExecutionUpdateHorde";

            try
            {
                Dispatcher.InvokeAsync(() =>
                {
                    try
                    {
                        Execution execution = e.Execution;
                        Account execAccount = execution.Account;
                        
                        // Only track fills from follower accounts
                        // Performance optimization: check only active follower accounts instead of all 24
                        if (execAccount == null)
                        {
                            return;
                        }
                        bool isFollowerAccount = false;
                        for (int i = 0; i < activeFollowerAccounts.Count; i++)
                        {
                            if (activeFollowerAccounts[i].Account == execAccount)
                            {
                                isFollowerAccount = true;
                                break;
                            }
                        }
                        if (!isFollowerAccount)
                        {
                            return;
                        }

                        // Only track actual fills
                        if (execution.Order.OrderState == OrderState.Filled || execution.Order.OrderState == OrderState.PartFilled)
                        {
                            Instrument instrument = execution.Instrument;
                            int fillQty = execution.Quantity;
                            OrderAction action = execution.Order.OrderAction;
                            
                            // Determine position change: Buy increases position, Sell decreases position
                            int positionChange = 0;
                            if (action == OrderAction.Buy || action == OrderAction.BuyToCover)
                            {
                                positionChange = fillQty;
                            }
                            else if (action == OrderAction.Sell || action == OrderAction.SellShort)
                            {
                                positionChange = -fillQty;
                            }

                            if (positionChange != 0)
                            {
                                lock (hordeAccountPositions)
                                {
                                    // Initialize account dictionary if needed
                                    if (!hordeAccountPositions.ContainsKey(execAccount))
                                    {
                                        hordeAccountPositions[execAccount] = new Dictionary<Instrument, int>();
                                    }

                                    // Initialize instrument position if needed
                                    if (!hordeAccountPositions[execAccount].ContainsKey(instrument))
                                    {
                                        hordeAccountPositions[execAccount][instrument] = 0;
                                    }

                                    // Update position count for this account/instrument
                                    int oldPosition = hordeAccountPositions[execAccount][instrument];
                                    int newPosition = oldPosition + positionChange;
                                    hordeAccountPositions[execAccount][instrument] = newPosition;

                                    // Update total horde position count
                                    // Only count positions that are non-zero (have open positions)
                                    if (oldPosition == 0 && newPosition != 0)
                                    {
                                        // New position opened
                                        totalHordePositionCount++;
                                    }
                                    else if (oldPosition != 0 && newPosition == 0)
                                    {
                                        // Position closed
                                        totalHordePositionCount--;
                                    }
                                    // If both old and new are non-zero, the count doesn't change (position modified but still open)

                                    // Clean up zero positions to keep dictionary clean
                                    if (newPosition == 0)
                                    {
                                        hordeAccountPositions[execAccount].Remove(instrument);
                                        if (hordeAccountPositions[execAccount].Count == 0)
                                        {
                                            hordeAccountPositions.Remove(execAccount);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        RealLogger.PrintOutput("Exception in OnExecutionUpdateHorde tracking:" + ex.Message + " " + ex.StackTrace);
                    }
                });
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling OnExecutionUpdateHorde:" + ex.Message + " " + ex.StackTrace);
            }
        }
        
        private void OnPositionUpdate(object sender, PositionEventArgs e)
        {
            string signalName = "OnPositionUpdate";

            //NinjaTrader.Code.Output.Process(string.Format("OnPositionUpdate - Instrument: {0} MarketPosition: {1} AveragePrice: {2} Quantity: {3} Operation: {4}", e.Position.Instrument.FullName, e.MarketPosition, e.AveragePrice, e.Quantity, e.Operation), PrintTo.OutputTab1);

            if (e != null && e.Position != null && e.Position.Instrument != null)
            {
                RealLogger.PrintOutput(string.Format("OnPositionUpdate - Instrument: {0} - MarketPosition: {1} - AveragePrice: {2} - Quantity: {3} - Operation: {4}", e.Position.Instrument.FullName, e.MarketPosition, e.AveragePrice, e.Quantity, e.Operation));
                //Print("*** DEBUG e.AveragePrice=" + e.AveragePrice + " pos.ap=" + e.Position.AveragePrice + " exp=" + lastExecutionPrice);

                RealPosition updatedPosition = RealPositionService.BuildRealPosition(e.Position.Account, e.Position.Instrument, e.MarketPosition, e.Quantity, e.AveragePrice, GetDateTimeNow());

                if (e.Operation == Operation.Add)
                {
                    RealPositionService.AddPosition(updatedPosition);
                }
                else if (e.Operation == Operation.Update)
                {
                    RealPositionService.UpdatePosition(updatedPosition);
                }
                else if (e.Operation == Operation.Remove)
                {
                    RealPositionService.RemovePosition(updatedPosition);
                }



                /*
                 RealPosition foundPosition = null;
                if (RealPositionService.TryGetByInstrumentFullName(e.Position.Instrument.FullName, out foundPosition))
                {
                    bool arePositionCountsInSync = (e.Quantity == foundPosition.Quantity);

                    if (!arePositionCountsInSync)
                    {
                        RealLogger.PrintOutput("*** ERROR: Position quantity counts out of sync internalQuantityCount=" + foundPosition.Quantity + " vs  actualQuantityCount=" + e.Quantity + " via " + signalName);
                    }
                }
                else if (e.Quantity != 0)
                {
                    RealLogger.PrintOutput("*** ERROR: Position quantity counts out of sync internalQuantityCount=0 vs actualQuantityCount=" + e.Quantity + " via " + signalName);
                }
                */

                bool isInstrumentFlat = (e.MarketPosition == MarketPosition.Flat);

                if (isInstrumentFlat)
                {
                    PositionCloseCleanUp(e.Position.Instrument);
                }


                bool isAttachedInstrument = (e.Position.Instrument == attachedInstrument);
                bool isBlendedInstrument = IsBlendedInstrumentEnabled() && (e.Position.Instrument == blendedInstrument);

                if (isAttachedInstrument || isBlendedInstrument)
                {
                    if (!isInstrumentFlat)
                    {
                        // Only convert Stage1 flags to actual flags if position/order sync is needed
                        // Check if position and stop loss/take profit are already in sync
                        RealPosition foundPosition = null;
                        if (RealPositionService.TryGetByInstrumentFullName(e.Position.Instrument.FullName, out foundPosition))
                        {
                            OrderType orderType;
                            int stopLossOrderQuantity = 0;
                            int takeProfitOrderQuantity = 0;
                            int stopLossOrderCount = 0;
                            int takeProfitOrderCount = 0;

                            RealOrderService.GetStopLossInfo(e.Position.Account, e.Position.Instrument, ConvertMarketPositionToSLOrderAction(e.Position.MarketPosition), out orderType, out stopLossOrderQuantity, out stopLossOrderCount);
                            RealOrderService.GetTakeProfitInfo(e.Position.Account, e.Position.Instrument, ConvertMarketPositionToTPOrderAction(e.Position.MarketPosition), out orderType, out takeProfitOrderQuantity, out takeProfitOrderCount);

                            // Stop loss and take profit should always match position quantity when they exist
                            // If quantity is 0, no order exists (either not required by settings or not created yet - both are okay)
                            // If quantity > 0, an order exists and MUST equal position quantity to be in sync
                            bool stopLossInSync = (stopLossOrderQuantity == 0 || stopLossOrderQuantity == foundPosition.Quantity);
                            bool takeProfitInSync = (takeProfitOrderQuantity == 0 || takeProfitOrderQuantity == foundPosition.Quantity);

                            // If position was updated via OnPositionUpdate, we know it's synced with the broker
                            // So it's safe to adjust orders even if the other order is still filling (PartFilled)
                            // The key is: OnPositionUpdate has already updated the position, so we know the current state
                            // Example: Stop loss partially fills 1 of 2 contracts  OnPositionUpdate fires with position = 1
                            //  Take profit still shows 2 contracts  needs adjustment to 1 (not a timing issue)

                            if (validateAttachedPositionStopLossQuantityStage1)
                            {
                                // Set validation flag if there's a mismatch
                                // It's safe because OnPositionUpdate has already synced the position
                                if (!stopLossInSync)
                                {
                                    validateAttachedPositionStopLossQuantity = true;
                                }
                                validateAttachedPositionStopLossQuantityStage1 = false;
                            }

                            if (validateAttachedPositionTakeProfitQuantityStage1)
                            {
                                // Set validation flag if there's a mismatch
                                // It's safe because OnPositionUpdate has already synced the position
                                if (!takeProfitInSync)
                                {
                                    validateAttachedPositionTakeProfitQuantity = true;
                                }
                                validateAttachedPositionTakeProfitQuantityStage1 = false;
                            }

                            if (validateBlendedPositionStopLossQuantityStage1)
                            {
                                if (!stopLossInSync)
                                {
                                    validateBlendedPositionStopLossQuantity = true;
                                }
                                validateBlendedPositionStopLossQuantityStage1 = false;
                            }

                            if (validateBlendedPositionTakeProfitQuantityStage1)
                            {
                                if (!takeProfitInSync)
                                {
                                    validateBlendedPositionTakeProfitQuantity = true;
                                }
                                validateBlendedPositionTakeProfitQuantityStage1 = false;
                            }
                        }
                        else
                        {
                            // Fallback: convert flags if position not found (shouldn't happen normally)
                            if (validateAttachedPositionStopLossQuantityStage1)
                            {
                                validateAttachedPositionStopLossQuantity = true;
                                validateAttachedPositionStopLossQuantityStage1 = false;
                            }

                            if (validateAttachedPositionTakeProfitQuantityStage1)
                            {
                                validateAttachedPositionTakeProfitQuantity = true;
                                validateAttachedPositionTakeProfitQuantityStage1 = false;
                            }

                            if (validateBlendedPositionStopLossQuantityStage1)
                            {
                                validateBlendedPositionStopLossQuantity = true;
                                validateBlendedPositionStopLossQuantityStage1 = false;
                            }

                            if (validateBlendedPositionTakeProfitQuantityStage1)
                            {
                                validateBlendedPositionTakeProfitQuantity = true;
                                validateBlendedPositionTakeProfitQuantityStage1 = false;
                            }
                        }
                    }
                }
            }
        }

        private void PositionCloseCleanUp(Instrument instrument)
        {
            string signalName = "PositionCloseCleanUp";

            if (instrument == attachedInstrument)
            {
                CancelPositionTPSLOrders("TPSLRefresh-All", attachedInstrument);

                ExitCloseAlertWindows();

                if (attachedInstrumentHasPosition && ChartControl != null)
                {
                    if (ChartControl.Dispatcher.CheckAccess())
                    {
                        DeactivatePopDelayedEntryFeatures(signalName);
                    }
                    else
                    {
                        ChartControl.Dispatcher.InvokeAsync(() =>
                        {
                            DeactivatePopDelayedEntryFeatures(signalName);
                        });
                    }
                }

                attachedInstrumentHasPosition = false;
                attachedInstrumentPositionBarCount = 0;
                attachedInstrumentPositionCreeperCycleCount = 0;
                attachedInstrumentPositionCreeperSurging = false;
                attachedInstrumentPositionCreeperGushing1 = false;
                attachedInstrumentPositionFlowing1 = false;
                attachedInstrumentPositionFlowing2 = false;
                attachedInstrumentPositionFlowing3 = false;
                attachedInstrumentPositionFlowing4 = false;
                attachedInstrumentMarketPosition = MarketPosition.Flat;
                attachedInstrumentPositionPrice = 0;
                attachedInstrumentPositionQuantity = 0;
                attachedInstrumentPositionStopLossPrice = 0;
                attachedInstrumentPositionTakeProfitPrice = 0;
                attachedInstrumentPositionPnL = 0;
                attachedInstrumentHasChanged = true;

                riskInfoHasChanged = true;

                profitInfoHasChanged = true;

                dayOverMaxLossHasChanged = true;

                bogeyTargetHasChanged = true;

                dayOverAccountBalanceFloorHasChanged = true;

                ecaTakeProfitHasChanged = true;

                averagePriceHasChanged = true;

                lastFlattenEverythingCycleChangeTime = DateTime.MinValue;

                lastTakeProfitLogThrottleSeconds = 0;
                nextTakeProfitThrottleSeconds = 0;
                lastTakeProfitThrottleChangeTime = DateTime.MinValue;
                lastTakeProfitMismatchContracts = 0;

                lastStopLossLogThrottleSeconds = 0;
                nextStopLossThrottleSeconds = 0;
                lastStopLossThrottleChangeTime = DateTime.MinValue;
            }
            else if (IsBlendedInstrumentEnabled() && instrument == blendedInstrument)
            {
                CancelPositionTPSLOrders("TPSLRefresh-All", blendedInstrument);

                ExitCloseAlertWindows();

                if (blendedInstrumentHasPosition && ChartControl != null)
                {
                    if (ChartControl.Dispatcher.CheckAccess())
                    {
                        DeactivatePopDelayedEntryFeatures(signalName);
                    }
                    else
                    {
                        ChartControl.Dispatcher.InvokeAsync(() =>
                        {
                            DeactivatePopDelayedEntryFeatures(signalName);
                        });
                    }
                }

                blendedInstrumentHasPosition = false;
                blendedInstrumentPositionCreeperCycleCount = 0;
                blendedInstrumentPositionCreeperSurging = false;
                blendedInstrumentMarketPosition = MarketPosition.Flat;
                blendedInstrumentPositionPrice = 0;
                blendedInstrumentPositionQuantity = 0;
                blendedInstrumentPositionStopLossPrice = 0;
                blendedInstrumentPositionTakeProfitPrice = 0;
                blendedInstrumentHasChanged = true;

                bogeyTargetHasChanged = true;

                ecaTakeProfitHasChanged = true;

                averagePriceHasChanged = true;

                lastFlattenEverythingCycleChangeTime = DateTime.MinValue;

                lastTakeProfitBlendLogThrottleSeconds = 0;
                nextTakeProfitBlendThrottleSeconds = 0;
                lastTakeProfitBlendThrottleChangeTime = DateTime.MinValue;
                lastTakeProfitBlendMismatchContracts = 0;

                lastStopLossBlendLogThrottleSeconds = 0;
                nextStopLossBlendThrottleSeconds = 0;
                lastStopLossBlendThrottleChangeTime = DateTime.MinValue;
            }

        }

        private string GetATMStrategy()
        {
            string tempATMStrategyName = null;

            try
            {
                AtmStrategy atmStrategy = this.ChartControl.OwnerChart.ChartTrader.AtmStrategy;
                if (atmStrategy != null)
                {
                    tempATMStrategyName = atmStrategy.Template + "";
                }
            }
            catch (Exception ex)
            {
                //stuff exception
            }

            return tempATMStrategyName;
        }

        private void LoadATMStrategy(string newATMStrategyName = "")
        {
            //lock (account)
            {
                string tempATMStrategyName = newATMStrategyName;

                if (tempATMStrategyName == string.Empty)
                {
                    tempATMStrategyName = GetATMStrategy();
                }
                else
                {
                    tempATMStrategyName = newATMStrategyName;
                }

                if (tempATMStrategyName != atmStrategyName)
                {
                    atmStrategyName = tempATMStrategyName;

                    string displayATMStrategyName = (string.IsNullOrEmpty(atmStrategyName)) ? "None" : atmStrategyName;

                    RealLogger.PrintOutput("Found ATM strategy name (" + displayATMStrategyName + ")", PrintTo.OutputTab1);
                    RealLogger.PrintOutput("Found ATM strategy name (" + displayATMStrategyName + ")", PrintTo.OutputTab2);
                }
            }
        }

        private Account GetAccount()
        {
            Account tempAccount = null;

            try
            {
                tempAccount = this.ChartControl.OwnerChart.ChartTrader.Account;
            }
            catch
            {
                //stuff exception
            }

            return tempAccount;
        }

        private void LoadAccount(Account newAccount = null)
        {
            string signalName = "LoadAccount";

            lock (AccountLock)
            {
                Account tempAccount = newAccount;

                if (newAccount == null)
                {
                    tempAccount = GetAccount();
                }
                else
                {
                    tempAccount = newAccount;
                }

                if (tempAccount != null && tempAccount != account)
                {
                    if (account != null) UnloadAccountEvents(signalName);

                    account = tempAccount;

                    RealLogger.PrintOutput("Found account name (" + Convert.ToString(account.DisplayName) + ")", PrintTo.OutputTab1);
                    RealLogger.PrintOutput("Found account name (" + Convert.ToString(account.DisplayName) + ")", PrintTo.OutputTab2);


                    SubscribeToOrderUpdate(account);
                    SubscribeToExecutionUpdate(account);
                    SubscribeToPositionUpdate(account);

                    if (UseHordeTradeCopier && account != null && account.Connection != null)
                    {
                        this.followerAccount1 = null;
                        this.followerAccount2 = null;
                        this.followerAccount3 = null;
                        this.followerAccount4 = null;
                        this.followerAccount5 = null;
                        this.followerAccount6 = null;
                        this.followerAccount7 = null;
                        this.followerAccount8 = null;
                        this.followerAccount9 = null;
                        this.followerAccount10 = null;
                        this.followerAccount11 = null;
                        this.followerAccount12 = null;
                        this.followerAccount13 = null;
                        this.followerAccount14 = null;
                        this.followerAccount15 = null;
                        this.followerAccount16 = null;
                        this.followerAccount17 = null;
                        this.followerAccount18 = null;
                        this.followerAccount19 = null;
                        this.followerAccount20 = null;
                        this.followerAccount21 = null;
                        this.followerAccount22 = null;
                        this.followerAccount23 = null;
                        this.followerAccount24 = null;

                        hasFollowerAccounts = false;
                        foreach (Account acc in Account.All)
                        {
                            // Skip if account is null or connection not connected
                            if (acc == null || acc.ConnectionStatus != ConnectionStatus.Connected)
                                continue;

                            if (!string.IsNullOrEmpty(FollowerAccount1) && acc.DisplayName == FollowerAccount1 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount1 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount2) && acc.DisplayName == FollowerAccount2 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount2 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount3) && acc.DisplayName == FollowerAccount3 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount3 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount4) && acc.DisplayName == FollowerAccount4 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount4 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount5) && acc.DisplayName == FollowerAccount5 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount5 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount6) && acc.DisplayName == FollowerAccount6 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount6 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount7) && acc.DisplayName == FollowerAccount7 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount7 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount8) && acc.DisplayName == FollowerAccount8 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount8 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount9) && acc.DisplayName == FollowerAccount9 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount9 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount10) && acc.DisplayName == FollowerAccount10 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount10 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount11) && acc.DisplayName == FollowerAccount11 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount11 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount12) && acc.DisplayName == FollowerAccount12 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount12 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount13) && acc.DisplayName == FollowerAccount13 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount13 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount14) && acc.DisplayName == FollowerAccount14 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount14 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount15) && acc.DisplayName == FollowerAccount15 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount15 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount16) && acc.DisplayName == FollowerAccount16 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount16 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount17) && acc.DisplayName == FollowerAccount17 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount17 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount18) && acc.DisplayName == FollowerAccount18 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount18 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount19) && acc.DisplayName == FollowerAccount19 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount19 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount20) && acc.DisplayName == FollowerAccount20 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount20 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount21) && acc.DisplayName == FollowerAccount21 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount21 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount22) && acc.DisplayName == FollowerAccount22 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount22 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount23) && acc.DisplayName == FollowerAccount23 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount23 = acc;
                                hasFollowerAccounts = true;
                            }
                            if (!string.IsNullOrEmpty(FollowerAccount24) && acc.DisplayName == FollowerAccount24 && acc.DisplayName != account.DisplayName)
                            {
                                this.followerAccount24 = acc;
                                hasFollowerAccounts = true;
                            }
                        }

                        var followers = new[] 
                        { 
                            this.followerAccount1, this.followerAccount2, this.followerAccount3, 
                            this.followerAccount4, this.followerAccount5, this.followerAccount6,
                            this.followerAccount7, this.followerAccount8, this.followerAccount9,
                            this.followerAccount10, this.followerAccount11, this.followerAccount12,
                            this.followerAccount13, this.followerAccount14, this.followerAccount15,
                            this.followerAccount16, this.followerAccount17, this.followerAccount18,
                            this.followerAccount19, this.followerAccount20, this.followerAccount21,
                            this.followerAccount22, this.followerAccount23, this.followerAccount24
                        };

                        var uniqueFollowers = followers.Distinct().ToArray();

                        this.followerAccount1 = uniqueFollowers.Length > 0 ? uniqueFollowers[0] : null;
                        this.followerAccount2 = uniqueFollowers.Length > 1 ? uniqueFollowers[1] : null;
                        this.followerAccount3 = uniqueFollowers.Length > 2 ? uniqueFollowers[2] : null;
                        this.followerAccount4 = uniqueFollowers.Length > 3 ? uniqueFollowers[3] : null;
                        this.followerAccount5 = uniqueFollowers.Length > 4 ? uniqueFollowers[4] : null;
                        this.followerAccount6 = uniqueFollowers.Length > 5 ? uniqueFollowers[5] : null;
                        this.followerAccount7 = uniqueFollowers.Length > 6 ? uniqueFollowers[6] : null;
                        this.followerAccount8 = uniqueFollowers.Length > 7 ? uniqueFollowers[7] : null;
                        this.followerAccount9 = uniqueFollowers.Length > 8 ? uniqueFollowers[8] : null;
                        this.followerAccount10 = uniqueFollowers.Length > 9 ? uniqueFollowers[9] : null;
                        this.followerAccount11 = uniqueFollowers.Length > 10 ? uniqueFollowers[10] : null;
                        this.followerAccount12 = uniqueFollowers.Length > 11 ? uniqueFollowers[11] : null;
                        this.followerAccount13 = uniqueFollowers.Length > 12 ? uniqueFollowers[12] : null;
                        this.followerAccount14 = uniqueFollowers.Length > 13 ? uniqueFollowers[13] : null;
                        this.followerAccount15 = uniqueFollowers.Length > 14 ? uniqueFollowers[14] : null;
                        this.followerAccount16 = uniqueFollowers.Length > 15 ? uniqueFollowers[15] : null;
                        this.followerAccount17 = uniqueFollowers.Length > 16 ? uniqueFollowers[16] : null;
                        this.followerAccount18 = uniqueFollowers.Length > 17 ? uniqueFollowers[17] : null;
                        this.followerAccount19 = uniqueFollowers.Length > 18 ? uniqueFollowers[18] : null;
                        this.followerAccount20 = uniqueFollowers.Length > 19 ? uniqueFollowers[19] : null;
                        this.followerAccount21 = uniqueFollowers.Length > 20 ? uniqueFollowers[20] : null;
                        this.followerAccount22 = uniqueFollowers.Length > 21 ? uniqueFollowers[21] : null;
                        this.followerAccount23 = uniqueFollowers.Length > 22 ? uniqueFollowers[22] : null;
                        this.followerAccount24 = uniqueFollowers.Length > 23 ? uniqueFollowers[23] : null;

                        // Parse and cache TradeSize values once during account load (performance optimization)
                        // This avoids parsing on every execution update
                        string tradeSize1 = GetFollowerTradeSize(1);
                        follower1Multiplier = ParseTradeSizeMultiplier(tradeSize1);
                        follower1CrossToEmini = IsCrossToEmini(tradeSize1);
                        
                        string tradeSize2 = GetFollowerTradeSize(2);
                        follower2Multiplier = ParseTradeSizeMultiplier(tradeSize2);
                        follower2CrossToEmini = IsCrossToEmini(tradeSize2);
                        
                        string tradeSize3 = GetFollowerTradeSize(3);
                        follower3Multiplier = ParseTradeSizeMultiplier(tradeSize3);
                        follower3CrossToEmini = IsCrossToEmini(tradeSize3);
                        
                        string tradeSize4 = GetFollowerTradeSize(4);
                        follower4Multiplier = ParseTradeSizeMultiplier(tradeSize4);
                        follower4CrossToEmini = IsCrossToEmini(tradeSize4);
                        
                        string tradeSize5 = GetFollowerTradeSize(5);
                        follower5Multiplier = ParseTradeSizeMultiplier(tradeSize5);
                        follower5CrossToEmini = IsCrossToEmini(tradeSize5);
                        
                        string tradeSize6 = GetFollowerTradeSize(6);
                        follower6Multiplier = ParseTradeSizeMultiplier(tradeSize6);
                        follower6CrossToEmini = IsCrossToEmini(tradeSize6);
                        
                        string tradeSize7 = GetFollowerTradeSize(7);
                        follower7Multiplier = ParseTradeSizeMultiplier(tradeSize7);
                        follower7CrossToEmini = IsCrossToEmini(tradeSize7);
                        
                        string tradeSize8 = GetFollowerTradeSize(8);
                        follower8Multiplier = ParseTradeSizeMultiplier(tradeSize8);
                        follower8CrossToEmini = IsCrossToEmini(tradeSize8);
                        
                        string tradeSize9 = GetFollowerTradeSize(9);
                        follower9Multiplier = ParseTradeSizeMultiplier(tradeSize9);
                        follower9CrossToEmini = IsCrossToEmini(tradeSize9);

                        string tradeSize10 = GetFollowerTradeSize(10);
                        follower10Multiplier = ParseTradeSizeMultiplier(tradeSize10);
                        follower10CrossToEmini = IsCrossToEmini(tradeSize10);

                        string tradeSize11 = GetFollowerTradeSize(11);
                        follower11Multiplier = ParseTradeSizeMultiplier(tradeSize11);
                        follower11CrossToEmini = IsCrossToEmini(tradeSize11);

                        string tradeSize12 = GetFollowerTradeSize(12);
                        follower12Multiplier = ParseTradeSizeMultiplier(tradeSize12);
                        follower12CrossToEmini = IsCrossToEmini(tradeSize12);

                        string tradeSize13 = GetFollowerTradeSize(13);
                        follower13Multiplier = ParseTradeSizeMultiplier(tradeSize13);
                        follower13CrossToEmini = IsCrossToEmini(tradeSize13);

                        string tradeSize14 = GetFollowerTradeSize(14);
                        follower14Multiplier = ParseTradeSizeMultiplier(tradeSize14);
                        follower14CrossToEmini = IsCrossToEmini(tradeSize14);

                        string tradeSize15 = GetFollowerTradeSize(15);
                        follower15Multiplier = ParseTradeSizeMultiplier(tradeSize15);
                        follower15CrossToEmini = IsCrossToEmini(tradeSize15);

                        string tradeSize16 = GetFollowerTradeSize(16);
                        follower16Multiplier = ParseTradeSizeMultiplier(tradeSize16);
                        follower16CrossToEmini = IsCrossToEmini(tradeSize16);

                        string tradeSize17 = GetFollowerTradeSize(17);
                        follower17Multiplier = ParseTradeSizeMultiplier(tradeSize17);
                        follower17CrossToEmini = IsCrossToEmini(tradeSize17);

                        string tradeSize18 = GetFollowerTradeSize(18);
                        follower18Multiplier = ParseTradeSizeMultiplier(tradeSize18);
                        follower18CrossToEmini = IsCrossToEmini(tradeSize18);

                        string tradeSize19 = GetFollowerTradeSize(19);
                        follower19Multiplier = ParseTradeSizeMultiplier(tradeSize19);
                        follower19CrossToEmini = IsCrossToEmini(tradeSize19);

                        string tradeSize20 = GetFollowerTradeSize(20);
                        follower20Multiplier = ParseTradeSizeMultiplier(tradeSize20);
                        follower20CrossToEmini = IsCrossToEmini(tradeSize20);

                        string tradeSize21 = GetFollowerTradeSize(21);
                        follower21Multiplier = ParseTradeSizeMultiplier(tradeSize21);
                        follower21CrossToEmini = IsCrossToEmini(tradeSize21);

                        string tradeSize22 = GetFollowerTradeSize(22);
                        follower22Multiplier = ParseTradeSizeMultiplier(tradeSize22);
                        follower22CrossToEmini = IsCrossToEmini(tradeSize22);

                        string tradeSize23 = GetFollowerTradeSize(23);
                        follower23Multiplier = ParseTradeSizeMultiplier(tradeSize23);
                        follower23CrossToEmini = IsCrossToEmini(tradeSize23);

                        string tradeSize24 = GetFollowerTradeSize(24);
                        follower24Multiplier = ParseTradeSizeMultiplier(tradeSize24);
                        follower24CrossToEmini = IsCrossToEmini(tradeSize24);

                        // Build list of active follower accounts for performance optimization
                        // This avoids looping through all 24 indexes when only a few accounts are configured
                        activeFollowerAccounts.Clear();
                        
                        Action<Account, int, int, bool> addFollowerIfNotNull = (acc, idx, mult, cross) =>
                        {
                            if (acc != null)
                            {
                                activeFollowerAccounts.Add(new FollowerAccountInfo
                                {
                                    Account = acc,
                                    Index = idx,
                                    Multiplier = mult,
                                    CrossToEmini = cross
                                });
                            }
                        };
                        
                        addFollowerIfNotNull(followerAccount1, 1, follower1Multiplier, follower1CrossToEmini);
                        addFollowerIfNotNull(followerAccount2, 2, follower2Multiplier, follower2CrossToEmini);
                        addFollowerIfNotNull(followerAccount3, 3, follower3Multiplier, follower3CrossToEmini);
                        addFollowerIfNotNull(followerAccount4, 4, follower4Multiplier, follower4CrossToEmini);
                        addFollowerIfNotNull(followerAccount5, 5, follower5Multiplier, follower5CrossToEmini);
                        addFollowerIfNotNull(followerAccount6, 6, follower6Multiplier, follower6CrossToEmini);
                        addFollowerIfNotNull(followerAccount7, 7, follower7Multiplier, follower7CrossToEmini);
                        addFollowerIfNotNull(followerAccount8, 8, follower8Multiplier, follower8CrossToEmini);
                        addFollowerIfNotNull(followerAccount9, 9, follower9Multiplier, follower9CrossToEmini);
                        addFollowerIfNotNull(followerAccount10, 10, follower10Multiplier, follower10CrossToEmini);
                        addFollowerIfNotNull(followerAccount11, 11, follower11Multiplier, follower11CrossToEmini);
                        addFollowerIfNotNull(followerAccount12, 12, follower12Multiplier, follower12CrossToEmini);
                        addFollowerIfNotNull(followerAccount13, 13, follower13Multiplier, follower13CrossToEmini);
                        addFollowerIfNotNull(followerAccount14, 14, follower14Multiplier, follower14CrossToEmini);
                        addFollowerIfNotNull(followerAccount15, 15, follower15Multiplier, follower15CrossToEmini);
                        addFollowerIfNotNull(followerAccount16, 16, follower16Multiplier, follower16CrossToEmini);
                        addFollowerIfNotNull(followerAccount17, 17, follower17Multiplier, follower17CrossToEmini);
                        addFollowerIfNotNull(followerAccount18, 18, follower18Multiplier, follower18CrossToEmini);
                        addFollowerIfNotNull(followerAccount19, 19, follower19Multiplier, follower19CrossToEmini);
                        addFollowerIfNotNull(followerAccount20, 20, follower20Multiplier, follower20CrossToEmini);
                        addFollowerIfNotNull(followerAccount21, 21, follower21Multiplier, follower21CrossToEmini);
                        addFollowerIfNotNull(followerAccount22, 22, follower22Multiplier, follower22CrossToEmini);
                        addFollowerIfNotNull(followerAccount23, 23, follower23Multiplier, follower23CrossToEmini);
                        addFollowerIfNotNull(followerAccount24, 24, follower24Multiplier, follower24CrossToEmini);

                        string defaultTradeSizeDisplay = TickHunterFollowerTradeSizeValueConverter.GetDefaultDisplayValue();
                        
                        if (this.followerAccount1 != null)
                        {
                            string tradeSizeDisplay1 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(1));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount1.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay1) ? defaultTradeSizeDisplay : tradeSizeDisplay1), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount2 != null)
                        {
                            string tradeSizeDisplay2 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(2));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount2.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay2) ? defaultTradeSizeDisplay : tradeSizeDisplay2), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount3 != null)
                        {
                            string tradeSizeDisplay3 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(3));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount3.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay3) ? defaultTradeSizeDisplay : tradeSizeDisplay3), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount4 != null)
                        {
                            string tradeSizeDisplay4 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(4));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount4.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay4) ? defaultTradeSizeDisplay : tradeSizeDisplay4), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount5 != null)
                        {
                            string tradeSizeDisplay5 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(5));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount5.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay5) ? defaultTradeSizeDisplay : tradeSizeDisplay5), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount6 != null)
                        {
                            string tradeSizeDisplay6 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(6));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount6.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay6) ? defaultTradeSizeDisplay : tradeSizeDisplay6), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount7 != null)
                        {
                            string tradeSizeDisplay7 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(7));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount7.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay7) ? defaultTradeSizeDisplay : tradeSizeDisplay7), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount8 != null)
                        {
                            string tradeSizeDisplay8 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(8));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount8.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay8) ? defaultTradeSizeDisplay : tradeSizeDisplay8), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount9 != null)
                        {
                            string tradeSizeDisplay9 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(9));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount9.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay9) ? defaultTradeSizeDisplay : tradeSizeDisplay9), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount10 != null)
                        {
                            string tradeSizeDisplay10 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(10));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount10.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay10) ? defaultTradeSizeDisplay : tradeSizeDisplay10), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount11 != null)
                        {
                            string tradeSizeDisplay11 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(11));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount11.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay11) ? defaultTradeSizeDisplay : tradeSizeDisplay11), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount12 != null)
                        {
                            string tradeSizeDisplay12 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(12));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount12.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay12) ? defaultTradeSizeDisplay : tradeSizeDisplay12), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount13 != null)
                        {
                            string tradeSizeDisplay13 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(13));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount13.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay13) ? defaultTradeSizeDisplay : tradeSizeDisplay13), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount14 != null)
                        {
                            string tradeSizeDisplay14 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(14));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount14.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay14) ? defaultTradeSizeDisplay : tradeSizeDisplay14), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount15 != null)
                        {
                            string tradeSizeDisplay15 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(15));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount15.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay15) ? defaultTradeSizeDisplay : tradeSizeDisplay15), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount16 != null)
                        {
                            string tradeSizeDisplay16 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(16));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount16.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay16) ? defaultTradeSizeDisplay : tradeSizeDisplay16), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount17 != null)
                        {
                            string tradeSizeDisplay17 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(17));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount17.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay17) ? defaultTradeSizeDisplay : tradeSizeDisplay17), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount18 != null)
                        {
                            string tradeSizeDisplay18 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(18));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount18.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay18) ? defaultTradeSizeDisplay : tradeSizeDisplay18), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount19 != null)
                        {
                            string tradeSizeDisplay19 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(19));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount19.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay19) ? defaultTradeSizeDisplay : tradeSizeDisplay19), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount20 != null)
                        {
                            string tradeSizeDisplay20 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(20));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount20.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay20) ? defaultTradeSizeDisplay : tradeSizeDisplay20), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount21 != null)
                        {
                            string tradeSizeDisplay21 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(21));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount21.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay21) ? defaultTradeSizeDisplay : tradeSizeDisplay21), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount22 != null)
                        {
                            string tradeSizeDisplay22 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(22));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount22.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay22) ? defaultTradeSizeDisplay : tradeSizeDisplay22), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount23 != null)
                        {
                            string tradeSizeDisplay23 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(23));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount23.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay23) ? defaultTradeSizeDisplay : tradeSizeDisplay23), PrintTo.OutputTab1);
                        }
                        if (this.followerAccount24 != null)
                        {
                            string tradeSizeDisplay24 = TickHunterFollowerTradeSizeValueConverter.GetDisplayValue(GetFollowerTradeSize(24));
                            RealLogger.PrintOutput("Found horde follower account name (" + Convert.ToString(this.followerAccount24.DisplayName) + ") TradeSize: " + (string.IsNullOrEmpty(tradeSizeDisplay24) ? defaultTradeSizeDisplay : tradeSizeDisplay24), PrintTo.OutputTab1);
                        }

                        if (!string.IsNullOrEmpty(FollowerAccount1) && this.followerAccount1 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount1) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount2) && this.followerAccount2 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount2) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount3) && this.followerAccount3 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount3) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount4) && this.followerAccount4 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount4) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount5) && this.followerAccount5 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount5) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount6) && this.followerAccount6 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount6) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount7) && this.followerAccount7 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount7) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount8) && this.followerAccount8 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount8) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount9) && this.followerAccount9 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount9) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount10) && this.followerAccount10 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount10) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount11) && this.followerAccount11 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount11) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount12) && this.followerAccount12 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount12) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount13) && this.followerAccount13 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount13) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount14) && this.followerAccount14 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount14) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount15) && this.followerAccount15 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount15) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount16) && this.followerAccount16 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount16) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount17) && this.followerAccount17 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount17) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount18) && this.followerAccount18 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount18) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount19) && this.followerAccount19 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount19) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount20) && this.followerAccount20 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount20) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount21) && this.followerAccount21 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount21) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount22) && this.followerAccount22 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount22) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount23) && this.followerAccount23 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount23) + ") invalid or not found.", PrintTo.OutputTab1);
                        if (!string.IsNullOrEmpty(FollowerAccount24) && this.followerAccount24 == null) RealLogger.PrintOutput("WARNING: Horde follower account name (" + Convert.ToString(FollowerAccount24) + ") invalid or not found.", PrintTo.OutputTab1);
                        
                        if (hasFollowerAccounts)
                        {
                            SubscribeToExecutionUpdateHorde(followerAccount1);
                            SubscribeToExecutionUpdateHorde(followerAccount2);
                            SubscribeToExecutionUpdateHorde(followerAccount3);
                            SubscribeToExecutionUpdateHorde(followerAccount4);
                            SubscribeToExecutionUpdateHorde(followerAccount5);
                            SubscribeToExecutionUpdateHorde(followerAccount6);
                            SubscribeToExecutionUpdateHorde(followerAccount7);
                            SubscribeToExecutionUpdateHorde(followerAccount8);
                            SubscribeToExecutionUpdateHorde(followerAccount9);
                            SubscribeToExecutionUpdateHorde(followerAccount10);
                            SubscribeToExecutionUpdateHorde(followerAccount11);
                            SubscribeToExecutionUpdateHorde(followerAccount12);
                            SubscribeToExecutionUpdateHorde(followerAccount13);
                            SubscribeToExecutionUpdateHorde(followerAccount14);
                            SubscribeToExecutionUpdateHorde(followerAccount15);
                            SubscribeToExecutionUpdateHorde(followerAccount16);
                            SubscribeToExecutionUpdateHorde(followerAccount17);
                            SubscribeToExecutionUpdateHorde(followerAccount18);
                            SubscribeToExecutionUpdateHorde(followerAccount19);
                            SubscribeToExecutionUpdateHorde(followerAccount20);
                            SubscribeToExecutionUpdateHorde(followerAccount21);
                            SubscribeToExecutionUpdateHorde(followerAccount22);
                            SubscribeToExecutionUpdateHorde(followerAccount23);
                            SubscribeToExecutionUpdateHorde(followerAccount24);
                        }
                    }

                    //WeakEventManager<Account, AccountStatusEventArgs>.AddHandler(account, "AccountStatusUpdate", OnAccountStatusUpdate);
                    //WeakEventManager<Account, AccountItemEventArgs>.AddHandler(account, "AccountItemUpdate", OnAccountItemUpdate);

                    //if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** LoadAccount: Subscribing to PositionUpdate:");
                    //WeakEventManager<Account, PositionEventArgs>.AddHandler(account, "PositionUpdate", OnPositionUpdate);


                    //LoadDayOverMaxLossHighestPnLInSessionData();

                }
                else if (tempAccount == null)
                {
                    RealLogger.PrintOutput("Account name not found.", PrintTo.OutputTab1);
                    RealLogger.PrintOutput("Account name not found.", PrintTo.OutputTab2);
                }
            }


            /*
            Window currentWindow = Window.GetWindow(ChartControl.Parent);
            if (currentWindow != null)
            {
                NinjaTrader.Gui.Tools.AccountSelector accountSelector = currentWindow.FindFirst("ChartTraderControlAccountSelector") as NinjaTrader.Gui.Tools.AccountSelector;
                if (accountSelector != null)
                {
                    if (accountSelector.SelectedAccount != null)
                    {
                        RealLogger.PrintOutput("*** Found account name (" + Convert.ToString(accountSelector.SelectedAccount.DisplayName) + ")", PrintTo.OutputTab2);
                        account = accountSelector.SelectedAccount; //ChartControl.OwnerChart.ChartTrader.Account 

                        if (account != null)
                        {
                            //Account.ExecutionUpdate += OnExecutionUpdate;
                            WeakEventManager<Account, OrderEventArgs>.AddHandler(account, "OrderUpdate", OnOrderUpdate);
                            WeakEventManager<Account, PositionEventArgs>.AddHandler(account, "PositionUpdate", OnPositionUpdate);
                            //Account.OrderUpdate += OnOrderUpdate;
                            // Subscribe to position updates
                            //Account.PositionUpdate += OnPositionUpdate;

                        }
                    }
                }
                else
                    RealLogger.PrintOutput("*** Account name not found.", PrintTo.OutputTab2);

            }
            else
                RealLogger.PrintOutput("*** Account name not found and no window.", PrintTo.OutputTab2);
            */
        }

        private void SetButtonPanelVisiblity()
        {
            if (buttonGrid != null)
            {
                buttonGrid.Background = Brushes.Black;

                if (thLayoutGrid != null)
                {
                    thLayoutGrid.Visibility = Visibility.Visible;
                }
                if (labelGrid != null)
                {
                    labelGrid.Visibility = Visibility.Visible;
                }
                if (riskInfoLabel != null)
                {
                    riskInfoLabel.Visibility = (string.IsNullOrEmpty(riskInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible; 
                }
                if (profitInfoLabel != null)
                {
                    profitInfoLabel.Visibility = (string.IsNullOrEmpty(profitInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible; 
                }
                if (bogeyTargetInfoLabel != null)
                {
                    bogeyTargetInfoLabel.Visibility = (string.IsNullOrEmpty(bogeyTargetInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible; 
                }
                if (dayOverMaxLossInfoLabel != null)
                {
                    dayOverMaxLossInfoLabel.Visibility = (string.IsNullOrEmpty(dayOverMaxLossInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible; 
                }
                if (hordeTradeCopierInfoLabel != null)
                {
                    hordeTradeCopierInfoLabel.Visibility = (string.IsNullOrEmpty(hordeTradeCopierInfoLabel.Text) || !hasRanOnceFirstCycle || !isTickHunterActivated) ? Visibility.Collapsed : Visibility.Visible; 
                }
                if (revButton != null && ShowButtonReverse)
                {
                    revButton.Visibility = Visibility.Visible;
                }
                if (closeAllButton != null && ShowButtonClose)
                {
                    closeAllButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoCloseButton != null && ShowButtonAutoClose)
                {
                    toggleAutoCloseButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoBEButton != null && ShowButtonAutoBreakEven)
                {
                    toggleAutoBEButton.Visibility = Visibility.Visible;
                }
                if (toggleProfitTargetButton != null && ShowButtonProfitTarget)
                {
                    toggleProfitTargetButton.Visibility = Visibility.Visible;
                }
                if (TPButton != null && ShowButtonTPPlus)
                {
                    TPButton.Visibility = Visibility.Visible;
                }
                if (BEButton != null && ShowButtonBEPlus)
                {
                    BEButton.Visibility = Visibility.Visible;
                }
                if (SLButton != null && ShowButtonSLPlus)
                {
                    SLButton.Visibility = Visibility.Visible;
                }
                if (BuyMarketButton != null && ShowButtonBuyMarket)
                {
                    BuyMarketButton.Visibility = Visibility.Visible;
                }
                if (SellMarketButton != null && ShowButtonSellMarket)
                {
                    SellMarketButton.Visibility = Visibility.Visible;
                }
                if (BuyPopButton != null && ShowButtonPopPlus)
                {
                    BuyPopButton.Visibility = Visibility.Visible;
                }
                if (SellPopButton != null && ShowButtonPopMinus)
                {
                    SellPopButton.Visibility = Visibility.Visible;
                }
                if (BuyDropButton != null && ShowButtonDropPlus)
                {
                    BuyDropButton.Visibility = Visibility.Visible;
                }
                if (SellDropButton != null && ShowButtonDropMinus)
                {
                    SellDropButton.Visibility = Visibility.Visible;
                }
                if (toggleEntryVolumeAutoButton != null && ShowButtonVolume)
                {
                    toggleEntryVolumeAutoButton.Visibility = Visibility.Visible;
                }
                if (toggleEntryVolumeMaxButton != null && ShowButtonVolumeMax && LimitToVolumeMaxOption)
                {
                    toggleEntryVolumeMaxButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoPilotButton != null && ShowButtonAutoPilot)
                {
                    toggleAutoPilotButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoPilotProfileButton != null && ShowButtonAutoPilotProfile)
                {
                    toggleAutoPilotProfileButton.Visibility = Visibility.Visible;
                }
                if (toggleTradeSignalButton != null && ShowButtonTradeSignal && !UseAutoPilotLite)
                {
                    toggleTradeSignalButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoAddOnButton != null && ShowButtonAutoAddOn)
                {
                    toggleAutoAddOnButton.Visibility = Visibility.Visible;
                }
            }
        }

        private void SetButtonPanelHidden()
        {
            if (buttonGrid != null)
            {
                buttonGrid.Background = Brushes.Transparent;

                if (thLayoutGrid != null)
                {
                    thLayoutGrid.Visibility = Visibility.Visible;
                }
                if (labelGrid != null)
                {
                    labelGrid.Visibility = Visibility.Hidden;
                }
                if (riskInfoLabel != null)
                {
                    riskInfoLabel.Visibility = Visibility.Hidden;
                }
                if (profitInfoLabel != null)
                {
                    profitInfoLabel.Visibility = Visibility.Hidden;
                }
                if (bogeyTargetInfoLabel != null)
                {
                    bogeyTargetInfoLabel.Visibility = Visibility.Hidden;
                }
                if (dayOverMaxLossInfoLabel != null)
                {
                    dayOverMaxLossInfoLabel.Visibility = Visibility.Hidden;
                }
                if (hordeTradeCopierInfoLabel != null)
                {
                    hordeTradeCopierInfoLabel.Visibility = Visibility.Hidden;
                }
                if (revButton != null)
                {
                    revButton.Visibility = Visibility.Hidden;
                }
                if (closeAllButton != null)
                {
                    closeAllButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoCloseButton != null)
                {
                    toggleAutoCloseButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoBEButton != null)
                {
                    toggleAutoBEButton.Visibility = Visibility.Hidden;
                }
                if (toggleProfitTargetButton != null)
                {
                    toggleProfitTargetButton.Visibility = Visibility.Hidden;
                }
                if (TPButton != null)
                {
                    TPButton.Visibility = Visibility.Hidden;
                }
                if (BEButton != null)
                {
                    BEButton.Visibility = Visibility.Hidden;
                }
                if (SLButton != null)
                {
                    SLButton.Visibility = Visibility.Hidden;
                }
                if (BuyPopButton != null)
                {
                    BuyPopButton.Visibility = Visibility.Hidden;
                }
                if (SellPopButton != null)
                {
                    SellPopButton.Visibility = Visibility.Hidden;
                }
                if (BuyDropButton != null)
                {
                    BuyDropButton.Visibility = Visibility.Hidden;
                }
                if (SellDropButton != null)
                {
                    SellDropButton.Visibility = Visibility.Hidden;
                }
                if (BuyMarketButton != null)
                {
                    BuyMarketButton.Visibility = Visibility.Hidden;
                }
                if (SellMarketButton != null)
                {
                    SellMarketButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoAddOnButton != null)
                {
                    toggleAutoAddOnButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoPilotButton != null)
                {
                    toggleAutoPilotButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoPilotProfileButton != null)
                {
                    toggleAutoPilotProfileButton.Visibility = Visibility.Hidden;
                }
                if (toggleTradeSignalButton != null)
                {
                    toggleTradeSignalButton.Visibility = Visibility.Hidden;
                }
                if (toggleEntryVolumeAutoButton != null)
                {
                    toggleEntryVolumeAutoButton.Visibility = Visibility.Hidden;
                }
                if (toggleEntryVolumeMaxButton != null)
                {
                    toggleEntryVolumeMaxButton.Visibility = Visibility.Hidden;
                }
            }
        }
        private bool IsStrategyAttachedToChart()
        {
            return (this.ChartBars != null);
        }

        private void RemoveButtonPanel()
        {
            if (buttonGrid != null)
            {
                if (UserControlCollection.Contains(buttonGrid))
                {
                    if (revButton != null)
                    {
                        UnsubscribeToButtonClick(revButton);
                        buttonGrid.Children.Remove(revButton);
                        revButton = null;
                    }
                    if (closeAllButton != null)
                    {
                        UnsubscribeToButtonClick(closeAllButton);
                        buttonGrid.Children.Remove(closeAllButton);
                        closeAllButton = null;
                    }
                    if (toggleAutoCloseButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoCloseButton);
                        buttonGrid.Children.Remove(toggleAutoCloseButton);
                        toggleAutoCloseButton = null;
                    }
                    if (toggleAutoBEButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoBEButton);
                        buttonGrid.Children.Remove(toggleAutoBEButton);
                        toggleAutoBEButton = null;
                    }
                    if (toggleProfitTargetButton != null)
                    {
                        UnsubscribeToButtonClick(toggleProfitTargetButton);
                        buttonGrid.Children.Remove(toggleProfitTargetButton);
                        toggleProfitTargetButton = null;
                    }
                    if (toggleEntryVolumeAutoButton != null)
                    {
                        UnsubscribeToButtonClick(toggleEntryVolumeAutoButton);
                        buttonGrid.Children.Remove(toggleEntryVolumeAutoButton);
                        toggleEntryVolumeAutoButton = null;
                    }
                    if (toggleEntryVolumeMaxButton != null)
                    {
                        UnsubscribeToButtonClick(toggleEntryVolumeMaxButton);
                        buttonGrid.Children.Remove(toggleEntryVolumeMaxButton);
                        toggleEntryVolumeMaxButton = null;
                    }

                    if (toggleAutoAddOnButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoAddOnButton);
                        buttonGrid.Children.Remove(toggleAutoAddOnButton);
                        toggleAutoAddOnButton = null;
                    }

                    if (toggleTradeSignalButton != null)
                    {
                        UnsubscribeToButtonClick(toggleTradeSignalButton);
                        buttonGrid.Children.Remove(toggleTradeSignalButton);
                        toggleTradeSignalButton = null;
                    }

                    if (toggleAutoPilotButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoPilotButton);
                        buttonGrid.Children.Remove(toggleAutoPilotButton);
                        toggleAutoPilotButton = null;
                    }

                    if (toggleAutoPilotProfileButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoPilotProfileButton);
                        buttonGrid.Children.Remove(toggleAutoPilotProfileButton);
                        toggleAutoPilotProfileButton = null;
                    }

                    if (TPButton != null)
                    {
                        UnsubscribeToButtonClick(TPButton);
                        buttonGrid.Children.Remove(TPButton);
                        TPButton = null;
                    }
                    if (BEButton != null)
                    {
                        UnsubscribeToButtonClick(BEButton);
                        buttonGrid.Children.Remove(BEButton);
                        BEButton = null;
                    }
                    if (SLButton != null)
                    {
                        UnsubscribeToButtonClick(SLButton);
                        buttonGrid.Children.Remove(SLButton);
                        SLButton = null;
                    }

                    if (BuyPopButton != null)
                    {
                        UnsubscribeToButtonClick(BuyPopButton);
                        buttonGrid.Children.Remove(BuyPopButton);
                        BuyPopButton = null;
                    }

                    if (SellPopButton != null)
                    {
                        UnsubscribeToButtonClick(SellPopButton);
                        buttonGrid.Children.Remove(SellPopButton);
                        SellPopButton = null;
                    }

                    if (BuyDropButton != null)
                    {
                        UnsubscribeToButtonClick(BuyDropButton);
                        buttonGrid.Children.Remove(BuyDropButton);
                        BuyDropButton = null;
                    }

                    if (SellDropButton != null)
                    {
                        UnsubscribeToButtonClick(SellDropButton);
                        buttonGrid.Children.Remove(SellDropButton);
                        SellDropButton = null;
                    }

                    if (BuyMarketButton != null)
                    {
                        UnsubscribeToButtonClick(BuyMarketButton);
                        buttonGrid.Children.Remove(BuyMarketButton);
                        BuyMarketButton = null;
                    }

                    if (SellMarketButton != null)
                    {
                        UnsubscribeToButtonClick(SellMarketButton);
                        buttonGrid.Children.Remove(SellMarketButton);
                        SellMarketButton = null;
                    }


                    thLayoutGrid = null;
                }
            }
        }

        private void DrawButtonPanel()
        {
            if (thLayoutGrid == null)
            {
                if (!UserControlCollection.Contains(thLayoutGrid))
                {
                    thLayoutGrid = new System.Windows.Controls.Grid
                    {
                        Name = "HHTHLayoutGrid",
                        Margin = new Thickness(0, 0, 40, 0),
                        HorizontalAlignment = HorizontalAlignment.Right,
                        VerticalAlignment = VerticalAlignment.Top
                        //ShowGridLines = true,
                        //Background = Brushes.Black
                    };

                    System.Windows.Controls.RowDefinition thLayoutRow1 = new System.Windows.Controls.RowDefinition();
                    System.Windows.Controls.RowDefinition thLayoutRow2 = new System.Windows.Controls.RowDefinition();
                    thLayoutGrid.RowDefinitions.Add(thLayoutRow1);
                    thLayoutGrid.RowDefinitions.Add(thLayoutRow2);

                    System.Windows.Controls.ColumnDefinition thLayoutColumn1 = new System.Windows.Controls.ColumnDefinition();

                    thLayoutGrid.ColumnDefinitions.Add(thLayoutColumn1);


                    buttonGrid = new System.Windows.Controls.Grid
                    {
                        Name = "HHButtonGrid",
                        Margin = new Thickness(0, 0, 0, 0),
                        HorizontalAlignment = HorizontalAlignment.Right,
                        VerticalAlignment = VerticalAlignment.Top,
                        //ShowGridLines = true,
                        Background = Brushes.Black

                    };

                    System.Windows.Controls.RowDefinition row1 = new System.Windows.Controls.RowDefinition();



                    //System.Windows.Controls.RowDefinition row3 = new System.Windows.Controls.RowDefinition();
                    //row2.Height = new GridLength(50);
                    buttonGrid.RowDefinitions.Add(row1);
                    //buttonGrid.RowDefinitions.Add(row3);

                    System.Windows.Controls.ColumnDefinition column1 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column2 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column3 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column4 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column5 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column6 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column7 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column8 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column9 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column10 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column11 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column12 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column13 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column14 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column15 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column16 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column17 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column18 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column19 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column20 = new System.Windows.Controls.ColumnDefinition();


                    buttonGrid.ColumnDefinitions.Add(column1);
                    buttonGrid.ColumnDefinitions.Add(column2);
                    buttonGrid.ColumnDefinitions.Add(column3);
                    buttonGrid.ColumnDefinitions.Add(column4);
                    buttonGrid.ColumnDefinitions.Add(column5);
                    buttonGrid.ColumnDefinitions.Add(column6);
                    buttonGrid.ColumnDefinitions.Add(column7);
                    buttonGrid.ColumnDefinitions.Add(column8);
                    buttonGrid.ColumnDefinitions.Add(column9);
                    buttonGrid.ColumnDefinitions.Add(column10);
                    buttonGrid.ColumnDefinitions.Add(column11);
                    buttonGrid.ColumnDefinitions.Add(column12);
                    buttonGrid.ColumnDefinitions.Add(column13);
                    buttonGrid.ColumnDefinitions.Add(column14);
                    buttonGrid.ColumnDefinitions.Add(column15);
                    buttonGrid.ColumnDefinitions.Add(column16);
                    buttonGrid.ColumnDefinitions.Add(column17);
                    buttonGrid.ColumnDefinitions.Add(column18);
                    buttonGrid.ColumnDefinitions.Add(column19);
                    buttonGrid.ColumnDefinitions.Add(column20);


                    revButton = new System.Windows.Controls.Button
                    {
                        Name = HHRevButtonName,
                        Content = (IsBlendedInstrumentEnabled()) ? ToggleReverseBButtonText : ToggleReverseButtonText,
                        ToolTip = (IsBlendedInstrumentEnabled()) ? ToggleReverseBButtonToolTip : ToggleReverseButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.DarkOrange,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    string closeButtonText = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonText : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonText : ToggleCloseButtonText;
                    string closeButtonToolTip = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonToolTip : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonToolTip : ToggleCloseButtonToolTip;

                    closeAllButton = new System.Windows.Controls.Button
                    {
                        Name = HHCloseAllButtonName,
                        Content = closeButtonText,
                        ToolTip = closeButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.DarkGreen,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    string tempContent;
                    string tempToolTip;

                    if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage4Break)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.DriftLine4Break)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieStackedFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }

                    Brush tempBrush = (currentCloseAutoStatus != TickHunterCloseAutoTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoCloseButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoCloseButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Enabled)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.HODL)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMix)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZombieFlip)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMonster)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else
                    {
                        lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }

                    tempBrush = (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoBEButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoBEButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    GetBogeyTargetTypeButtonText(currentBogeyTargetMultiplier, out tempContent, out tempToolTip);

                    tempBrush = (currentBogeyTargetMultiplier != BogeyTargetMultiplierDisabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleProfitTargetButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleProfitTargetButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    TPButton = new System.Windows.Controls.Button
                    {
                        Name = HHTPButtonName,
                        Content = ToggleTPButtonText,
                        ToolTip = ToggleTPButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.Silver,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden

                    };

                    BEButton = new System.Windows.Controls.Button
                    {
                        Name = HHBEButtonName,
                        Content = ToggleBEButtonText,
                        ToolTip = ToggleBEButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.DarkCyan,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden

                    };

                    SLButton = new System.Windows.Controls.Button
                    {
                        Name = HHSLButtonName,
                        Content = ToggleSLButtonText,
                        ToolTip = ToggleSLButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.Silver,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    BuyDropButton = new System.Windows.Controls.Button
                    {
                        Name = HHBuyDropButtonName,
                        Content = ToggleDropBuyButtonText,
                        ToolTip = ToggleDropBuyButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.Blue,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    SellDropButton = new System.Windows.Controls.Button
                    {
                        Name = HHSellDropButtonName,
                        Content = ToggleDropSellButtonText,
                        ToolTip = ToggleDropSellButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.OrangeRed,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out tempContent, out tempToolTip);

                    BuyPopButton = new System.Windows.Controls.Button
                    {
                        Name = HHBuyPopButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out tempContent, out tempToolTip);

                    SellPopButton = new System.Windows.Controls.Button
                    {
                        Name = HHSellPopButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    BuyMarketButton = new System.Windows.Controls.Button
                    {
                        Name = HHBuyMarketButtonName,
                        Content = ToggleBuyMarketButtonText,
                        ToolTip = ToggleBuyMarketButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.Blue,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    SellMarketButton = new System.Windows.Controls.Button
                    {
                        Name = HHSellMarketButtonName,
                        Content = ToggleSellMarketButtonText,
                        ToolTip = ToggleSellMarketButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.OrangeRed,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    if (currentEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option2)
                    {
                        tempContent = ToggleAutoEntryVolOption2ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption2ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option3)
                    {
                        tempContent = ToggleAutoEntryVolOption3ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption3ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option4)
                    {
                        tempContent = ToggleAutoEntryVolOption4ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption4ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option5)
                    {
                        tempContent = ToggleAutoEntryVolOption5ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption5ButtonEnabledToolTip;
                    }
                    else
                    {
                        tempContent = ToggleAutoEntryVolOption1ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption1ButtonEnabledToolTip;
                    }

                    tempBrush = Brushes.SaddleBrown;


                    toggleEntryVolumeAutoButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleEntryVolumeAutoButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };


                    if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option2)
                    {
                        tempContent = ToggleEntryVolMaxOption2ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption2ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option3)
                    {
                        tempContent = ToggleEntryVolMaxOption3ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption3ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option4)
                    {
                        tempContent = ToggleEntryVolMaxOption4ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption4ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option5)
                    {
                        tempContent = ToggleEntryVolMaxOption5ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption5ButtonEnabledToolTip;
                    }
                    else
                    {
                        tempContent = ToggleEntryVolMaxOption1ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption1ButtonEnabledToolTip;
                    }

                    tempBrush = Brushes.SaddleBrown;


                    toggleEntryVolumeMaxButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleEntryVolumeMaxButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    if (currentAutoAddOnStatus == TickHunterAutoAddOnTypes.Enabled)
                    {
                        tempContent = ToggleAutoAddOnButtonEnabledText;
                        tempToolTip = string.Format(ToggleAutoAddOnButtonEnabledToolTip, autoAddOnMaxDollars.ToString("N0"));
                    }
                    else
                    {
                        tempContent = ToggleAutoAddOnButtonDisabledText;
                        tempToolTip = string.Format(ToggleAutoAddOnButtonDisabledToolTip, autoAddOnMaxDollars.ToString("N0"));
                    }

                    tempBrush = (currentAutoAddOnStatus != TickHunterAutoAddOnTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoAddOnButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoAddOnButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };


                    if (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll)
                    {
                        tempContent = ToggleTradeSignalBSAButtonEnabledText;
                        tempToolTip = ToggleTradeSignalBSAButtonEnabledTextToolTip;
                    }
                    else if (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered)
                    {
                        tempContent = ToggleTradeSignalBSFButtonEnabledText;
                        tempToolTip = ToggleTradeSignalBSFButtonEnabledTextToolTip;
                    }
                    else if (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly)
                    {
                        tempContent = ToggleTradeSignalBOButtonEnabledText;
                        tempToolTip = ToggleTradeSignalBOButtonEnabledTextToolTip;
                    }
                    else if (currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly)
                    {
                        tempContent = ToggleTradeSignalSOButtonEnabledText;
                        tempToolTip = ToggleTradeSignalSOButtonEnabledTextToolTip;
                    }
                    else
                    {
                        tempContent = ToggleTradeSignalButtonDisabledText;
                        tempToolTip = ToggleTradeSignalButtonDisabledToolTip;
                    }


                    tempBrush = (currentTradeSignalStatus != TickHunterTradeSignalTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleTradeSignalButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleTradeSignalButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    if (UseAutoPilotLite)
                    {
                        GetAutoPilotLiteButtonText(currentAutoPilotLiteStatus, out tempContent, out tempToolTip);
                    }
                    else
                    {
                        GetAutoPilotButtonText(currentAutoPilotStatus, out tempContent, out tempToolTip);
                    }

                    tempBrush = (currentAutoPilotStatus != TickHunterAutoPilotTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoPilotButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoPilotButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };


                    GetAutoPilotProfileButtonText(currentAutoPilotProfileStatus, out tempContent, out tempToolTip);

                    tempBrush = (currentAutoPilotProfileStatus != TickHunterAutoPilotProfileTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoPilotProfileButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoPilotProfileButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    SubscribeToButtonClick(closeAllButton);
                    SubscribeToButtonClick(revButton);
                    SubscribeToButtonClick(toggleAutoCloseButton);
                    SubscribeToButtonClick(toggleAutoBEButton);
                    SubscribeToButtonClick(toggleProfitTargetButton);
                    SubscribeToButtonClick(TPButton);
                    SubscribeToButtonClick(BEButton);
                    SubscribeToButtonClick(SLButton);
                    SubscribeToButtonClick(BuyDropButton);
                    SubscribeToButtonClick(SellDropButton);
                    SubscribeToButtonClick(BuyPopButton);
                    SubscribeToButtonClick(SellPopButton);
                    SubscribeToButtonClick(BuyMarketButton);
                    SubscribeToButtonClick(SellMarketButton);
                    SubscribeToButtonClick(toggleEntryVolumeAutoButton);
                    SubscribeToButtonClick(toggleEntryVolumeMaxButton);
                    SubscribeToButtonClick(toggleAutoAddOnButton);
                    SubscribeToButtonClick(toggleAutoPilotProfileButton);
                    SubscribeToButtonClick(toggleTradeSignalButton);
                    SubscribeToButtonClick(toggleAutoPilotButton);


                    int gridColumnIndex = buttonGrid.ColumnDefinitions.Count - 1;

                    if (ShowButtonVolume)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleEntryVolumeAutoButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleEntryVolumeAutoButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleEntryVolumeAutoButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleEntryVolumeAutoButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleEntryVolumeAutoButton, 0);
                        toggleEntryVolumeAutoButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonVolume) gridColumnIndex--;

                    if (ShowButtonVolumeMax && LimitToVolumeMaxOption)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleEntryVolumeMaxButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleEntryVolumeMaxButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleEntryVolumeMaxButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleEntryVolumeMaxButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleEntryVolumeMaxButton, 0);
                        toggleEntryVolumeMaxButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonVolumeMax && LimitToVolumeMaxOption) gridColumnIndex--;

                    if (ShowButtonAutoPilot)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoPilotButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoPilotButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 75;
                        buttonGrid.Children.Add(toggleAutoPilotButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoPilotButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoPilotButton, 0);
                        toggleAutoPilotButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoPilot) gridColumnIndex--;

                    if (ShowButtonTradeSignal && !UseAutoPilotLite)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleTradeSignalButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleTradeSignalButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleTradeSignalButton);

                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleTradeSignalButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleTradeSignalButton, 0);
                        toggleTradeSignalButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonTradeSignal && !UseAutoPilotLite) gridColumnIndex--;

                    if (ShowButtonAutoPilotProfile)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoPilotProfileButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoPilotProfileButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleAutoPilotProfileButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoPilotProfileButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoPilotProfileButton, 0);
                        toggleAutoPilotProfileButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoPilotProfile) gridColumnIndex--;

                    if (ShowButtonAutoAddOn)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoAddOnButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoAddOnButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleAutoAddOnButton);

                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoAddOnButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoAddOnButton, 0);
                        toggleAutoAddOnButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoAddOn) gridColumnIndex--;

                    if (ShowButtonDropPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyDropButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyDropButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(BuyDropButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyDropButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyDropButton, 0);
                        BuyDropButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonDropPlus) gridColumnIndex--;

                    if (ShowButtonDropMinus)
                    {
                        System.Windows.Controls.Grid.SetColumn(SellDropButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellDropButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(SellDropButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(SellDropButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellDropButton, 0);
                        SellDropButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonDropMinus) gridColumnIndex--;

                    if (ShowButtonPopMinus)
                    {
                        System.Windows.Controls.Grid.SetColumn(SellPopButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellPopButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(SellPopButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(SellPopButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellPopButton, 0);
                        SellPopButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonPopMinus) gridColumnIndex--;

                    if (ShowButtonPopPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyPopButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyPopButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(BuyPopButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyPopButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyPopButton, 0);
                        BuyPopButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonPopPlus) gridColumnIndex--;

                    if (ShowButtonSellMarket)
                    {
                        System.Windows.Controls.Grid.SetColumn(SellMarketButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellMarketButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(SellMarketButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(SellMarketButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellMarketButton, 0);
                        SellMarketButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonSellMarket) gridColumnIndex--;

                    if (ShowButtonBuyMarket)
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyMarketButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyMarketButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(BuyMarketButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyMarketButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyMarketButton, 0);
                        BuyMarketButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonBuyMarket) gridColumnIndex--;

                    if (ShowButtonSLPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(SLButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SLButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(SLButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(SLButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SLButton, 0);
                        SLButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonSLPlus) gridColumnIndex--;

                    if (ShowButtonBEPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(BEButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BEButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(BEButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(BEButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BEButton, 0);
                        BEButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonBEPlus) gridColumnIndex--;

                    if (ShowButtonTPPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(TPButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(TPButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(TPButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(TPButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(TPButton, 0);
                        TPButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonTPPlus) gridColumnIndex--;

                    if (ShowButtonProfitTarget)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleProfitTargetButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleProfitTargetButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleProfitTargetButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleProfitTargetButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleProfitTargetButton, 0);
                        toggleProfitTargetButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonProfitTarget) gridColumnIndex--;

                    if (ShowButtonAutoClose)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoCloseButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoCloseButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleAutoCloseButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoCloseButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoCloseButton, 0);
                        toggleAutoCloseButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoClose) gridColumnIndex--;

                    if (ShowButtonClose)
                    {
                        System.Windows.Controls.Grid.SetColumn(closeAllButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(closeAllButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(closeAllButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(closeAllButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(closeAllButton, 0);
                        closeAllButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonClose) gridColumnIndex--;

                    if (ShowButtonReverse)
                    {
                        System.Windows.Controls.Grid.SetColumn(revButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(revButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(revButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(revButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(revButton, 0);
                        revButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonReverse) gridColumnIndex--;

                    if (ShowButtonAutoBreakEven)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoBEButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoBEButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 75;
                        buttonGrid.Children.Add(toggleAutoBEButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoBEButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoBEButton, 0);
                        toggleAutoBEButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoBreakEven) gridColumnIndex--;




                    #region LabelGrid
                    labelGrid = new System.Windows.Controls.Grid
                    {
                        Name = "HHLabelGrid",
                        Margin = new Thickness(0, 0, 2, 0),
                        HorizontalAlignment = HorizontalAlignment.Right,
                        VerticalAlignment = VerticalAlignment.Top,
                        //ShowGridLines = true,
                        Background = Brushes.Black

                    };

                    System.Windows.Controls.RowDefinition labelRow1 = new System.Windows.Controls.RowDefinition();
                    labelGrid.RowDefinitions.Add(labelRow1);

                    System.Windows.Controls.ColumnDefinition labelColumn1 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition labelColumn2 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition labelColumn3 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition labelColumn4 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition labelColumn5 = new System.Windows.Controls.ColumnDefinition();

                    labelColumn1.Width = GridLength.Auto;
                    labelColumn2.Width = GridLength.Auto;
                    labelColumn3.Width = GridLength.Auto;
                    labelColumn4.Width = GridLength.Auto;
                    labelColumn5.Width = GridLength.Auto;

                    labelGrid.ColumnDefinitions.Add(labelColumn1);
                    labelGrid.ColumnDefinitions.Add(labelColumn2);
                    labelGrid.ColumnDefinitions.Add(labelColumn3);
                    labelGrid.ColumnDefinitions.Add(labelColumn4);
                    labelGrid.ColumnDefinitions.Add(labelColumn5);

                    #endregion

                    riskInfoLabel = new System.Windows.Controls.TextBlock
                    {
                        Name = HHRiskInfoLabelName,
                        Text = "",
                        Foreground = Brushes.White,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Padding = new Thickness(0, 0, 0, 0),
                        Margin = new Thickness(20, 4, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    profitInfoLabel = new System.Windows.Controls.TextBlock
                    {
                        Name = HHProfitInfoLabelName,
                        Text = "",
                        Foreground = Brushes.White,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Padding = new Thickness(0, 0, 0, 0),
                        Margin = new Thickness(20, 4, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    bogeyTargetInfoLabel = new System.Windows.Controls.TextBlock
                    {
                        Name = HHBogeyTargetInfoLabelName,
                        Text = "",
                        Foreground = Brushes.Silver,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Padding = new Thickness(0, 0, 0, 0),
                        Margin = new Thickness(20, 4, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    dayOverMaxLossInfoLabel = new System.Windows.Controls.TextBlock
                    {
                        Name = HHDayOverMaxLossInfoLabelName,
                        Text = "",
                        Foreground = dayOverMaxLossInfoTextColor,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Padding = new Thickness(0, 0, 0, 0),
                        Margin = new Thickness(20, 4, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };
                    //if (IsDayOverMaxLossEnabled()) dayOverMaxLossInfoLabel.Background = Brushes.Black;

                    hordeTradeCopierInfoLabel = new System.Windows.Controls.TextBlock
                    {
                        Name = HHHordeTradeCopierInfoLabelName,
                        Text = "",
                        Foreground = Brushes.Silver,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Padding = new Thickness(0, 0, 0, 0),
                        Margin = new Thickness(20, 4, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    

                    System.Windows.Controls.Grid.SetColumn(bogeyTargetInfoLabel, 4);
                    System.Windows.Controls.Grid.SetRow(bogeyTargetInfoLabel, 4);

                    System.Windows.Controls.Grid.SetColumn(riskInfoLabel, 3);
                    System.Windows.Controls.Grid.SetRow(riskInfoLabel, 3);

                    System.Windows.Controls.Grid.SetColumn(profitInfoLabel, 2);
                    System.Windows.Controls.Grid.SetRow(profitInfoLabel, 2);

                    System.Windows.Controls.Grid.SetColumn(dayOverMaxLossInfoLabel, 1);
                    System.Windows.Controls.Grid.SetRow(dayOverMaxLossInfoLabel, 1);

                    System.Windows.Controls.Grid.SetColumn(hordeTradeCopierInfoLabel, 0);
                    System.Windows.Controls.Grid.SetRow(hordeTradeCopierInfoLabel, 0);

                    labelGrid.Children.Add(bogeyTargetInfoLabel);
                    labelGrid.Children.Add(riskInfoLabel);
                    labelGrid.Children.Add(profitInfoLabel);
                    labelGrid.Children.Add(dayOverMaxLossInfoLabel);
                    labelGrid.Children.Add(hordeTradeCopierInfoLabel);



                    System.Windows.Controls.Grid.SetColumn(labelGrid, 0);
                    System.Windows.Controls.Grid.SetRow(labelGrid, 1);
                    //System.Windows.Controls.Grid.SetColumnSpan(labelGrid, buttonGrid.ColumnDefinitions.Count);

                    /*
                    System.Windows.Controls.Grid.SetColumn(riskInfoLabel, 6);
                    System.Windows.Controls.Grid.SetRow(riskInfoLabel, 1);
                    System.Windows.Controls.Grid.SetColumnSpan(riskInfoLabel, 3);

                    System.Windows.Controls.Grid.SetColumn(dayOverMaxLossInfoLabel, 10);
                    System.Windows.Controls.Grid.SetRow(dayOverMaxLossInfoLabel, 1);
                    System.Windows.Controls.Grid.SetColumnSpan(dayOverMaxLossInfoLabel, 3);
                    

                    buttonGrid.Children.Add(riskInfoLabel);
                    buttonGrid.Children.Add(dayOverMaxLossInfoLabel);
                    */

                    thLayoutGrid.Children.Add(labelGrid);

                    /*
                    buttonGrid.Children.Add(toggleAutoBEButton);
                    buttonGrid.Children.Add(revButton);
                    buttonGrid.Children.Add(closeAllButton);
                    buttonGrid.Children.Add(toggleAutoCloseButton);
                    buttonGrid.Children.Add(toggleProfitTargetButton);
                    buttonGrid.Children.Add(TPButton);
                    buttonGrid.Children.Add(BEButton);
                    buttonGrid.Children.Add(SLButton);
                    buttonGrid.Children.Add(BuyMarketButton);
                    buttonGrid.Children.Add(SellMarketButton);
                    buttonGrid.Children.Add(BuyPopButton);
                    buttonGrid.Children.Add(SellPopButton);
                    buttonGrid.Children.Add(BuyDropButton);
                    buttonGrid.Children.Add(SellDropButton);
                    buttonGrid.Children.Add(toggleAutoAddOnButton);
                    buttonGrid.Children.Add(toggleTradeSignalButton);
                    buttonGrid.Children.Add(toggleAutoPilotButton);
                    buttonGrid.Children.Add(toggleEntryVolumeAutoButton);
                    */



                    thLayoutGrid.Children.Add(buttonGrid);

                    System.Windows.Controls.Grid.SetColumn(buttonGrid, 0);
                    System.Windows.Controls.Grid.SetRow(buttonGrid, 0);

                    UserControlCollection.Add(thLayoutGrid);
                }
            }
        }

        private void SubscribeToMarketDataUpdate(Instrument instrument)
        {
            if (instrument != null)
            {
                UnsubscribeToMarketDataUpdate(instrument);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to MarketDataUpdate for " + instrument);
                WeakEventManager<Instrument, MarketDataEventArgs>.AddHandler(instrument, "MarketDataUpdate", MarketData_Update);
            }
        }

        private void UnsubscribeToMarketDataUpdate(Instrument instrument)
        {
            if (instrument != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to MarketDataUpdate for " + instrument);
                WeakEventManager<Instrument, MarketDataEventArgs>.RemoveHandler(instrument, "MarketDataUpdate", MarketData_Update);
            }
        }

        private void SubscribeToOrderUpdate(Account account)
        {
            if (account != null)
            {
                UnsubscribeToOrderUpdate(account);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to OrderUpdate for " + account);
                WeakEventManager<Account, OrderEventArgs>.AddHandler(account, "OrderUpdate", OnOrderUpdate);
            }
        }

        private void UnsubscribeToOrderUpdate(Account account)
        {
            if (account != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to OrderUpdate for " + account);
                WeakEventManager<Account, OrderEventArgs>.RemoveHandler(account, "OrderUpdate", OnOrderUpdate);
            }
        }

        private void SubscribeToExecutionUpdate(Account account)
        {
            if (account != null)
            {
                UnsubscribeToExecutionUpdate(account);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to ExecutionUpdate for " + account);
                WeakEventManager<Account, ExecutionEventArgs>.AddHandler(account, "ExecutionUpdate", OnExecutionUpdate);
            }
        }

        private void UnsubscribeToExecutionUpdate(Account account)
        {
            if (account != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to ExecutionUpdate for " + account);
                WeakEventManager<Account, ExecutionEventArgs>.RemoveHandler(account, "ExecutionUpdate", OnExecutionUpdate);
            }
        }

        private void SubscribeToExecutionUpdateHorde(Account account)
        {
            if (account != null)
            {
                UnsubscribeToExecutionUpdateHorde(account);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to ExecutionUpdateHorde for " + account);
                WeakEventManager<Account, ExecutionEventArgs>.AddHandler(account, "ExecutionUpdate", OnExecutionUpdateHorde);
            }
        }

        private void UnsubscribeToExecutionUpdateHorde(Account account)
        {
            if (account != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to ExecutionUpdateHorde for " + account);
                WeakEventManager<Account, ExecutionEventArgs>.RemoveHandler(account, "ExecutionUpdate", OnExecutionUpdateHorde);
            }
        }


        private void SubscribeToPositionUpdate(Account account)
        {
            if (account != null)
            {
                UnsubscribeToPositionUpdate(account);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to PositionUpdate for " + account);
                WeakEventManager<Account, PositionEventArgs>.AddHandler(account, "PositionUpdate", OnPositionUpdate);
            }
        }

        private void UnsubscribeToPositionUpdate(Account account)
        {
            if (account != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to PositionUpdate for " + account);
                WeakEventManager<Account, PositionEventArgs>.RemoveHandler(account, "PositionUpdate", OnPositionUpdate);
            }
        }

        private void SubscribeToPreviewMouseLeftButtonDown(ChartControl chartControl)
        {
            if (chartControl != null)
            {
                UnsubscribeToPreviewMouseLeftButtonDown(chartControl);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to PreviewMouseLeftButtonDown for " + chartControl);
                WeakEventManager<ChartControl, MouseButtonEventArgs>.AddHandler(chartControl, "PreviewMouseLeftButtonDown", ChartControl_PreviewMouseLeftButtonDown);
            }
        }

        private void UnsubscribeToPreviewMouseLeftButtonDown(ChartControl chartControl)
        {
            if (chartControl != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to PreviewMouseLeftButtonDown for " + chartControl);
                WeakEventManager<ChartControl, MouseButtonEventArgs>.RemoveHandler(chartControl, "PreviewMouseLeftButtonDown", ChartControl_PreviewMouseLeftButtonDown);
            }
        }

        private void SubscribeToPreviewKeyDown(Window chartWindow)
        {
            if (chartWindow != null)
            {
                UnsubscribeToPreviewKeyDown(chartWindow);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to PreviewKeyDown for " + chartWindow);
                WeakEventManager<Window, KeyEventArgs>.AddHandler(chartWindow, "PreviewKeyDown", OnPreviewKeyDown);
            }
        }

        private void UnsubscribeToPreviewKeyDown(Window chartWindow)
        {
            if (chartWindow != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to PreviewKeyDown for " + chartWindow);
                WeakEventManager<Window, KeyEventArgs>.RemoveHandler(chartWindow, "PreviewKeyDown", OnPreviewKeyDown);
            }
        }

        private void SubscribeToButtonClick(System.Windows.Controls.Button button)
        {
            if (button != null)
            {
                UnsubscribeToButtonClick(button);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to ButtonClick for " + button);
                WeakEventManager<System.Windows.Controls.Button, RoutedEventArgs>.AddHandler(button, "Click", OnButtonClick);
            }
        }

        private void UnsubscribeToButtonClick(System.Windows.Controls.Button button)
        {
            if (button != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to ButtonClick for " + button);
                WeakEventManager<System.Windows.Controls.Button, RoutedEventArgs>.RemoveHandler(button, "Click", OnButtonClick);
            }
        }

        private void SubscribeToTimerTick(System.Windows.Threading.DispatcherTimer timer)
        {
            if (timer != null)
            {
                UnsubscribeToTimerTick(timer);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to TimerTick for " + timer);
                WeakEventManager<System.Windows.Threading.DispatcherTimer, EventArgs>.AddHandler(timer, "Tick", OnTimerTick);
            }
        }

        private void UnsubscribeToTimerTick(System.Windows.Threading.DispatcherTimer timer)
        {
            if (timer != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to TimerTick for " + timer);
                WeakEventManager<System.Windows.Threading.DispatcherTimer, EventArgs>.RemoveHandler(timer, "Tick", OnTimerTick);
            }
        }


        private void GetBreakEvenAutoButtonText(TickHunterBreakEvenAutoTypes breakEvenAutoType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string AutoTrailNowText = " (AutoTrailNow)";
            const string DoubleStarText = "**";
            const string AutoTrailNowAfterProfitText = " (AutoTrailNowAfterProfit)";

            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit)
            {
                flagActiveText = DoubleStarText;
                flagActiveTextToolTip = AutoTrailNowAfterProfitText;
            }
            else if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowBeforeBE)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = AutoTrailNowText;
            }

            if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.Enabled)
            {
                buttonText = ToggleAutoBEButtonEnabledText;
                buttonToolTipText = ToggleAutoBEButtonEnabledToolTip;
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.HODL)
            {
                buttonText = ToggleAutoBEHDLButtonEnabledText;
                buttonToolTipText = ToggleAutoBEHDLButtonEnabledToolTip;
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
            {
                buttonText = ToggleCZFTButtonEnabledText;
                buttonToolTipText = ToggleCZFTButtonEnabledToolTip;
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
            {
                buttonText = string.Format(ToggleCFTButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleCFTButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
            {
                buttonText = string.Format(ToggleAutoBET1BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBET1BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
            {
                buttonText = string.Format(ToggleAutoBET2BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBET2BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
            {
                buttonText = string.Format(ToggleAutoBET3BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBET3BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
            {
                buttonText = string.Format(ToggleAutoBET5BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBET5BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMix)
            {
                buttonText = string.Format(ToggleAutoBETMXButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETMXButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailBoss)
            {
                buttonText = string.Format(ToggleAutoBETBSButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETBSButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailZombieFlip)
            {
                buttonText = string.Format(ToggleAutoBETZFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETZFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
            {
                buttonText = string.Format(ToggleAutoBETSLButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETSLButtonEnabledToolTip, flagActiveTextToolTip, this.AutoPilotSpeedLineFilterPeriod);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
            {
                buttonText = string.Format(ToggleAutoBETRLButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETRLButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailRLPeriod);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
            {
                buttonText = string.Format(ToggleAutoBETR1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETR1ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailR1Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
            {
                buttonText = string.Format(ToggleAutoBETR5ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETR5ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailR5Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
            {
                buttonText = string.Format(ToggleAutoBETC1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETC1ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL3Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
            {
                buttonText = string.Format(ToggleAutoBETC5ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETC5ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL4Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
            {
                buttonText = string.Format(ToggleAutoBETKLDButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETKLDButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailZL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
            {
                buttonText = string.Format(ToggleAutoBETZL2ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETZL2ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailZL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
            {
                buttonText = string.Format(ToggleAutoBETZLDButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETZLDButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailZL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
            {
                buttonText = string.Format(ToggleAutoBETKZDButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETKZDButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailZL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailStingRay)
            {
                buttonText = string.Format(ToggleAutoBETSButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETSButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMonster)
            {
                buttonText = string.Format(ToggleAutoBETMButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETMButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
            {
                buttonText = string.Format(ToggleAutoBETDMButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETDMButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
            {
                buttonText = string.Format(ToggleAutoBETM1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETM1ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailMA1Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
            {
                buttonText = string.Format(ToggleAutoBETM2ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETM2ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailMA2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
            {
                buttonText = string.Format(ToggleAutoBETM3ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETM3ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailMA3Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
            {
                buttonText = string.Format(ToggleAutoBETM4ButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETM4ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailMA4Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
            {
                buttonText = string.Format(ToggleAutoBETD1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETD1ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL1Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
            {
                buttonText = string.Format(ToggleAutoBETD2ButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETD2ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
            {
                buttonText = string.Format(ToggleAutoBETD3ButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETD3ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL3Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
            {
                buttonText = string.Format(ToggleAutoBETD4ButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETD4ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL4Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
            {
                buttonText = string.Format(ToggleAutoBETZRButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETZRButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.ProfilePeppy)
            {
                buttonText = string.Format(ToggleAutoBEPLButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBEPLButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.ProfileSleepy)
            {
                buttonText = string.Format(ToggleAutoBEPSButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBEPSButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleAutoBEButtonDisabledText;
                buttonToolTipText = ToggleAutoBEButtonDisabledToolTip;
            }
        }

        private void GetAutoCloseButtonText(TickHunterCloseAutoTypes closeAutoType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string MinProfitText = " (MinProfit)";

            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (closeAutoMinProfitFlag)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = MinProfitText;
            }

            if (closeAutoType == TickHunterCloseAutoTypes.DriftLine4Break)
            {
                buttonText = string.Format(ToggleAutoCloseDL4BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseDL4BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ZombieStackedFlip)
            {
                buttonText = string.Format(ToggleAutoCloseZSFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseZSFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.KLineDualFlip)
            {
                buttonText = string.Format(ToggleAutoCloseKLDFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseKLDFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ZombieFlip)
            {
                buttonText = string.Format(ToggleAutoCloseZFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseZFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ZombieBoostedFlip)
            {
                buttonText = string.Format(ToggleAutoCloseZBFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseZBFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.CreeperFlip)
            {
                buttonText = string.Format(ToggleAutoCloseCFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseCFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ZLineDualFlip)
            {
                buttonText = string.Format(ToggleAutoCloseZLDButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseZLDButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.KZFlip)
            {
                buttonText = string.Format(ToggleAutoCloseKZButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseKZButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.MovingAverage1Slope)
            {
                buttonText = string.Format(ToggleAutoCloseM1SButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseM1SButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.MovingAverage2Slope)
            {
                buttonText = string.Format(ToggleAutoCloseM2SButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseM2SButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.MovingAverage3Slope)
            {
                buttonText = string.Format(ToggleAutoCloseM3SButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseM3SButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.MovingAverage4Break)
            {
                buttonText = string.Format(ToggleAutoCloseM4BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseM4BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ProfilePeppy)
            {
                buttonText = string.Format(ToggleAutoClosePLButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoClosePLButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ProfileSleepy)
            {
                buttonText = string.Format(ToggleAutoClosePSButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoClosePSButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleAutoCloseButtonDisabledText;
                buttonToolTipText = ToggleAutoCloseButtonDisabledToolTip;
            }
        }


        private void GetPopButtonText(TickHunterPopTypes popType, TickHunterPopDelayedTypes popDelayedType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string LimitToPullbackText = " (LimitToPullback)";

            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (popLimitToPullbackFlag)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = LimitToPullbackText;
            }

            if (popType == TickHunterPopTypes.PopPlus)
            {
                if (useBuyPopActivateFlag || !popCTRLDelayedEntryFlag)
                {
                    if (popDelayedType == TickHunterPopDelayedTypes.TradeCount1)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount1Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount1ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount2)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount2Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount2ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount3)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount3Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount3ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount4)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount4Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount4ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount5)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount5Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount5ToolTip, flagActiveTextToolTip);
                    }
                    else
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonDisabledText, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonDisabledToolTip, flagActiveTextToolTip);
                    }
                }
                else
                {
                    buttonText = String.Format(TogglePopBuyButtonText, flagActiveText);
                    buttonToolTipText = String.Format(TogglePopBuyButtonToolTip, flagActiveTextToolTip);
                }

            }
            else if (popType == TickHunterPopTypes.PopMinus)
            {

                if (useSellPopActivateFlag || !popCTRLDelayedEntryFlag)
                {
                    if (popDelayedType == TickHunterPopDelayedTypes.TradeCount1)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount1Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount1ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount2)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount2Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount2ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount3)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount3Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount3ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount4)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount4Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount4ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount5)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount5Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount5ToolTip, flagActiveTextToolTip);
                    }
                    else
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonDisabledText, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonDisabledToolTip, flagActiveTextToolTip);
                    }
                }
                else
                {
                    buttonText = String.Format(TogglePopSellButtonText, flagActiveText);
                    buttonToolTipText = String.Format(TogglePopSellButtonToolTip, flagActiveTextToolTip);
                }
            }
        }

        private void GetAutoPilotProfileButtonText(TickHunterAutoPilotProfileTypes autoPilotProfileType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";

            string flagActiveText = "";

            if (autoPilotProfileAutoAdjustFlag)
            {
                flagActiveText = StarText;
            }

            if (autoPilotProfileType == TickHunterAutoPilotProfileTypes.Peppy)
            {
                buttonText = String.Format(ToggleAutoPPPButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPPPButtonEnabledToolTip, flagActiveText);
            }
            else if (autoPilotProfileType == TickHunterAutoPilotProfileTypes.Sleepy)
            {
                buttonText = String.Format(ToggleAutoPPSButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPPSButtonEnabledToolTip, flagActiveText);
            }
            else
            {
                buttonText = ToggleAutoPPButtonDisabledText;
                buttonToolTipText = ToggleAutoPPButtonDisabledToolTip;
            }
        }

        private void GetAutoPilotButtonText(TickHunterAutoPilotTypes autoPilotType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string AutoPilotAddOnText = " (AutoPilotAddOn)";


            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (useAutoPilotAddOnFlag)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = AutoPilotAddOnText;
            }

            if (autoPilotType == TickHunterAutoPilotTypes.TradeCount1)
            {
                buttonText = String.Format(ToggleAutoPilotCount1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount2)
            {
                buttonText = String.Format(ToggleAutoPilotCount2ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount2ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount3)
            {
                buttonText = String.Format(ToggleAutoPilotCount3ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount3ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount4)
            {
                buttonText = String.Format(ToggleAutoPilotCount4ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount4ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount5)
            {
                buttonText = String.Format(ToggleAutoPilotCount5ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount5ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount6)
            {
                buttonText = String.Format(ToggleAutoPilotCount6ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount6ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount7)
            {
                buttonText = String.Format(ToggleAutoPilotCount7ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount7ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount8)
            {
                buttonText = String.Format(ToggleAutoPilotCount8ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount8ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount9)
            {
                buttonText = String.Format(ToggleAutoPilotCount9ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount9ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount10)
            {
                buttonText = String.Format(ToggleAutoPilotCount10ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount10ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount11)
            {
                buttonText = String.Format(ToggleAutoPilotCount11ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount11ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount12)
            {
                buttonText = String.Format(ToggleAutoPilotCount12ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount12ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount13)
            {
                buttonText = String.Format(ToggleAutoPilotCount13ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount13ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount14)
            {
                buttonText = String.Format(ToggleAutoPilotCount14ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount14ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount15)
            {
                buttonText = String.Format(ToggleAutoPilotCount15ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount15ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount16)
            {
                buttonText = String.Format(ToggleAutoPilotCount16ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount16ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount17)
            {
                buttonText = String.Format(ToggleAutoPilotCount17ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount17ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount18)
            {
                buttonText = String.Format(ToggleAutoPilotCount18ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount18ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount19)
            {
                buttonText = String.Format(ToggleAutoPilotCount19ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount19ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount20)
            {
                buttonText = String.Format(ToggleAutoPilotCount20ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount20ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleAutoPilotButtonDisabledText;
                buttonToolTipText = ToggleAutoPilotButtonDisabledToolTip;
            }

        }

        private void GetAutoPilotLiteButtonText(TickHunterAutoPilotLiteTypes autoPilotLiteType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string AutoPilotAddOnText = " (AutoPilotAddOn)";


            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (useAutoPilotAddOnFlag)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = AutoPilotAddOnText;
            }

            if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.NextSetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteNext1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteNext1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteNextFiltered1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteNextFiltered1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.BuySetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteBuy1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteBuy1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.SellSetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteSell1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteSell1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.AlertSetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteAlertButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteAlertButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleAutoPilotLiteButtonDisabledText;
                buttonToolTipText = ToggleAutoPilotLiteButtonDisabledToolTip;
            }

        }


        private bool HasATMStrategy()
        {
            return !string.IsNullOrEmpty(atmStrategyName);
        }

        private void ValidateInstrument(string instrumentName)
        {
            Instrument instrument = Instrument.GetInstrument(instrumentName);
            if (instrument != null)
            {
                RealLogger.PrintOutput("Instrument =" + instrument.FullName + " Tick Size=" + Convert.ToString(instrument.MasterInstrument.TickSize) + " Tick Value=" + Convert.ToString(RealInstrumentService.GetTickValue(instrument)), PrintTo.OutputTab2);
            }
        }

        private string GetCurrentFuturesMonthYearPrefix()
        {
            string tempText = null;

            if (attachedInstrumentIsFuture)
            {
                tempText = this.attachedInstrument.FullName.Substring(this.attachedInstrument.MasterInstrument.Name.Length, 6);
            }
            return tempText;
        }

        /*
        private bool IsCtrlKeyDown()
        {
            bool returnFlag = false;

            if (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool IsShiftKeyDown()
        {
            bool returnFlag = false;

            if (Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift))
            {
                returnFlag = true;
            }

            return returnFlag;
        }
        */

        #region Properties

        [NinjaScriptProperty]
        [Display(Name = "IndicatorName", Order = 0, GroupName = "0) Indicator Information")]
        public string IndicatorName
        {
            get { return FullSystemName; }
            set { }
        }

        [NinjaScriptProperty]
        [Display(Name = "IndicatorTermsOfUse", Description = SystemDescription, Order = 1, GroupName = "0) Indicator Information")]
        public string IndicatorTermsOfUse
        {
            get { return SystemDescription; }
            set { }
        }

        [NinjaScriptProperty]
        [Display(Name = "ShowIndicatorName", Order = 2, GroupName = "0) Indicator Information")]
        public bool ShowIndicatorName
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "IndicatorInfoLink", Order = 2, GroupName = "0) Indicator Information")]
        public string IndicatorInfoLink
        {
            get { return InfoLink; }
            set { }
        }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPositionStopLoss", Order = 0, GroupName = "01) Stop Loss Settings")]
        public bool UseAutoPositionStopLoss
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "StopLossInitialTicks", Order = 1, GroupName = "01) Stop Loss Settings")]
        public int StopLossInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "StopLossInitialATRMultiplier", Order = 2, GroupName = "01) Stop Loss Settings")]
        public double StopLossInitialATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossInitialSnapType", Order = 3, GroupName = "01) Stop Loss Settings")]
        public TickHunterStopLossSnapTypes StopLossInitialSnapType
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "StopLossInitialMaxTicks", Order = 4, GroupName = "01) Stop Loss Settings")]
        public int StopLossInitialMaxTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "StopLossInitialDollars", Order = 5, GroupName = "01) Stop Loss Settings")]
        public double StopLossInitialDollars
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossInitialDollarsCombined", Order = 6, GroupName = "01) Stop Loss Settings")]
        public bool StopLossInitialDollarsCombined
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "StopLossJumpTicks", Order = 7, GroupName = "01) Stop Loss Settings")]
        public int StopLossJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossCTRLJumpTicks", Order = 8, GroupName = "01) Stop Loss Settings")]
        public bool StopLossCTRLJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossRefreshOnVolumeChange", Order = 9, GroupName = "01) Stop Loss Settings")]
        public bool StopLossRefreshOnVolumeChange
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossRefreshManagementEnabled ", Order = 10, GroupName = "01) Stop Loss Settings")]
        public bool StopLossRefreshManagementEnabled
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPositionTakeProfit", Order = 0, GroupName = "02) Take Profit Settings")]
        public bool UseAutoPositionTakeProfit
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "TakeProfitInitialTicks", Order = 1, GroupName = "02) Take Profit Settings")]
        public int TakeProfitInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "TakeProfitInitialATRMultiplier", Order = 2, GroupName = "02) Take Profit Settings")]
        public double TakeProfitInitialATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "TakeProfitSyncBogeyTargetPrice", Order = 3, GroupName = "02) Take Profit Settings")]
        public bool TakeProfitSyncBogeyTargetPrice
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "TakeProfitSyncECATargetPrice", Order = 4, GroupName = "02) Take Profit Settings")]
        public bool TakeProfitSyncECATargetPrice
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "TakeProfitJumpTicks", Order = 5, GroupName = "02) Take Profit Settings")]
        public int TakeProfitJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.1, double.MaxValue)]
        [Display(Name = "TakeProfitCtrlSLMultiplier", Order = 6, GroupName = "02) Take Profit Settings")]
        public double TakeProfitCtrlSLMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "TakeProfitRefreshManagementEnabled", Order = 7, GroupName = "02) Take Profit Settings")]
        public bool TakeProfitRefreshManagementEnabled
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "AutoPositionBreakEvenType", Order = 0, GroupName = "03) Break-Even Settings")]
        public TickHunterBreakEvenAutoTypes AutoPositionBreakEvenType
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "BreakEvenInitialTicks", Order = 1, GroupName = "03) Break-Even Settings")]
        public int BreakEvenInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "BreakEvenJumpTicks", Order = 2, GroupName = "03) Break-Even Settings")]
        public int BreakEvenJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "BreakEvenTurboJumpTicks", Order = 3, GroupName = "03) Break-Even Settings")]
        public int BreakEvenTurboJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "BreakEvenAutoTrailNow", Order = 4, GroupName = "03) Break-Even Settings")]
        public TickHunterBreakEvenAutoTrailNowTypes BreakEvenAutoTrailNow
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "BreakEvenAutoTriggerTicks", Order = 6, GroupName = "03) Break-Even Settings")]
        public int BreakEvenAutoTriggerTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "BreakEvenAutoTriggerATRMultiplier", Order = 7, GroupName = "03) Break-Even Settings")]
        public double BreakEvenAutoTriggerATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "BreakEvenAutoZombieFlipResumeSnapType", Order = 8, GroupName = "03) Break-Even Settings")]
        public TickHunterStopLossSnapTypes BreakEvenAutoZombieFlipResumeSnapType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "BreakEvenAutoCreeperFlipSnapType", Order = 9, GroupName = "03) Break-Even Settings")]
        public TickHunterStopLossSnapTypes BreakEvenAutoCreeperFlipSnapType
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UseIntradayMarginCheck", Order = 0, GroupName = "04) Buy/Sell Settings")]
        public bool UseIntradayMarginCheck
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "LimitToVolumeMaxOption", Order = 1, GroupName = "04) Buy/Sell Settings")]
        public bool LimitToVolumeMaxOption
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption1", Order = 2, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption1
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption2", Order = 3, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption2
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption3", Order = 4, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption3
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption4", Order = 5, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption4
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption5", Order = 6, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption5
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "LimitTrancheVolumeToInProfit", Order = 7, GroupName = "04) Buy/Sell Settings")]
        public bool LimitTrancheVolumeToInProfit
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "MaxInitialTrancheVolumeSize", Order = 8, GroupName = "04) Buy/Sell Settings")]
        public int MaxInitialTrancheVolumeSize
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "LimitTrancheVolumePerBar", Order = 10, GroupName = "04) Buy/Sell Settings")]
        public bool LimitTrancheVolumePerBar
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "MinTrancheVolumeDelaySeconds", Order = 11, GroupName = "04) Buy/Sell Settings")]
        public int MinTrancheVolumeDelaySeconds
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePopCTRLDelayedEntry", Order = 0, GroupName = "05) Pop/Drop Settings")]
        public bool UsePopCTRLDelayedEntry
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePopLimitToPullback", Order = 1, GroupName = "05) Pop/Drop Settings")]
        public bool UsePopLimitToPullback
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, 5)]
        [Display(Name = "PopDelayedEntryMaxCount", Order = 2, GroupName = "05) Pop/Drop Settings")]
        public int PopDelayedEntryMaxCount
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "PopInitialTicks", Order = 3, GroupName = "05) Pop/Drop Settings")]
        public int PopInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "PopInitialATRMultiplier", Order = 4, GroupName = "05) Pop/Drop Settings")]
        public double PopInitialATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "PopJumpTicks", Order = 5, GroupName = "05) Pop/Drop Settings")]
        public int PopJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePopAutoJumpToSnap", Order = 6, GroupName = "05) Pop/Drop Settings")]
        public bool UsePopAutoJumpToSnap
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "DropInitialTicks", Order = 7, GroupName = "05) Pop/Drop Settings")]
        public int DropInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DropInitialATRMultiplier", Order = 8, GroupName = "05) Pop/Drop Settings")]
        public double DropInitialATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "DropJumpTicks", Order = 9, GroupName = "05) Pop/Drop Settings")]
        public int DropJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseDropAutoJumpToSnap", Order = 10, GroupName = "05) Pop/Drop Settings")]
        public bool UseDropAutoJumpToSnap
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePopDropOnBarUpdateDelay", Order = 11, GroupName = "05) Pop/Drop Settings")]
        public bool UsePopDropOnBarUpdateDelay
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, long.MaxValue)]
        [Display(Name = "PopDropThrottleMilliseconds", Order = 12, GroupName = "05) Pop/Drop Settings")]
        public long PopDropThrottleMilliseconds
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "AutoEntryVolumeType", Order = 0, GroupName = "06) Volume Settings")]
        public TickHunterEntryVolumeAutoTypes AutoEntryVolumeType
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption1", Order = 1, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption1
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption2", Order = 2, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption2
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption3", Order = 3, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption3
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption4", Order = 4, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption4
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption5", Order = 5, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption5
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "AutoPilotOrderType", Order = 0, GroupName = "07) AutoPilot Settings")]
        public TickHunterAutoPilotOrderTypes AutoPilotOrderType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "AutoPilotTradeSignalType", Order = 1, GroupName = "07) AutoPilot Settings")]
        public TickHunterTradeSignalTypes AutoPilotTradeSignalType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "AutoPilotSetupTypes", Order = 2, GroupName = "07) AutoPilot Settings")]
        public TickHunterAutoPilotSetupTypes AutoPilotSetupType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPilotLite", Order = 4, GroupName = "07) AutoPilot Settings")]
        public bool UseAutoPilotLite
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPilotAddOn", Order = 5, GroupName = "07) AutoPilot Settings")]
        public bool UseAutoPilotAddOn
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "AutoPilotMaxVolume", Order = 6, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPilotSpeedLineFilter", Order = 7, GroupName = "07) AutoPilot Settings")]
        public bool UseAutoPilotSpeedLineFilter
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSpeedLineFilterPeriod", Order = 8, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSpeedLineFilterPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupFilterPeriod", Order = 9, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupFilterPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupZombiePeriod", Order = 10, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupZombiePeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "AutoPilotSetupZombieMultiplier", Order = 11, GroupName = "07) AutoPilot Settings")]
        public double AutoPilotSetupZombieMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupCreeperPeriod1", Order = 12, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupCreeperPeriod1
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupCreeperPeriod2", Order = 13, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupCreeperPeriod2
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupCreeperPeriod3", Order = 14, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupCreeperPeriod3
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupWalkerPeriod", Order = 15, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupWalkerPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "AutoPilotSetupWalkerFreshCrossOnly", Order = 16, GroupName = "07) AutoPilot Settings")]
        public bool AutoPilotSetupWalkerFreshCrossOnly
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "AutoPilotProfileSetupTypes", Order = 0, GroupName = "08) AutoPilot Profile Settings")]
        public TickHunterAutoPilotProfileSetupTypes AutoPilotProfileSetupType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePeppyLimitPopDelayedEntry", Order = 1, GroupName = "08) AutoPilot Profile Settings")]
        public bool UsePeppyLimitPopDelayedEntry
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePeppyLimitPopToPullback", Order = 2, GroupName = "08) AutoPilot Profile Settings")]
        public bool UsePeppyLimitPopToPullback
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePeppyLimitPopAlignedCreeper", Order = 3, GroupName = "08) AutoPilot Profile Settings")]
        public bool UsePeppyLimitPopAlignedCreeper
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePeppyLimitPopAlignedRushLine", Order = 4, GroupName = "08) AutoPilot Profile Settings")]
        public bool UsePeppyLimitPopAlignedRushLine
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseSleepyLimitPopDelayedEntry", Order = 5, GroupName = "08) AutoPilot Profile Settings")]
        public bool UseSleepyLimitPopDelayedEntry
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseSleepyLimitPopToPullback", Order = 6, GroupName = "08) AutoPilot Profile Settings")]
        public bool UseSleepyLimitPopToPullback
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseSleepyLimitPopCounterCreeper", Order = 7, GroupName = "08) AutoPilot Profile Settings")]
        public bool UseSleepyLimitPopCounterCreeper
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseSleepyLimitPopCounterRushLine", Order = 8, GroupName = "08) AutoPilot Profile Settings")]
        public bool UseSleepyLimitPopCounterRushLine
        { get; set; }



        [NinjaScriptProperty]
        [Display(Name = "AutoPositionCloseType", Order = 0, GroupName = "09) Auto Close Settings")]
        public TickHunterCloseAutoTypes AutoPositionCloseType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoCloseMinProfit", Order = 1, GroupName = "09) Auto Close Settings")]
        public bool UseAutoCloseMinProfit
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "AutoCloseMinProfitDollarsPerVolume", Order = 2, GroupName = "09) Auto Close Settings")]
        public double AutoCloseMinProfitDollarsPerVolume
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoCloseAlert", Order = 3, GroupName = "09) Auto Close Settings")]
        public bool UseAutoCloseAlert
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailOffsetTicks", Order = 4, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailOffsetTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailMA1Period", Order = 5, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailMA1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailMA2Period", Order = 6, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailMA2Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailMA3Period", Order = 7, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailMA3Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailMA4Period", Order = 8, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailMA4Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailZL1Period", Order = 9, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailZL1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailZL2Period", Order = 10, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailZL2Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailZL3Period", Order = 10, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailZL3Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailZL4Period", Order = 10, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailZL4Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailRLPeriod", Order = 11, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailRLPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailDL1Period", Order = 12, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailDL1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailDL2Period", Order = 13, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailDL2Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailDL3Period", Order = 14, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailDL3Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailDL4Period", Order = 15, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailDL4Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailR1Period", Order = 16, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailR1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailR5Period", Order = 17, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailR5Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailKLine1Period", Order = 18, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailKLine1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "AutoCloseAndTrailKLine1Multiplier", Order = 19, GroupName = "09) Auto Close Settings")]
        public double AutoCloseAndTrailKLine1Multiplier
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailKLine2Period", Order = 20, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailKLine2Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "AutoCloseAndTrailKLine2Multiplier", Order = 21, GroupName = "09) Auto Close Settings")]
        public double AutoCloseAndTrailKLine2Multiplier
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "BogeyTargetStartWithFullPnL", Order = 0, GroupName = "10) Bogey Target Settings")]
        public bool BogeyTargetStartWithFullPnL
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "BogeyTargetBaseDollars", Order = 1, GroupName = "10) Bogey Target Settings")]
        public double BogeyTargetBaseDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.0, double.MaxValue)]
        [Display(Name = "BogeyTargetDailyBaseDollars", Order = 2, GroupName = "10) Bogey Target Settings")]
        public double BogeyTargetDailyBaseDollars
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDailyBreakEvenLine", Order = 3, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDailyBreakEvenLine
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily1Line", Order = 4, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily1Line
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily2Line", Order = 5, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily2Line
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily3Line", Order = 6, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily3Line
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily4Line", Order = 7, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily4Line
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily5Line", Order = 8, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily5Line
        { get; set; }


        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "ECATargetDollars", Order = 0, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerOtherVolume", Order = 1, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerOtherVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerMNQVolume", Order = 3, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerMNQVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerNQVolume", Order = 4, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerNQVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerM2KVolume", Order = 5, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerM2KVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerRTYVolume", Order = 6, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerRTYVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerMESVolume", Order = 7, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerMESVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerESVolume", Order = 8, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerESVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerMYMVolume", Order = 9, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerMYMVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerYMVolume", Order = 10, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerYMVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "ECATargetATRMultiplierPerVolume", Order = 11, GroupName = "11) ECA Target Settings")]
        public double ECATargetATRMultiplierPerVolume
        { get; set; }


        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "AutoAddOnMaxDollars", Order = 0, GroupName = "12) Auto Entry Settings")]
        public double AutoAddOnMaxDollars
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UseDayOverMaxLossTrailing", Order = 0, GroupName = "13) Account Risk Settings")]
        public bool UseDayOverMaxLossTrailing
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DayOverMaxLossDollars", Order = 1, GroupName = "13) Account Risk Settings")]
        public double DayOverMaxLossDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DayOverMaxLossBTBaseRatio", Order = 2, GroupName = "13) Account Risk Settings")]
        public double DayOverMaxLossBTBaseRatio
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DayOverMaxAccountPnLPeakDollars", Order = 3, GroupName = "13) Account Risk Settings")]
        public double DayOverMaxAccountPnLPeakDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DayOverAccountBalanceFloorDollars", Order = 4, GroupName = "13) Account Risk Settings")]
        public double DayOverAccountBalanceFloorDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "ECAMaxDDInDollars", Order = 5, GroupName = "13) Account Risk Settings")]
        public double ECAMaxDDInDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "ExcessIntradayMarginMinDollars", Order = 6, GroupName = "13) Account Risk Settings")]
        public double ExcessIntradayMarginMinDollars
        { get; set; }

        [Display(ResourceType = typeof(Custom.Resource), Name = "PlaySoundOnSetupAlert", Order = 0, GroupName = "14) Sound Alert Settings")]
        public bool PlaySoundOnSetupAlert
        {
            get; set;
        }

        [Display(ResourceType = typeof(Custom.Resource), Name = "SoundFile", Order = 1, GroupName = "14) Sound Alert Settings")]
        [PropertyEditor("NinjaTrader.Gui.Tools.FilePathPicker", Filter = "Any Files (*.wav)|*.wav")]
        public string SoundFile
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoBreakEven", Order = 1, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoBreakEven
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonReverse", Order = 2, GroupName = "15) Button Settings")]
        public bool ShowButtonReverse
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonClose", Order = 3, GroupName = "15) Button Settings")]
        public bool ShowButtonClose
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoClose", Order = 4, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoClose
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonProfitTarget", Order = 5, GroupName = "15) Button Settings")]
        public bool ShowButtonProfitTarget
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonTPPlus", Order = 6, GroupName = "15) Button Settings")]
        public bool ShowButtonTPPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonBEPlus", Order = 7, GroupName = "15) Button Settings")]
        public bool ShowButtonBEPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonSLPlus", Order = 8, GroupName = "15) Button Settings")]
        public bool ShowButtonSLPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonBuyMarket", Order = 9, GroupName = "15) Button Settings")]
        public bool ShowButtonBuyMarket
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonSellMarket", Order = 10, GroupName = "15) Button Settings")]
        public bool ShowButtonSellMarket
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonPopPlus", Order = 11, GroupName = "15) Button Settings")]
        public bool ShowButtonPopPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonPopMinus", Order = 12, GroupName = "15) Button Settings")]
        public bool ShowButtonPopMinus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonDropMinus", Order = 13, GroupName = "15) Button Settings")]
        public bool ShowButtonDropMinus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonDropPlus", Order = 14, GroupName = "15) Button Settings")]
        public bool ShowButtonDropPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoAddOn", Order = 15, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoAddOn
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonTradeSignal", Order = 16, GroupName = "15) Button Settings")]
        public bool ShowButtonTradeSignal
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoPilotProfile", Order = 17, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoPilotProfile
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoPilot", Order = 18, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoPilot
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonVolumeMax", Order = 19, GroupName = "15) Button Settings")]
        public bool ShowButtonVolumeMax
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonVolume", Order = 20, GroupName = "15) Button Settings")]
        public bool ShowButtonVolume
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UseBlendedInstruments", Order = 0, GroupName = "16) Instrument Settings")]
        public bool UseBlendedInstruments
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "ShowAveragePriceLine", Order = 1, GroupName = "16) Instrument Settings")]
        public bool ShowAveragePriceLine
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowAveragePriceLineQuantity", Order = 2, GroupName = "16) Instrument Settings")]
        public bool ShowAveragePriceLineQuantity
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowAveragePriceLineQuantityInMicros", Order = 3, GroupName = "16) Instrument Settings")]
        public bool ShowAveragePriceLineQuantityInMicros
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 4, GroupName = "16) Instrument Settings")]
        public double OtherCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 5, GroupName = "16) Instrument Settings")]
        public double OtherIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 6, GroupName = "16) Instrument Settings")]
        public int OtherPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 7, GroupName = "16) Instrument Settings")]
        public double MNQCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 8, GroupName = "16) Instrument Settings")]
        public double MNQIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 9, GroupName = "16) Instrument Settings")]
        public int MNQPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 10, GroupName = "16) Instrument Settings")]
        public double NQCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 11, GroupName = "16) Instrument Settings")]
        public double NQIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 12, GroupName = "16) Instrument Settings")]
        public int NQPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 13, GroupName = "16) Instrument Settings")]
        public double MESCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 14, GroupName = "16) Instrument Settings")]
        public double MESIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 15, GroupName = "16) Instrument Settings")]
        public int MESPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 16, GroupName = "16) Instrument Settings")]
        public double ESCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 17, GroupName = "16) Instrument Settings")]
        public double ESIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 18, GroupName = "16) Instrument Settings")]
        public int ESPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 19, GroupName = "16) Instrument Settings")]
        public double MYMCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 20, GroupName = "16) Instrument Settings")]
        public double MYMIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 21, GroupName = "16) Instrument Settings")]
        public int MYMPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 22, GroupName = "16) Instrument Settings")]
        public double YMCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 23, GroupName = "16) Instrument Settings")]
        public double YMIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 24, GroupName = "16) Instrument Settings")]
        public int YMPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 25, GroupName = "16) Instrument Settings")]
        public double M2KCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 26, GroupName = "16) Instrument Settings")]
        public double M2KIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 27, GroupName = "16) Instrument Settings")]
        public int M2KPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 28, GroupName = "16) Instrument Settings")]
        public double RTYCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 29, GroupName = "16) Instrument Settings")]
        public double RTYIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 30, GroupName = "16) Instrument Settings")]
        public int RTYPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "IgnoreInstrumentServerSupport", Order = 31, GroupName = "16) Instrument Settings")]
        public bool IgnoreInstrumentServerSupport
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseHotKeys", Order = 0, GroupName = "17) HotKey Settings")]
        public bool UseHotKeys
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "BuyMarketHotKey", Order = 1, GroupName = "17) HotKey Settings")]
        public string BuyMarketHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "SellMarketHotKey", Order = 2, GroupName = "17) HotKey Settings")]
        public string SellMarketHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "BuyPopHotKey", Order = 3, GroupName = "17) HotKey Settings")]
        public string BuyPopHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "SellPopHotKey", Order = 4, GroupName = "17) HotKey Settings")]
        public string SellPopHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "CloseHotKey", Order = 5, GroupName = "17) HotKey Settings")]
        public string CloseHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "ReverseHotKey", Order = 6, GroupName = "17) HotKey Settings")]
        public string ReverseHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "BreakEvenPlusHotKey", Order = 7, GroupName = "17) HotKey Settings")]
        public string BreakEvenPlusHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "StopLossPlusHotKey", Order = 8, GroupName = "17) HotKey Settings")]
        public string StopLossPlusHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "VolumeHotKey", Order = 9, GroupName = "17) HotKey Settings")]
        public string VolumeHotKey
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterHotKeyValueConverter))]
        [Display(Name = "ActivateHotKey", Order = 10, GroupName = "17) HotKey Settings")]
        public string ActivateHotKey
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseHordeTradeCopier", Order = 1, GroupName = "18) Horde Settings")]
        public bool UseHordeTradeCopier
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount1", Order = 2, GroupName = "18) Horde Settings")]
        public string FollowerAccount1
        { 
            get {return followerAccount1Prop;}
            set {followerAccount1Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower1TradeSize", Order = 3, GroupName = "18) Horde Settings")]
        public string Follower1TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount2", Order = 4, GroupName = "18) Horde Settings")]
        public string FollowerAccount2
        { 
            get {return followerAccount2Prop;}
            set {followerAccount2Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower2TradeSize", Order = 5, GroupName = "18) Horde Settings")]
        public string Follower2TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount3", Order = 6, GroupName = "18) Horde Settings")]
        public string FollowerAccount3
        { 
            get {return followerAccount3Prop;}
            set {followerAccount3Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower3TradeSize", Order = 7, GroupName = "18) Horde Settings")]
        public string Follower3TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount4", Order = 8, GroupName = "18) Horde Settings")]
        public string FollowerAccount4
        { 
            get {return followerAccount4Prop;}
            set {followerAccount4Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower4TradeSize", Order = 9, GroupName = "18) Horde Settings")]
        public string Follower4TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount5", Order = 10, GroupName = "18) Horde Settings")]
        public string FollowerAccount5
        { 
            get {return followerAccount5Prop;}
            set {followerAccount5Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower5TradeSize", Order = 11, GroupName = "18) Horde Settings")]
        public string Follower5TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount6", Order = 12, GroupName = "18) Horde Settings")]
        public string FollowerAccount6
        { 
            get {return followerAccount6Prop;}
            set {followerAccount6Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower6TradeSize", Order = 13, GroupName = "18) Horde Settings")]
        public string Follower6TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount7", Order = 14, GroupName = "18) Horde Settings")]
        public string FollowerAccount7
        { 
            get {return followerAccount7Prop;}
            set {followerAccount7Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower7TradeSize", Order = 15, GroupName = "18) Horde Settings")]
        public string Follower7TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount8", Order = 16, GroupName = "18) Horde Settings")]
        public string FollowerAccount8
        { 
            get {return followerAccount8Prop;}
            set {followerAccount8Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower8TradeSize", Order = 17, GroupName = "18) Horde Settings")]
        public string Follower8TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount9", Order = 18, GroupName = "18) Horde Settings")]
        public string FollowerAccount9
        { 
            get {return followerAccount9Prop;}
            set {followerAccount9Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower9TradeSize", Order = 19, GroupName = "18) Horde Settings")]
        public string Follower9TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount10", Order = 20, GroupName = "18) Horde Settings")]
        public string FollowerAccount10
        { 
            get {return followerAccount10Prop;}
            set {followerAccount10Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower10TradeSize", Order = 21, GroupName = "18) Horde Settings")]
        public string Follower10TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount11", Order = 22, GroupName = "18) Horde Settings")]
        public string FollowerAccount11
        { 
            get {return followerAccount11Prop;}
            set {followerAccount11Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower11TradeSize", Order = 23, GroupName = "18) Horde Settings")]
        public string Follower11TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount12", Order = 24, GroupName = "18) Horde Settings")]
        public string FollowerAccount12
        { 
            get {return followerAccount12Prop;}
            set {followerAccount12Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower12TradeSize", Order = 25, GroupName = "18) Horde Settings")]
        public string Follower12TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount13", Order = 26, GroupName = "18) Horde Settings")]
        public string FollowerAccount13
        { 
            get {return followerAccount13Prop;}
            set {followerAccount13Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower13TradeSize", Order = 27, GroupName = "18) Horde Settings")]
        public string Follower13TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount14", Order = 28, GroupName = "18) Horde Settings")]
        public string FollowerAccount14
        { 
            get {return followerAccount14Prop;}
            set {followerAccount14Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower14TradeSize", Order = 29, GroupName = "18) Horde Settings")]
        public string Follower14TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount15", Order = 30, GroupName = "18) Horde Settings")]
        public string FollowerAccount15
        { 
            get {return followerAccount15Prop;}
            set {followerAccount15Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower15TradeSize", Order = 31, GroupName = "18) Horde Settings")]
        public string Follower15TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount16", Order = 32, GroupName = "18) Horde Settings")]
        public string FollowerAccount16
        { 
            get {return followerAccount16Prop;}
            set {followerAccount16Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower16TradeSize", Order = 33, GroupName = "18) Horde Settings")]
        public string Follower16TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount17", Order = 34, GroupName = "18) Horde Settings")]
        public string FollowerAccount17
        { 
            get {return followerAccount17Prop;}
            set {followerAccount17Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower17TradeSize", Order = 35, GroupName = "18) Horde Settings")]
        public string Follower17TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount18", Order = 36, GroupName = "18) Horde Settings")]
        public string FollowerAccount18
        { 
            get {return followerAccount18Prop;}
            set {followerAccount18Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower18TradeSize", Order = 37, GroupName = "18) Horde Settings")]
        public string Follower18TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount19", Order = 38, GroupName = "18) Horde Settings")]
        public string FollowerAccount19
        { 
            get {return followerAccount19Prop;}
            set {followerAccount19Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower19TradeSize", Order = 39, GroupName = "18) Horde Settings")]
        public string Follower19TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount20", Order = 40, GroupName = "18) Horde Settings")]
        public string FollowerAccount20
        { 
            get {return followerAccount20Prop;}
            set {followerAccount20Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower20TradeSize", Order = 41, GroupName = "18) Horde Settings")]
        public string Follower20TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount21", Order = 42, GroupName = "18) Horde Settings")]
        public string FollowerAccount21
        { 
            get {return followerAccount21Prop;}
            set {followerAccount21Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower21TradeSize", Order = 43, GroupName = "18) Horde Settings")]
        public string Follower21TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount22", Order = 44, GroupName = "18) Horde Settings")]
        public string FollowerAccount22
        { 
            get {return followerAccount22Prop;}
            set {followerAccount22Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower22TradeSize", Order = 45, GroupName = "18) Horde Settings")]
        public string Follower22TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount23", Order = 46, GroupName = "18) Horde Settings")]
        public string FollowerAccount23
        { 
            get {return followerAccount23Prop;}
            set {followerAccount23Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower23TradeSize", Order = 47, GroupName = "18) Horde Settings")]
        public string Follower23TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterAccountNameConverter))]
        [Display(Name = "FollowerAccount24", Order = 48, GroupName = "18) Horde Settings")]
        public string FollowerAccount24
        { 
            get {return followerAccount24Prop;}
            set {followerAccount24Prop = value ?? string.Empty;}
        }

        [NinjaScriptProperty]
        [TypeConverter(typeof(NinjaTrader.NinjaScript.Indicators.TickHunterTA.TickHunterFollowerTradeSizeValueConverter))]
        [Display(Name = "Follower24TradeSize", Order = 49, GroupName = "18) Horde Settings")]
        public string Follower24TradeSize
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "SnapOffsetTicks", Order = 0, GroupName = "19) Misc Settings")]
        public int SnapOffsetTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(2, int.MaxValue)]
        [Display(Name = "SnapPowerBoxPeriod", Order = 1, GroupName = "19) Misc Settings")]
        public int SnapPowerBoxPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "SnapPowerBoxAutoAdjustPeriodsOnM1", Order = 2, GroupName = "19) Misc Settings")]
        public bool SnapPowerBoxAutoAdjustPeriodsOnM1
        { get; set; }

        [NinjaScriptProperty]
        [Range(2, int.MaxValue)]
        [Display(Name = "ATRPeriod", Order = 3, GroupName = "19) Misc Settings")]
        public int ATRPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "RefreshTPSLOffsetTicks", Order = 4, GroupName = "19) Misc Settings")]
        public int RefreshTPSLOffsetTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "StopLossAddOnDelaySeconds", Description = "Delay stop loss order quantity updates when position increases by X seconds to batch position changes. Only applies when adding to existing position. 0 = immediate, >0 = delay (e.g., 5).", Order = 5, GroupName = "19) Misc Settings")]
        public int StopLossAddOnDelaySeconds
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "TakeProfitAddOnDelaySeconds", Description = "Delay take profit order quantity updates when position increases by X seconds to batch position changes. Only applies when adding to existing position. 0 = immediate, >0 = delay (e.g., 5).", Order = 6, GroupName = "19) Misc Settings")]
        public int TakeProfitAddOnDelaySeconds
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "SingleOrderChunkMaxQuantity", Order = 7, GroupName = "19) Misc Settings")]
        public int SingleOrderChunkMaxQuantity
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "SingleOrderChunkMinQuantity", Order = 8, GroupName = "19) Misc Settings")]
        public int SingleOrderChunkMinQuantity
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "SingleOrderChunkDelayMilliseconds", Order = 9, GroupName = "19) Misc Settings")]
        public int SingleOrderChunkDelayMilliseconds
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, long.MaxValue)]
        [Display(Name = "RealTimePipeLineThrottleMilliseconds", Order = 10, GroupName = "19) Misc Settings")]
        public long RealTimePipeLineThrottleMilliseconds
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UsePositionProfitLogging", Order = 1, GroupName = "20) Output Log Settings")]
        public bool UsePositionProfitLogging
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "DebugLogLevel", Order = 2, GroupName = "20) Output Log Settings")]
        public int DebugLogLevel
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "OrderWaitOutputThrottleSeconds", Order = 3, GroupName = "20) Output Log Settings")]
        public int OrderWaitOutputThrottleSeconds
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAccountInfoLogging", Order = 1, GroupName = "21) Account Logging Settings")]
        public bool UseAccountInfoLogging
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "AccountInfoLoggingPath", Order = 2, GroupName = "21) Account Logging Settings")]
        public string AccountInfoLoggingPath
        { get; set; }


        #endregion

    }
    
    public class TickHunterAccountNameConverter : StringConverter
    {
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            return true; // enables dropdown
        }

        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return true; // true = dropdown only, no free text
        }

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            return sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value != null)
                return value.ToString();
            else
                return string.Empty;
        }

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            List<string> names = new List<string> { string.Empty };

            // Guard against null context (common in NT8 property grid scenarios)
            if (context == null || Account.All == null)
            {
                return new StandardValuesCollection(names);
            }

            // Filter accounts: connection must be connected
            foreach (Account acc in Account.All)
            {
                if (acc != null 
                    && acc.ConnectionStatus == ConnectionStatus.Connected 
                    && !string.IsNullOrEmpty(acc.DisplayName))
                {
                    names.Add(acc.DisplayName);
                }
            }

            // Sort A-Z (keep blank at top)
            if (names.Count > 1)
            {
                List<string> sorted = new List<string>(names);
                sorted.RemoveAt(0);
                sorted.Sort(StringComparer.OrdinalIgnoreCase);
                sorted.Insert(0, string.Empty);
                names = sorted;
            }

            return new StandardValuesCollection(names);
        }
    }

    public class TickHunterFollowerTradeSizeValueConverter : StringConverter
    {
        private const string Separator = "|"; // Separator between display and value

        // Display values shown in properties dropdown
        private static readonly string[] DisplayValues = new string[]
        {
            "",
            "1 leader (same instrument)",
            "2 leader (same instrument)",
            "4 leader (same instrument)",
            "6 leader (same instrument)",
            "8 leader (same instrument)",
            "10 leader (same instrument)",
            "20 leader (same instrument)",
            "1 leader (cross to E-mini)",
            "2 leader (cross to E-mini)",
            "3 leader (cross to E-mini)",
            "5 leader (cross to E-mini)",
            "10 leader (cross to E-mini)",
            "20 leader (cross to E-mini)"
        };

        // Internal values for fast parsing: format is "multiplierxS" (same) or "multiplierxC" (cross)
        private static readonly string[] InternalValues = new string[]
        {
            "",
            "1xS",
            "2xS",
            "4xS",
            "6xS",
            "8xS",
            "10xS",
            "20xS",
            "1xC",
            "2xC",
            "3xC",
            "5xC",
            "10xC",
            "20xC"
        };

        // Dictionary for fast lookup: display value -> combined value
        private static readonly Dictionary<string, string> DisplayToCombined = new Dictionary<string, string>();
        // Dictionary for fast lookup: internal value -> combined value
        private static readonly Dictionary<string, string> InternalToCombined = new Dictionary<string, string>();

        static TickHunterFollowerTradeSizeValueConverter()
        {
            // Initialize dictionaries for fast conversion - generate combined format on the fly
            for (int i = 0; i < DisplayValues.Length && i < InternalValues.Length; i++)
            {
                string combined = DisplayValues[i] + Separator + InternalValues[i];
                DisplayToCombined[DisplayValues[i]] = combined;
                InternalToCombined[InternalValues[i]] = combined;
            }
        }

        // Helper method to extract display part from combined value
        public static string GetDisplayValue(string combinedValue)
        {
            if (string.IsNullOrEmpty(combinedValue))
                return "";

            int separatorIndex = combinedValue.IndexOf(Separator);
            if (separatorIndex >= 0)
                return combinedValue.Substring(0, separatorIndex);
            
            // If no separator, check if it's a display value
            if (DisplayToCombined.ContainsKey(combinedValue))
                return combinedValue;
            
            return combinedValue; // Fallback
        }

        // Helper method to extract internal value part from combined value
        public static string GetInternalValue(string combinedValue)
        {
            if (string.IsNullOrEmpty(combinedValue))
                return "";

            int separatorIndex = combinedValue.IndexOf(Separator);
            if (separatorIndex >= 0 && separatorIndex < combinedValue.Length - 1)
                return combinedValue.Substring(separatorIndex + 1);
            
            // If no separator, check if it's an internal value
            if (InternalToCombined.ContainsKey(combinedValue))
                return combinedValue;
            
            // Try to convert display value to internal
            if (DisplayToCombined.TryGetValue(combinedValue, out string combined))
            {
                int idx = combined.IndexOf(Separator);
                if (idx >= 0 && idx < combined.Length - 1)
                    return combined.Substring(idx + 1);
            }
            
            return ""; // Fallback
        }

        // Helper method to get default display value (second option from list)
        public static string GetDefaultDisplayValue()
        {
            return DisplayValues.Length > 1 ? DisplayValues[1] : "";
        }

        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            return true; // enables dropdown
        }

        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return true; // true = dropdown only, no free text
        }

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            return sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value != null)
            {
                string inputValue = value.ToString();
                
                // If it already contains separator, it's already a combined value
                if (inputValue.Contains(Separator))
                    return inputValue;
                
                // If it's a display value, convert to combined value
                if (DisplayToCombined.TryGetValue(inputValue, out string combinedValue))
                    return combinedValue;
                
                // If it's an internal value, convert to combined value
                if (InternalToCombined.TryGetValue(inputValue, out combinedValue))
                    return combinedValue;
                
                // Legacy format handling: try normalized comparison
                string normalized = inputValue.Replace("", "x");
                foreach (var kvp in DisplayToCombined)
                {
                    if (kvp.Key.Replace("", "x") == normalized)
                        return kvp.Value;
                }
            }
            return ""; // default
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            if (destinationType == typeof(string))
            {
                if (value != null)
                {
                    string combinedValue = value.ToString();
                    
                    // If it contains separator, extract display part for UI
                    if (combinedValue.Contains(Separator))
                        return GetDisplayValue(combinedValue);
                    
                    // If it's a display value, return it
                    if (DisplayToCombined.ContainsKey(combinedValue))
                        return combinedValue;
                    
                    // If it's an internal value, convert to display
                    if (InternalToCombined.TryGetValue(combinedValue, out string combined))
                        return GetDisplayValue(combined);
                }
                return "";
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            return new StandardValuesCollection(DisplayValues);
        }
    }

    public class TickHunterHotKeyValueConverter : StringConverter
    {
        private static readonly string[] DisplayValues = new string[]
        {
            "",
            "NumLock + 0",
            "NumLock + 1",
            "NumLock + 2",
            "NumLock + 3",
            "NumLock + 4",
            "NumLock + 5",
            "NumLock + 6",
            "NumLock + 7",
            "NumLock + 8",
            "NumLock + 9",
            "NumLock + /",
            "NumLock + *",
            "NumLock + -",
            "NumLock + +",
            "NumLock + Enter",
            "NumLock + ."
        };

        public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
        {
            return true; // enables dropdown
        }

        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
        {
            return true; // true = dropdown only, no free text
        }

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            return sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value != null)
            {
                string displayName = value.ToString();
                // Validate it's a valid display value, otherwise return empty string
                foreach (string validValue in DisplayValues)
                {
                    if (validValue == displayName)
                        return displayName;
                }
            }
            return ""; // default
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            if (destinationType == typeof(string))
            {
                if (value != null)
                {
                    string displayName = value.ToString();
                    // Validate it's a valid display value
                    foreach (string validValue in DisplayValues)
                    {
                        if (validValue == displayName)
                            return displayName;
                    }
                }
                return "";
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            return new StandardValuesCollection(DisplayValues);
        }
    }


    public enum TickHunterBreakEvenAutoTypes
    {
        Disabled = 0,
        HODL = 1,
        Enabled = 2,
        PlusTrail1Bar = 3,
        PlusTrail2Bar = 4,
        PlusTrail3Bar = 5,
        PlusTrail5Bar = 6,
        PlusTrailMix = 7,
        PlusTrailSpeedLine = 8,
        PlusTrailRushLine = 9,
        PlusTrailRiver1 = 10,
        PlusTrailRiver5 = 11,
        PlusTrailCreek1 = 12,
        PlusTrailCreek5 = 13,
        PlusTrailKLineDual = 14,
        PlusTrailZipLine2 = 15,
        PlusTrailZipLineDual = 16,
        PlusTrailKZ = 17,
        PlusTrailBoss = 18,
        PlusTrailStingRay = 19,
        PlusTrailMonster = 20,
        PlusTrailDriftMonster = 21,
        PlusTrailDriftLine1 = 22,
        PlusTrailDriftLine2 = 23,
        PlusTrailDriftLine3 = 24,
        PlusTrailDriftLine4 = 25,
        PlusTrailMovingAverage1 = 26,
        PlusTrailMovingAverage2 = 27,
        PlusTrailMovingAverage3 = 28,
        PlusTrailMovingAverage4 = 29,
        PlusTrailZombieFlip = 30,
        CreeperZombieFlipTrail = 31,
        CreeperFlipTrail = 32,
        ZombieFlipResumeTrail = 33,
        ProfilePeppy = 34,
        ProfileSleepy = 35
    };

    public enum TickHunterBreakEvenAutoTrailNowTypes
    {
        Disabled = 0,
        TrailNowBeforeBE = 1,
        TrailNowAfterProfit = 2
    };

    public enum TickHunterProfitTargetTypes
    {
        Disabled = 0,
        EquityCloseAllTarget = 1,
        BogeyTarget = 2
    };

    public enum TickHunterCloseAutoTypes
    {
        Disabled = 0,
        ZombieFlip = 1,
        ZombieStackedFlip = 2,
        ZombieBoostedFlip = 3,
        CreeperFlip = 4,
        KLineDualFlip = 5,
        ZLineDualFlip = 6,
        KZFlip = 7,
        MovingAverage1Slope = 8,
        MovingAverage2Slope = 9,
        MovingAverage3Slope = 10,
        MovingAverage4Break = 11,
        DriftLine4Break = 12,
        ProfilePeppy = 13,
        ProfileSleepy = 14
    };

    public enum TickHunterTradeSignalTypes
    {
        Disabled = 0,
        BuySellAll = 1,
        BuySellFiltered = 2,
        BuyOnly = 3,
        SellOnly = 4
    };

    public enum TickHunterAutoPilotProfileTypes
    {
        Disabled = 0,
        Peppy = 1,
        Sleepy = 2
    };

    public enum TickHunterPopTypes
    {
        PopPlus = 1,
        PopMinus = 2
    };

    public enum TickHunterAutoPilotProfileSetupTypes
    {
        CreeperOnly = 0,
        ZombieOnly = 1,
        SliderOnly = 2,
        CreeperOrSliderCombo = 3,
        ZombieOrSliderCombo = 4,
        ZombieOrCreeperCombo = 5,
        ZombieOrCreeperOrSliderCombo = 6
    };

    public enum TickHunterAutoPilotLiteTypes
    {
        Disabled = 0,
        NextSetup = 1,
        NextFilteredSetup = 2,
        BuySetup = 3,
        SellSetup = 4,
        AlertSetup = 5
    };

    public enum TickHunterAutoPilotSetupTypes
    {
        CreeperOnly = 0,
        ZombieOnly = 1,
        WalkerOnly = 2,
        CreeperOrCZCombo = 3,
        ZombieBoostedOnly = 4,
        ZombieStackedOnly = 5,
        ZombieBoostedOrStackedCombo = 6,
        ZombieOrCreeperCombo = 7,
        ZombieOrRiverBreakCombo = 8,
        ZombieOrDriftBreakCombo = 9,
        CreeperOrDriftBreakCombo = 10,
        CreeperOrRiverBreakCombo = 11,
        StingRayBreakOnly = 12,
        PeppySetupCombo = 13,
        SleepySetupCombo = 16
    };

    public enum TickHunterAutoPilotTypes
    {
        Disabled = 0,
        TradeCount1 = 1,
        TradeCount2 = 2,
        TradeCount3 = 3,
        TradeCount4 = 4,
        TradeCount5 = 5,
        TradeCount6 = 6,
        TradeCount7 = 7,
        TradeCount8 = 8,
        TradeCount9 = 9,
        TradeCount10 = 10,
        TradeCount11 = 11,
        TradeCount12 = 12,
        TradeCount13 = 13,
        TradeCount14 = 14,
        TradeCount15 = 15,
        TradeCount16 = 16,
        TradeCount17 = 17,
        TradeCount18 = 18,
        TradeCount19 = 19,
        TradeCount20 = 20
    };

    public enum TickHunterPopDelayedTypes
    {
        Disabled = 0,
        TradeCount1 = 1,
        TradeCount2 = 2,
        TradeCount3 = 3,
        TradeCount4 = 4,
        TradeCount5 = 5
    };

    public enum TickHunterAutoAddOnTypes
    {
        Disabled = 0,
        Enabled = 1
    };
    public enum TickHunterStopLossSnapTypes
    {
        Disabled = 0,
        Snap1Bar = 1,
        Snap2Bar = 2,
        Snap3Bar = 3,
        Snap4Bar = 4,
        Snap5Bar = 5,
        Snap6Bar = 6,
        Snap7Bar = 7,
        Snap8Bar = 8,
        Snap9Bar = 9,
        Snap10Bar = 10,
        Snap11Bar = 11,
        Snap12Bar = 12,
        Snap13Bar = 13,
        Snap14Bar = 14,
        Snap15Bar = 15,
        Snap16Bar = 16,
        Snap17Bar = 17,
        Snap18Bar = 18,
        Snap19Bar = 19,
        Snap20Bar = 20,
        SnapSpeedLine = 21,
        SnapRushLine = 22,
        SnapZipLine1 = 23,
        SnapZipLine2 = 24,
        SnapZipLine3 = 25,
        SnapZipLine4 = 26,
        SnapDriftLine1 = 27,
        SnapDriftLine2 = 28,
        SnapDriftLine3 = 29,
        SnapDriftLine4 = 30,
        SnapKineticLine1 = 31,
        SnapKineticLine2 = 32,
        SnapRiver1 = 33,
        SnapRiver5 = 34,
        SnapCreek1 = 35,
        SnapCreek5 = 36,
        SnapKeltnerInnerRing = 37,
        SnapStingRayLevel1 = 38,
        SnapStingRayLevel2 = 39,
        SnapStingRayLevel3 = 40,
        SnapStingRayLevel4 = 41,
        SnapStingRayLevel5 = 42,
        SnapStingRayXLevel = 43,
        SnapPBLevel = 44,
        SnapPBLevel10 = 45,
        SnapPBLevel20 = 46,
        SnapPBLevel30 = 47,
        SnapPBLevel40 = 48,
        SnapPBLevel50 = 49,
        SnapProfilePeppy = 50,
        SnapProfileSleepy = 51
    }

    public enum TickHunterAutoPilotOrderTypes
    {
        Market = 0,
        MarketPop = 1
    }

    public enum TickHunterEntryVolumeAutoTypes
    {
        Option1 = 0,
        Option2 = 1,
        Option3 = 2,
        Option4 = 3,
        Option5 = 4
    }

    public enum TickHunterEntryVolumeMaxTypes
    {
        Option1 = 0,
        Option2 = 1,
        Option3 = 2,
        Option4 = 3,
        Option5 = 4
    }
}

namespace NinjaTrader.NinjaScript.Indicators.TickHunterTA.TH
{
    public class RealSessionState
    {
        public long AccountId
        { get; set; }

        public DateTime ChangeDate
        { get; set; }

        public double HighestPnL
        { get; set; }

    }

    public class RealUtility
    {

    }
}
